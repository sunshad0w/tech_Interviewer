{
  "guide_metadata": {
    "created_date": "2025-11-09",
    "target_audience": "Senior Angular разработчики",
    "covered_versions": "Angular 16-19 (с акцентом на современные фичи)",
    "language": "Русский",
    "total_questions": 70,
    "total_chapters": 8,
    "difficulty_level": "Senior",
    "tags": [
      "Angular",
      "Frontend",
      "TypeScript"
    ]
  },
  "guide_chapters": [
    {
      "chapter_number": 1,
      "chapter_title": "Angular Core & Fundamentals",
      "questions": [
        {
          "question_number": 1,
          "question_number_in_chapter": 1,
          "question_chapter": 1,
          "question_title": "Что такое Angular? В чем главные отличия от AngularJS?",
          "answer_markdown": "**Ответ:**\n\n**Angular** - это TypeScript-based платформа для разработки Single Page Applications (SPA), разработанная Google. Начиная с версии 2+, Angular представляет собой полную переработку AngularJS (1.x).\n\n**Ключевые отличия:**\n\n| Характеристика | AngularJS (1.x) | Angular (2+) |\n|---|---|---|\n| **Язык** | JavaScript | TypeScript |\n| **Архитектура** | MVC (Model-View-Controller) | Component-based |\n| **Мобильная поддержка** | ❌ Нет | ✅ Есть (Angular Universal, PWA) |\n| **Performance** | Медленнее (dirty checking) | Быстрее (Zone.js + Change Detection) |\n| **DI (Dependency Injection)** | Простая | Иерархическая, более мощная |\n| **SEO** | Сложно | Проще (Server-Side Rendering) |\n| **Структура** | Controllers + $scope | Components + Services |\n| **Binding syntax** | `ng-model`, `ng-click` | `[(ngModel)]`, `(click)` |\n| **CLI** | ❌ Нет | ✅ Angular CLI |\n| **Модульность** | NgModules не было | NgModules (теперь Standalone) |\n\n**Современная эволюция Angular (v16-19):**\n- **Angular 16**: Signals (fine-grained реактивность)\n- **Angular 17**: Standalone компоненты по умолчанию, новый control flow (`@if`, `@for`)\n- **Angular 18**: Zoneless Change Detection (экспериментально)\n- **Angular 19**: Signals становятся стандартом, улучшенный SSR и Hydration\n\n**Пример компонента (Angular vs AngularJS):**\n\n```typescript\n// AngularJS (1.x)\nangular.module('myApp', [])\n  .controller('MyController', function($scope) {\n    $scope.name = 'John';\n    $scope.greet = function() {\n      alert('Hello ' + $scope.name);\n    };\n  });\n```\n\n```html\n<!-- AngularJS HTML -->\n<div ng-controller=\"MyController\">\n  <input ng-model=\"name\">\n  <button ng-click=\"greet()\">Greet</button>\n</div>\n```\n\n```typescript\n// Angular (современный)\nimport { Component, signal } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  standalone: true,  // Angular 17+\n  template: `\n    <input [(ngModel)]=\"name\" />\n    <button (click)=\"greet()\">Greet</button>\n    <p>Hello {{ name() }}</p>\n  `\n})\nexport class MyComponent {\n  name = signal('John');  // Angular 16+ Signals\n\n  greet() {\n    alert('Hello ' + this.name());\n  }\n}\n```\n\n**Best Practices:**\n- ✅ Используйте TypeScript для строгой типизации\n- ✅ Предпочитайте Standalone Components (Angular 17+)\n- ✅ Используйте Signals для реактивного состояния (Angular 16+)\n- ✅ Применяйте OnPush Change Detection для оптимизации\n- ❌ Избегайте смешивания AngularJS и Angular в одном проекте\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 2,
          "question_number_in_chapter": 2,
          "question_chapter": 1,
          "question_title": "Что такое Angular Signals? Зачем они нужны и как работают?",
          "answer_markdown": "**Ответ:**\n\n**Signals** - это новая система fine-grained реактивности в Angular (с версии 16), которая позволяет отслеживать изменения данных и автоматически обновлять зависимые части приложения **без Zone.js и глобального Change Detection**.\n\n**Зачем нужны:**\n\n1. **Performance** - обновляются только компоненты, использующие изменившийся сигнал\n2. **Простота** - нет необходимости в manual `markForCheck()` или `detectChanges()`\n3. **Zoneless Angular** - можно отказаться от Zone.js (Angular 18+)\n4. **Интеграция с RxJS** - легко конвертировать через `toSignal()` / `toObservable()`\n5. **Glitch-free** - избегает промежуточных inconsistent состояний\n\n**Типы Signals:**\n\n| Тип | Описание | Пример |\n|---|---|---|\n| **Writable Signal** | Можно изменять через `.set()` / `.update()` | `signal(0)` |\n| **Computed Signal** | Вычисляется автоматически из других сигналов | `computed(() => count() * 2)` |\n| **Effect** | Выполняет side-effects при изменении сигналов | `effect(() => console.log(count()))` |\n\n**Примеры использования:**\n\n```typescript\nimport { Component, signal, computed, effect } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  standalone: true,\n  template: `\n    <h2>Count: {{ count() }}</h2>\n    <h3>Double: {{ double() }}</h3>\n    <button (click)=\"increment()\">+</button>\n    <button (click)=\"decrement()\">-</button>\n    <button (click)=\"reset()\">Reset</button>\n  `\n})\nexport class CounterComponent {\n  // Writable Signal\n  count = signal(0);\n\n  // Computed Signal (пересчитывается автоматически)\n  double = computed(() => this.count() * 2);\n\n  constructor() {\n    // Effect (выполняется при изменении count)\n    effect(() => {\n      console.log('Count changed:', this.count());\n\n      // Можно выполнять side-effects\n      if (this.count() > 10) {\n        console.warn('Count is too high!');\n      }\n    });\n  }\n\n  increment() {\n    this.count.update(value => value + 1);  // На основе текущего значения\n  }\n\n  decrement() {\n    this.count.update(value => value - 1);\n  }\n\n  reset() {\n    this.count.set(0);  // Прямая установка значения\n  }\n}\n```\n\n**Работа с объектами и массивами:**\n\n```typescript\nimport { signal } from '@angular/core';\n\ninterface Todo {\n  id: number;\n  title: string;\n  done: boolean;\n}\n\n@Component({...})\nexport class TodoListComponent {\n  todos = signal<Todo[]>([\n    { id: 1, title: 'Learn Signals', done: false }\n  ]);\n\n  // ❌ НЕ РАБОТАЕТ - Signals не отслеживают мутации внутри объектов\n  toggleTodoBad(id: number) {\n    const todo = this.todos().find(t => t.id === id);\n    if (todo) {\n      todo.done = !todo.done;  // Не вызовет обновление!\n    }\n  }\n\n  // ✅ ПРАВИЛЬНО - используйте .mutate() для мутаций\n  toggleTodo(id: number) {\n    this.todos.mutate(todos => {\n      const todo = todos.find(t => t.id === id);\n      if (todo) {\n        todo.done = !todo.done;\n      }\n    });\n  }\n\n  // ✅ ПРАВИЛЬНО - создавайте новый массив через .update()\n  addTodo(title: string) {\n    this.todos.update(todos => [\n      ...todos,\n      { id: Date.now(), title, done: false }\n    ]);\n  }\n\n  // ✅ ПРАВИЛЬНО - фильтрация через .update()\n  removeTodo(id: number) {\n    this.todos.update(todos => todos.filter(t => t.id !== id));\n  }\n}\n```\n\n**Readonly Signals (защита от изменений):**\n\n```typescript\nexport class AuthService {\n  private _user = signal<User | null>(null);\n\n  // Публичный readonly сигнал\n  user = this._user.asReadonly();\n\n  login(user: User) {\n    this._user.set(user);\n  }\n\n  logout() {\n    this._user.set(null);\n  }\n}\n```\n\n**Интеграция с RxJS:**\n\n```typescript\nimport { toSignal, toObservable } from '@angular/core/rxjs-interop';\n\n@Component({...})\nexport class DataComponent {\n  constructor(private http: HttpClient) {}\n\n  // Конвертация Observable → Signal\n  users = toSignal(\n    this.http.get<User[]>('/api/users'),\n    { initialValue: [] }  // Начальное значение обязательно\n  );\n\n  // Конвертация Signal → Observable\n  count = signal(0);\n  count$ = toObservable(this.count);\n\n  ngOnInit() {\n    // Подписка на Observable из Signal\n    this.count$.subscribe(value => {\n      console.log('Count changed:', value);\n    });\n  }\n}\n```\n\n**Signals vs RxJS Observables:**\n\n| Аспект | Signals | RxJS Observables |\n|---|---|---|\n| **Состояние** | Синхронное, всегда имеет значение | Асинхронное, может не иметь значения |\n| **Use Case** | Локальный UI state | Асинхронные потоки (HTTP, WebSocket) |\n| **Операторы** | Ограниченные (`computed`) | Богатая библиотека (map, filter, switchMap, и т.д.) |\n| **Performance** | Быстрее (fine-grained reactivity) | Медленнее (требует Zone.js) |\n| **Subscription** | Не требуется | Требуется (+ unsubscribe) |\n| **Memory leaks** | Нет | Возможны (если не отписаться) |\n\n**Когда использовать Signals:**\n- ✅ Локальное состояние компонента (счетчики, формы, UI флаги)\n- ✅ Производные вычисления (computed values)\n- ✅ Простая реактивность без сложной логики\n\n**Когда использовать RxJS:**\n- ✅ Асинхронные операции (HTTP, WebSocket, Timers)\n- ✅ Сложная обработка потоков (debounce, throttle, switchMap)\n- ✅ Event-based логика (клики, скролл, drag-and-drop)\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте Signals для UI state\ncount = signal(0);\nisLoading = signal(false);\nerrorMessage = signal<string | null>(null);\n\n// ✅ Computed для производных значений\ntotal = computed(() => this.items().reduce((sum, item) => sum + item.price, 0));\n\n// ✅ Effect только для side-effects\neffect(() => {\n  // Логирование, аналитика, localStorage\n  console.log('Count:', this.count());\n  localStorage.setItem('count', String(this.count()));\n});\n\n// ❌ НЕ выполняйте асинхронные операции в computed\nbadComputed = computed(async () => {  // ❌ ERROR\n  return await this.http.get('/api/data');\n});\n\n// ✅ Используйте toSignal для HTTP\ndata = toSignal(this.http.get('/api/data'), { initialValue: [] });\n\n// ❌ НЕ мутируйте объекты напрямую\nuser = signal({ name: 'John', age: 30 });\nbad() {\n  this.user().age++;  // ❌ Не вызовет обновление\n}\n\n// ✅ Используйте .update() или .mutate()\ngood() {\n  this.user.update(u => ({ ...u, age: u.age + 1 }));  // ✅ Создает новый объект\n  // или\n  this.user.mutate(u => u.age++);  // ✅ Мутирует текущий\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 3,
          "question_number_in_chapter": 3,
          "question_chapter": 1,
          "question_title": "Что такое Zone.js и Zoneless Change Detection? В чем разница?",
          "answer_markdown": "**Ответ:**\n\n**Zone.js** - это библиотека, которая **monkey-patches** все асинхронные API браузера (setTimeout, Promise, addEventListener, XMLHttpRequest) и уведомляет Angular о завершении асинхронных операций для запуска Change Detection.\n\n**Как работает Zone.js:**\n\n1. **Перехват async API** - Zone.js заменяет браузерные API своими обертками\n2. **Tracking** - Отслеживает все асинхронные задачи в Angular zone\n3. **Notification** - Когда все задачи завершены, вызывает `ApplicationRef.tick()`\n4. **Change Detection** - Angular проверяет все компоненты на изменения\n\n**Проблемы Zone.js:**\n\n| Проблема | Описание |\n|---|---|\n| **Performance Overhead** | Запускает Change Detection для ВСЕХ компонентов, даже если изменился только один |\n| **Bundle Size** | ~100KB дополнительного кода |\n| **Debugging** | Усложняет stack traces |\n| **Конфликты** | Может конфликтовать с другими библиотеками |\n| **Непредсказуемость** | Не всегда понятно, когда и почему запустился CD |\n\n**Zoneless Change Detection** (Angular 18+):\n\n**Zoneless** приложение - это Angular приложение **без Zone.js**, где Change Detection запускается:\n1. **Signals** - автоматически при изменении signal\n2. **Async Pipe** - автоматически при новом значении Observable\n3. **Manually** - через `ChangeDetectorRef.markForCheck()`\n\n**Включение Zoneless режима:**\n\n```typescript\n// main.ts (Angular 18+)\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideExperimentalZonelessChangeDetection } from '@angular/core';\nimport { AppComponent } from './app/app.component';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideExperimentalZonelessChangeDetection()  // ✅ Zoneless mode\n  ]\n});\n```\n\n**Удалите Zone.js из polyfills:**\n\n```typescript\n// polyfills.ts\n// ❌ Удалите эту строку:\n// import 'zone.js';\n```\n\n**Как работает Zoneless Change Detection:**\n\n```typescript\nimport { Component, signal, ChangeDetectorRef } from '@angular/core';\n\n@Component({\n  selector: 'app-zoneless',\n  standalone: true,\n  template: `\n    <h2>Count: {{ count() }}</h2>\n    <button (click)=\"increment()\">+</button>\n\n    <h3>Manual: {{ manual }}</h3>\n    <button (click)=\"updateManual()\">Update Manual</button>\n  `\n})\nexport class ZonelessComponent {\n  // ✅ Signals работают автоматически\n  count = signal(0);\n\n  increment() {\n    this.count.update(v => v + 1);  // ✅ Автоматически обновит UI\n  }\n\n  // ❌ Обычные свойства НЕ вызывают CD в zoneless режиме\n  manual = 0;\n\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  updateManual() {\n    this.manual++;\n\n    // ✅ Нужно вручную вызвать Change Detection\n    this.cdr.markForCheck();  // Пометить компонент как \"dirty\"\n  }\n}\n```\n\n**Async Pipe в Zoneless:**\n\n```typescript\n@Component({\n  selector: 'app-async',\n  template: `\n    <!-- ✅ Async pipe работает автоматически -->\n    <div *ngFor=\"let user of users$ | async\">\n      {{ user.name }}\n    </div>\n  `\n})\nexport class AsyncComponent {\n  users$ = this.http.get<User[]>('/api/users');\n\n  constructor(private http: HttpClient) {}\n\n  // ✅ Async pipe автоматически вызывает markForCheck() при новом значении\n}\n```\n\n**Сравнение Zone.js vs Zoneless:**\n\n| Аспект | Zone.js | Zoneless |\n|---|---|---|\n| **Automatic CD** | ✅ Да, после любого async | ❌ Нет, только Signals/Async Pipe |\n| **Bundle Size** | ~100KB больше | ✅ Меньше |\n| **Performance** | Медленнее (глобальный CD) | ✅ Быстрее (локальный CD) |\n| **Developer Experience** | ✅ Проще (автоматический) | Сложнее (нужно думать о CD) |\n| **Third-party Libraries** | ✅ Работают автоматически | ⚠️ Могут не работать |\n| **Debugging** | Сложнее (Zone stack traces) | ✅ Проще |\n| **Manual CD** | Редко нужен | Часто нужен для legacy code |\n\n**Миграция на Zoneless:**\n\n```typescript\n// ❌ БЫЛО (Zone.js автоматически запускает CD)\n@Component({...})\nexport class OldComponent {\n  data: any;\n\n  async loadData() {\n    this.data = await fetch('/api/data').then(r => r.json());\n    // ✅ Zone.js автоматически обновит UI\n  }\n}\n\n// ✅ СТАЛО (Zoneless - используем Signals)\n@Component({...})\nexport class NewComponent {\n  data = signal<any>(null);\n\n  async loadData() {\n    const result = await fetch('/api/data').then(r => r.json());\n    this.data.set(result);  // ✅ Signal автоматически обновит UI\n  }\n}\n\n// ✅ ИЛИ с toSignal (рекомендуется)\n@Component({...})\nexport class NewComponent2 {\n  data = toSignal(\n    this.http.get('/api/data'),\n    { initialValue: null }\n  );\n\n  constructor(private http: HttpClient) {}\n}\n```\n\n**Hybrid подход (Zone.js + Signals):**\n\n```typescript\n// main.ts - используем Zone.js с оптимизацией\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideZoneChangeDetection } from '@angular/core';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideZoneChangeDetection({\n      eventCoalescing: true,  // ✅ Объединяет события\n      runCoalescing: true     // ✅ Объединяет zone.run() вызовы\n    })\n  ]\n});\n```\n\n**NgZone.runOutsideAngular() для оптимизации:**\n\n```typescript\n@Component({...})\nexport class PerformanceComponent {\n  constructor(private ngZone: NgZone) {}\n\n  setupMouseTracking() {\n    // ❌ Плохо - каждое движение мыши вызывает CD\n    window.addEventListener('mousemove', (event) => {\n      this.x = event.clientX;\n      this.y = event.clientY;\n    });\n\n    // ✅ Хорошо - выполняем вне Angular zone\n    this.ngZone.runOutsideAngular(() => {\n      window.addEventListener('mousemove', (event) => {\n        // Эти обновления НЕ вызывают Change Detection\n\n        // Если нужно обновить UI, вернемся в zone\n        if (event.clientX % 100 === 0) {\n          this.ngZone.run(() => {\n            this.x = event.clientX;\n            this.y = event.clientY;\n          });\n        }\n      });\n    });\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте Signals для state\ncount = signal(0);\n\n// ✅ Используйте toSignal для HTTP\nusers = toSignal(this.http.get<User[]>('/api/users'), { initialValue: [] });\n\n// ✅ Используйте Async Pipe для Observables\nusers$ = this.http.get<User[]>('/api/users');\n\n// ✅ Используйте OnPush Change Detection\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\n\n// ✅ Используйте runOutsideAngular для heavy tasks\nthis.ngZone.runOutsideAngular(() => {\n  // Heavy computation\n});\n\n// ❌ НЕ смешивайте Zone.js и Zoneless\n// ❌ НЕ забывайте markForCheck() в zoneless режиме\n// ❌ НЕ используйте setTimeout в zoneless без manual CD\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 4,
          "question_number_in_chapter": 4,
          "question_chapter": 1,
          "question_title": "Как работает Dependency Injection (DI) в Angular? Чем отличается от других фреймворков?",
          "answer_markdown": "**Ответ:**\n\n**Dependency Injection (DI)** в Angular - это паттерн проектирования и встроенный механизм фреймворка для управления зависимостями. Angular автоматически создает и внедряет зависимости в компоненты, сервисы и другие классы.\n\n**Ключевые концепции:**\n\n| Концепция | Описание |\n|---|---|\n| **Provider** | Определяет, как создавать экземпляр сервиса |\n| **Injector** | Контейнер, который хранит и предоставляет зависимости |\n| **Token** | Уникальный идентификатор зависимости (обычно класс) |\n| **Иерархия Injector'ов** | Дерево инжекторов: Root → Module → Component |\n| **Singleton** | По умолчанию сервисы создаются один раз на уровень |\n\n**Основные способы провайдинга:**\n\n```typescript\n// 1. ✅ Root-level (Singleton для всего приложения)\n@Injectable({\n  providedIn: 'root'  // Рекомендуется для большинства сервисов\n})\nexport class UserService {\n  private users = signal<User[]>([]);\n\n  getUsers() {\n    return this.users.asReadonly();\n  }\n}\n\n// 2. Component-level (новый экземпляр для каждого компонента)\n@Component({\n  selector: 'app-user-list',\n  providers: [UserService]  // ⚠️ Каждый компонент получит свой экземпляр\n})\nexport class UserListComponent {\n  constructor(private userService: UserService) {}\n}\n\n// 3. Module-level (Singleton на уровне модуля)\n@NgModule({\n  providers: [UserService]\n})\nexport class UserModule {}\n\n// 4. ✅ Standalone Component (Angular 17+)\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  providers: [LoggerService]  // Только для этого компонента и его детей\n})\nexport class AppComponent {}\n```\n\n**Иерархия Injector'ов:**\n\n```typescript\n// Root Injector\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideHttpClient(),        // ✅ Доступен везде\n    { provide: API_URL, useValue: 'https://api.example.com' }\n  ]\n});\n\n// Component Injector (родитель)\n@Component({\n  selector: 'app-parent',\n  providers: [ParentService]    // Доступен только в Parent и его детях\n})\nexport class ParentComponent {}\n\n// Component Injector (ребенок)\n@Component({\n  selector: 'app-child',\n  providers: [ChildService]     // Доступен только в Child\n})\nexport class ChildComponent {\n  constructor(\n    private parentService: ParentService,  // ✅ Найдет в родителе\n    private childService: ChildService     // ✅ Найдет в себе\n  ) {}\n}\n```\n\n**Типы провайдеров:**\n\n```typescript\n// 1. Class Provider (по умолчанию)\n@Injectable({ providedIn: 'root' })\nexport class RealApiService {\n  getData() { /* ... */ }\n}\n\n// 2. Value Provider (константы, конфигурации)\nexport const API_CONFIG = new InjectionToken<ApiConfig>('API_CONFIG');\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    { provide: API_CONFIG, useValue: { url: 'https://api.com', timeout: 5000 } }\n  ]\n});\n\n// Использование\n@Component({...})\nexport class AppComponent {\n  constructor(@Inject(API_CONFIG) private config: ApiConfig) {\n    console.log(this.config.url);  // 'https://api.com'\n  }\n}\n\n// 3. Factory Provider (создание с логикой)\nexport const API_SERVICE = new InjectionToken<ApiService>('API_SERVICE');\n\nfunction apiServiceFactory(http: HttpClient, config: ApiConfig): ApiService {\n  return config.useMock ? new MockApiService() : new RealApiService(http);\n}\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    {\n      provide: API_SERVICE,\n      useFactory: apiServiceFactory,\n      deps: [HttpClient, API_CONFIG]  // Зависимости для фабрики\n    }\n  ]\n});\n\n// 4. Existing Provider (алиас)\n@Injectable({ providedIn: 'root' })\nexport class LoggerService {}\n\n@Injectable({ providedIn: 'root' })\nexport class ConsoleLoggerService extends LoggerService {}\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    { provide: LoggerService, useExisting: ConsoleLoggerService }\n  ]\n});\n\n// 5. Class Provider с заменой (для тестов)\n@Injectable({ providedIn: 'root' })\nexport class ApiService {}\n\n@Injectable()\nexport class MockApiService extends ApiService {}\n\n// В тестах\nTestBed.configureTestingModule({\n  providers: [\n    { provide: ApiService, useClass: MockApiService }  // ✅ Замена для тестов\n  ]\n});\n```\n\n**Injection Tokens (для non-class зависимостей):**\n\n```typescript\n// Создание токена\nexport const API_URL = new InjectionToken<string>('API_URL');\nexport const FEATURE_FLAGS = new InjectionToken<FeatureFlags>('FEATURE_FLAGS', {\n  providedIn: 'root',\n  factory: () => ({\n    enableNewUI: true,\n    enableBetaFeatures: false\n  })\n});\n\n// Предоставление\nbootstrapApplication(AppComponent, {\n  providers: [\n    { provide: API_URL, useValue: 'https://api.example.com' }\n  ]\n});\n\n// Инжекция\n@Component({...})\nexport class ApiComponent {\n  constructor(\n    @Inject(API_URL) private apiUrl: string,\n    @Inject(FEATURE_FLAGS) private flags: FeatureFlags\n  ) {}\n}\n\n// ✅ Или с inject() функцией (Angular 14+)\nexport class ApiComponent {\n  private apiUrl = inject(API_URL);\n  private flags = inject(FEATURE_FLAGS);\n}\n```\n\n**inject() vs constructor injection:**\n\n```typescript\n// ❌ Старый способ (constructor injection)\n@Component({...})\nexport class OldComponent {\n  constructor(\n    private http: HttpClient,\n    private route: ActivatedRoute,\n    private router: Router,\n    private fb: FormBuilder,\n    @Inject(API_URL) private apiUrl: string\n  ) {}\n}\n\n// ✅ Новый способ (inject function, Angular 14+)\n@Component({...})\nexport class NewComponent {\n  private http = inject(HttpClient);\n  private route = inject(ActivatedRoute);\n  private router = inject(Router);\n  private fb = inject(FormBuilder);\n  private apiUrl = inject(API_URL);\n\n  // ✅ Можно использовать в свойствах\n  users = toSignal(this.http.get<User[]>('/api/users'));\n}\n```\n\n**Optional и Self модификаторы:**\n\n```typescript\n@Component({...})\nexport class FlexibleComponent {\n  // ✅ @Optional - не выбросит ошибку, если сервис не найден\n  constructor(\n    @Optional() private logger?: LoggerService\n  ) {\n    this.logger?.log('Component created');  // Safe navigation\n  }\n\n  // ✅ @Self - ищет только в текущем компоненте\n  constructor(\n    @Self() private localService: LocalService\n  ) {}\n\n  // ✅ @SkipSelf - пропускает текущий компонент, ищет в родителях\n  constructor(\n    @SkipSelf() private parentService: ParentService\n  ) {}\n\n  // ✅ @Host - ищет до ближайшего host элемента\n  constructor(\n    @Host() private hostService: HostService\n  ) {}\n\n  // ✅ Комбинация\n  constructor(\n    @Optional() @Self() private optionalLocalService?: LocalService\n  ) {}\n}\n\n// С inject() функцией\nexport class FlexibleComponent {\n  private logger = inject(LoggerService, { optional: true });\n  private localService = inject(LocalService, { self: true });\n  private parentService = inject(ParentService, { skipSelf: true });\n  private hostService = inject(HostService, { host: true });\n}\n```\n\n**Отличия от других фреймворков:**\n\n| Фреймворк | DI подход | Особенности |\n|---|---|---|\n| **Angular** | ✅ Встроенный, иерархический | Автоматический, типобезопасный, tree-shakeable |\n| **React** | ❌ Нет встроенного | Context API, prop drilling, или библиотеки (InversifyJS) |\n| **Vue 3** | ⚠️ Provide/Inject API | Проще, но менее мощный чем Angular DI |\n| **Nest.js** | ✅ Похож на Angular | Decorator-based, похожий на Angular |\n| **Spring (Java)** | ✅ Встроенный | Annotation-based, reflection-based |\n\n**Multi-providers (несколько значений для одного токена):**\n\n```typescript\nexport const HTTP_INTERCEPTORS = new InjectionToken<HttpInterceptor[]>('HTTP_INTERCEPTORS');\n\n// Регистрация нескольких перехватчиков\nbootstrapApplication(AppComponent, {\n  providers: [\n    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n    { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true },\n    { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true }\n  ]\n});\n\n// Angular соберет их в массив и вызовет по порядку\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте providedIn: 'root' по умолчанию\n@Injectable({ providedIn: 'root' })\nexport class UserService {}\n\n// ✅ Используйте inject() вместо constructor injection\nprivate http = inject(HttpClient);\n\n// ✅ Используйте InjectionToken для не-классов\nexport const API_URL = new InjectionToken<string>('API_URL');\n\n// ✅ Используйте factory provider для условной логики\n{\n  provide: ApiService,\n  useFactory: (config: Config) => config.useMock ? new MockApi() : new RealApi(),\n  deps: [Config]\n}\n\n// ❌ НЕ создавайте сервисы через new\nconst service = new UserService();  // ❌ Плохо\n\n// ✅ Получайте через DI\nprivate userService = inject(UserService);  // ✅ Хорошо\n\n// ❌ НЕ предоставляйте сервисы в компоненте, если нужен singleton\n@Component({\n  providers: [UserService]  // ❌ Каждый компонент получит свой экземпляр\n})\n\n// ✅ Используйте providedIn: 'root'\n@Injectable({ providedIn: 'root' })  // ✅ Один экземпляр на всё приложение\n\n// ✅ Используйте @Optional для необязательных зависимостей\nprivate logger = inject(LoggerService, { optional: true });\n\n// ✅ Используйте destroyRef для cleanup\nexport class MyService {\n  private destroyRef = inject(DestroyRef);\n\n  constructor() {\n    const subscription = interval(1000).subscribe();\n\n    this.destroyRef.onDestroy(() => {\n      subscription.unsubscribe();\n    });\n  }\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 5,
          "question_number_in_chapter": 5,
          "question_chapter": 1,
          "question_title": "Какие есть Component Lifecycle Hooks? В каком порядке они вызываются?",
          "answer_markdown": "**Ответ:**\n\n**Lifecycle Hooks** - это методы, которые Angular вызывает в определенные моменты жизненного цикла компонента/директивы. Они позволяют выполнять код в нужное время.\n\n**Полный список хуков (в порядке вызова):**\n\n| Хук | Вызывается когда | Использование | Вызывается сколько раз |\n|---|---|---|---|\n| **ngOnChanges** | @Input() изменился | Реакция на изменения входных данных | Много раз |\n| **ngOnInit** | Компонент инициализирован | Инициализация, HTTP запросы | 1 раз |\n| **ngDoCheck** | Каждый цикл CD | Кастомная проверка изменений | Очень много |\n| **ngAfterContentInit** | Content projection завершен | Работа с <ng-content> | 1 раз |\n| **ngAfterContentChecked** | Content projection проверен | Проверка projected content | Много раз |\n| **ngAfterViewInit** | View инициализирован | Работа с @ViewChild, DOM | 1 раз |\n| **ngAfterViewChecked** | View проверен | Проверка view изменений | Много раз |\n| **ngOnDestroy** | Перед уничтожением компонента | Cleanup: unsubscribe, clearInterval | 1 раз |\n\n**Диаграмма порядка вызова:**\n\n```\nConstructor\n    ↓\nngOnChanges        (если есть @Input)\n    ↓\nngOnInit           ← Самый популярный\n    ↓\nngDoCheck\n    ↓\nngAfterContentInit\n    ↓\nngAfterContentChecked\n    ↓\nngAfterViewInit\n    ↓\nngAfterViewChecked\n    ↓\n[Компонент работает, CD запускается...]\n    ↓\nngDoCheck → ngAfterContentChecked → ngAfterViewChecked (при каждом CD)\n    ↓\nngOnDestroy        ← Cleanup\n```\n\n**Примеры использования:**\n\n```typescript\nimport {\n  Component, OnInit, OnChanges, OnDestroy,\n  AfterViewInit, DoCheck, SimpleChanges,\n  Input, ViewChild, ElementRef, DestroyRef, inject\n} from '@angular/core';\n\n@Component({\n  selector: 'app-lifecycle',\n  template: `\n    <h2>User: {{ user()?.name }}</h2>\n    <div #content>Content</div>\n  `\n})\nexport class LifecycleComponent implements OnInit, OnChanges, OnDestroy, AfterViewInit {\n  // Angular 16+: DestroyRef вместо ngOnDestroy\n  private destroyRef = inject(DestroyRef);\n\n  @Input() user = input<User>();  // Signal input (Angular 17.1+)\n  @ViewChild('content') content!: ElementRef;\n\n  private subscription?: Subscription;\n\n  // 1️⃣ Constructor - DI, базовая инициализация\n  constructor() {\n    console.log('1. Constructor');\n    // ⚠️ @Input еще НЕ доступны\n    // ⚠️ @ViewChild еще НЕ доступны\n  }\n\n  // 2️⃣ ngOnChanges - при изменении @Input\n  ngOnChanges(changes: SimpleChanges) {\n    console.log('2. ngOnChanges', changes);\n\n    // ✅ Проверка конкретного Input\n    if (changes['user']) {\n      const previous = changes['user'].previousValue;\n      const current = changes['user'].currentValue;\n\n      console.log(`User changed from ${previous?.name} to ${current?.name}`);\n\n      // firstChange === true при первом вызове\n      if (changes['user'].firstChange) {\n        console.log('First time user is set');\n      }\n    }\n  }\n\n  // 3️⃣ ngOnInit - инициализация компонента\n  ngOnInit() {\n    console.log('3. ngOnInit');\n\n    // ✅ @Input уже доступны\n    console.log('User:', this.user());\n\n    // ✅ Идеальное место для:\n    // - HTTP запросов\n    // - Подписок на Observables\n    // - Инициализации данных\n    this.subscription = this.http.get('/api/data').subscribe();\n\n    // ✅ Современный подход - автоматический cleanup\n    this.destroyRef.onDestroy(() => {\n      console.log('Cleanup in DestroyRef');\n      this.subscription?.unsubscribe();\n    });\n  }\n\n  // 4️⃣ ngDoCheck - каждый цикл Change Detection\n  ngDoCheck() {\n    console.log('4. ngDoCheck');\n\n    // ⚠️ Вызывается ОЧЕНЬ часто - будьте осторожны!\n    // Используйте только для кастомной проверки изменений\n  }\n\n  // 5️⃣ ngAfterContentInit - после инициализации <ng-content>\n  ngAfterContentInit() {\n    console.log('5. ngAfterContentInit');\n    // ✅ @ContentChild доступны\n  }\n\n  // 6️⃣ ngAfterContentChecked - после проверки <ng-content>\n  ngAfterContentChecked() {\n    console.log('6. ngAfterContentChecked');\n    // ⚠️ Вызывается часто\n  }\n\n  // 7️⃣ ngAfterViewInit - после инициализации view\n  ngAfterViewInit() {\n    console.log('7. ngAfterViewInit');\n\n    // ✅ @ViewChild доступны\n    console.log('Content element:', this.content.nativeElement);\n\n    // ✅ Идеальное место для:\n    // - Работы с DOM\n    // - Инициализации сторонних библиотек (chart.js, leaflet)\n    // - Измерения размеров элементов\n\n    // ⚠️ НЕ изменяйте данные здесь (вызовет ExpressionChangedAfterItHasBeenCheckedError)\n    // this.someValue = 'new value';  // ❌ Ошибка!\n\n    // ✅ Используйте setTimeout или Promise\n    setTimeout(() => {\n      this.someValue = 'new value';  // ✅ OK\n    });\n  }\n\n  // 8️⃣ ngAfterViewChecked - после проверки view\n  ngAfterViewChecked() {\n    console.log('8. ngAfterViewChecked');\n    // ⚠️ Вызывается очень часто\n  }\n\n  // 9️⃣ ngOnDestroy - перед уничтожением\n  ngOnDestroy() {\n    console.log('9. ngOnDestroy');\n\n    // ✅ Cleanup:\n    // - Отписка от Observables\n    // - Очистка таймеров\n    // - Удаление event listeners\n    this.subscription?.unsubscribe();\n  }\n}\n```\n\n**Современный подход с Signals и DestroyRef:**\n\n```typescript\nimport { Component, inject, DestroyRef, effect } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\n\n@Component({...})\nexport class ModernComponent {\n  private http = inject(HttpClient);\n  private destroyRef = inject(DestroyRef);\n\n  // ✅ Signal inputs (Angular 17.1+) - не требуют ngOnChanges\n  userId = input.required<number>();\n\n  // ✅ Computed - автоматически пересчитывается\n  userIdString = computed(() => `User #${this.userId()}`);\n\n  // ✅ Effect - реагирует на изменения сигналов\n  constructor() {\n    effect(() => {\n      console.log('User ID changed:', this.userId());\n      // Автоматически cleanup при изменении или destroy\n    });\n  }\n\n  // ✅ takeUntilDestroyed - автоматическая отписка\n  users$ = this.http.get<User[]>('/api/users').pipe(\n    takeUntilDestroyed()  // Автоматически отпишется при destroy\n  );\n\n  // ✅ DestroyRef - регистрация cleanup\n  ngOnInit() {\n    const interval = setInterval(() => console.log('tick'), 1000);\n\n    this.destroyRef.onDestroy(() => {\n      clearInterval(interval);\n    });\n  }\n}\n```\n\n**Частые ошибки и решения:**\n\n```typescript\n// ❌ Ошибка: ExpressionChangedAfterItHasBeenCheckedError\n@Component({...})\nexport class BadComponent implements AfterViewInit {\n  message = 'Initial';\n\n  ngAfterViewInit() {\n    this.message = 'Changed';  // ❌ Изменение после проверки!\n  }\n}\n\n// ✅ Решение 1: setTimeout\nngAfterViewInit() {\n  setTimeout(() => {\n    this.message = 'Changed';  // ✅ В следующем цикле\n  });\n}\n\n// ✅ Решение 2: ChangeDetectorRef\nconstructor(private cdr: ChangeDetectorRef) {}\n\nngAfterViewInit() {\n  this.message = 'Changed';\n  this.cdr.detectChanges();  // ✅ Запустить CD вручную\n}\n\n// ✅ Решение 3: Signals (не вызывают эту ошибку)\nmessage = signal('Initial');\n\nngAfterViewInit() {\n  this.message.set('Changed');  // ✅ Сигналы обновляются корректно\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ ngOnInit для инициализации\nngOnInit() {\n  this.loadData();\n  this.setupSubscriptions();\n}\n\n// ✅ ngAfterViewInit для DOM манипуляций\nngAfterViewInit() {\n  this.initChart();\n  this.measureElementSize();\n}\n\n// ✅ ngOnDestroy для cleanup\nngOnDestroy() {\n  this.subscription?.unsubscribe();\n  clearInterval(this.intervalId);\n}\n\n// ✅ Современный подход - DestroyRef\nprivate destroyRef = inject(DestroyRef);\n\nngOnInit() {\n  this.destroyRef.onDestroy(() => {\n    // Cleanup\n  });\n}\n\n// ✅ takeUntilDestroyed для Observable\ndata$ = this.http.get('/api/data').pipe(\n  takeUntilDestroyed()\n);\n\n// ❌ НЕ используйте ngDoCheck без необходимости\nngDoCheck() {\n  // Вызывается ОЧЕНЬ часто!\n}\n\n// ❌ НЕ изменяйте данные в ngAfterViewInit\nngAfterViewInit() {\n  this.value = 'new';  // ❌ ExpressionChangedAfterItHasBeenCheckedError\n}\n\n// ✅ Используйте setTimeout\nngAfterViewInit() {\n  setTimeout(() => this.value = 'new');\n}\n\n// ✅ Или используйте Signals\nvalue = signal('initial');\nngAfterViewInit() {\n  this.value.set('new');  // ✅ OK\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 6,
          "question_number_in_chapter": 6,
          "question_chapter": 1,
          "question_title": "Что такое Change Detection? В чем разница между Default и OnPush стратегиями?",
          "answer_markdown": "**Ответ:**\n\n**Change Detection (CD)** - это механизм Angular для синхронизации состояния модели с view. Angular проверяет, изменились ли данные, и обновляет DOM если нужно.\n\n**Как работает Change Detection:**\n\n```\n1. Событие происходит (click, HTTP response, setTimeout)\n   ↓\n2. Zone.js уведомляет Angular\n   ↓\n3. Angular запускает Change Detection\n   ↓\n4. Проверяет все компоненты на изменения\n   ↓\n5. Обновляет DOM там, где данные изменились\n```\n\n**Две стратегии Change Detection:**\n\n| Стратегия | Когда проверяется | Performance | Использование |\n|---|---|---|---|\n| **Default** | При каждом событии | Медленнее | Простые приложения |\n| **OnPush** | Только при @Input изменении или событиях компонента | ✅ Быстрее | Рекомендуется для production |\n\n**1. Default Strategy:**\n\n```typescript\n@Component({\n  selector: 'app-default',\n  changeDetection: ChangeDetectionStrategy.Default  // По умолчанию\n})\nexport class DefaultComponent {\n  counter = 0;\n\n  increment() {\n    this.counter++;\n    // ✅ Angular автоматически проверит все компоненты в дереве\n  }\n}\n\n// Родительский компонент\n@Component({\n  template: `\n    <app-default></app-default>\n    <button (click)=\"parentClick()\">Parent Button</button>\n  `\n})\nexport class ParentComponent {\n  parentClick() {\n    console.log('Parent clicked');\n    // ⚠️ Angular проверит ВЕСЬ tree, включая ребенка (DefaultComponent)\n  }\n}\n```\n\n**Проблемы Default стратегии:**\n\n```typescript\n@Component({\n  selector: 'app-heavy',\n  template: `\n    <div *ngFor=\"let item of items\">\n      {{ expensiveCalculation(item) }}\n    </div>\n  `\n})\nexport class HeavyComponent {\n  items = Array.from({ length: 1000 }, (_, i) => i);\n\n  expensiveCalculation(item: number): number {\n    console.log('Calculating...', item);  // ⚠️ Вызывается при КАЖДОМ CD!\n    return item * 2;\n  }\n\n  // ⚠️ При ЛЮБОМ событии в приложении Angular вызовет expensiveCalculation 1000 раз!\n}\n```\n\n**2. OnPush Strategy:**\n\n```typescript\n@Component({\n  selector: 'app-onpush',\n  changeDetection: ChangeDetectionStrategy.OnPush,  // ✅ Оптимизация\n  template: `\n    <h2>Count: {{ count }}</h2>\n    <button (click)=\"increment()\">+</button>\n  `\n})\nexport class OnPushComponent {\n  @Input() data!: User;  // Проверяется только при изменении ссылки\n\n  count = 0;\n\n  increment() {\n    this.count++;\n    // ✅ Angular проверит только этот компонент (событие внутри компонента)\n  }\n}\n\n// Родительский компонент\n@Component({\n  template: `\n    <app-onpush [data]=\"user\"></app-onpush>\n    <button (click)=\"changeUser()\">Change User</button>\n  `\n})\nexport class ParentComponent {\n  user = { name: 'John', age: 30 };\n\n  changeUser() {\n    // ❌ Мутация - OnPush НЕ обнаружит изменение\n    this.user.age = 31;\n\n    // ✅ Новая ссылка - OnPush обнаружит изменение\n    this.user = { ...this.user, age: 31 };\n  }\n}\n```\n\n**Когда OnPush компонент проверяется:**\n\n```typescript\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class OnPushComponent {\n  @Input() data!: any;\n\n  // 1️⃣ @Input изменился (новая ссылка)\n  // this.data = newData;\n\n  // 2️⃣ Событие внутри компонента\n  onClick() {\n    console.log('Clicked');  // ✅ Вызовет CD только для этого компонента\n  }\n\n  // 3️⃣ Async pipe получил новое значение\n  users$ = this.http.get<User[]>('/api/users');\n\n  // 4️⃣ Manual trigger через ChangeDetectorRef\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  manualUpdate() {\n    this.cdr.markForCheck();  // ✅ Пометить компонент как dirty\n  }\n}\n```\n\n**OnPush с Observables и Async Pipe:**\n\n```typescript\n@Component({\n  selector: 'app-users',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <!-- ✅ Async pipe автоматически вызывает markForCheck() -->\n    <div *ngFor=\"let user of users$ | async\">\n      {{ user.name }}\n    </div>\n  `\n})\nexport class UsersComponent {\n  users$ = this.http.get<User[]>('/api/users');\n\n  constructor(private http: HttpClient) {}\n\n  // ✅ Async pipe автоматически:\n  // 1. Подписывается на Observable\n  // 2. Вызывает markForCheck() при новом значении\n  // 3. Отписывается при destroy\n}\n```\n\n**OnPush с Signals (Angular 16+):**\n\n```typescript\n@Component({\n  selector: 'app-counter',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <h2>Count: {{ count() }}</h2>\n    <button (click)=\"increment()\">+</button>\n  `\n})\nexport class CounterComponent {\n  // ✅ Signals автоматически работают с OnPush\n  count = signal(0);\n\n  increment() {\n    this.count.update(v => v + 1);\n    // ✅ Signal автоматически помечает компонент как dirty\n    // НЕ нужен manual markForCheck()\n  }\n}\n```\n\n**Частые проблемы с OnPush:**\n\n```typescript\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ProblematicComponent {\n  @Input() users: User[] = [];\n\n  // ❌ Проблема: мутация массива\n  addUserBad(user: User) {\n    this.users.push(user);  // ❌ OnPush не обнаружит (та же ссылка)\n  }\n\n  // ✅ Решение 1: новый массив\n  addUserGood(user: User) {\n    this.users = [...this.users, user];  // ✅ Новая ссылка\n  }\n\n  // ✅ Решение 2: ChangeDetectorRef\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  addUserManual(user: User) {\n    this.users.push(user);\n    this.cdr.markForCheck();  // ✅ Ручной trigger\n  }\n\n  // ✅ Решение 3: Signals (рекомендуется)\n  usersSignal = signal<User[]>([]);\n\n  addUserSignal(user: User) {\n    this.usersSignal.update(users => [...users, user]);  // ✅ Автоматически\n  }\n}\n```\n\n**ChangeDetectorRef API:**\n\n```typescript\nimport { ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ManualComponent {\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  // 1️⃣ markForCheck() - помечает компонент как dirty\n  update() {\n    // Изменения данных\n    this.cdr.markForCheck();  // ✅ CD запустится в следующем цикле\n  }\n\n  // 2️⃣ detectChanges() - немедленный CD только для этого компонента\n  updateNow() {\n    // Изменения данных\n    this.cdr.detectChanges();  // ✅ CD запустится немедленно\n  }\n\n  // 3️⃣ detach() - отключить автоматический CD\n  ngOnInit() {\n    this.cdr.detach();  // ⚠️ Компонент больше не обновляется автоматически\n\n    // Теперь нужно вручную вызывать detectChanges()\n    setInterval(() => {\n      this.someValue++;\n      this.cdr.detectChanges();  // ✅ Ручное обновление\n    }, 1000);\n  }\n\n  // 4️⃣ reattach() - включить обратно автоматический CD\n  enableCD() {\n    this.cdr.reattach();\n  }\n}\n```\n\n**Performance сравнение:**\n\n```typescript\n// ❌ Плохо - Default Strategy\n@Component({\n  changeDetection: ChangeDetectionStrategy.Default\n})\nexport class SlowComponent {\n  items = Array.from({ length: 1000 });\n\n  getTotal() {\n    console.log('Calculating total...');  // ⚠️ Вызывается при каждом CD\n    return this.items.reduce((sum, item) => sum + item.price, 0);\n  }\n}\n\n// ✅ Хорошо - OnPush + Signals\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class FastComponent {\n  items = signal(Array.from({ length: 1000 }));\n\n  // ✅ Computed пересчитывается только при изменении items\n  total = computed(() => {\n    console.log('Calculating total...');  // ✅ Вызывается только при изменении\n    return this.items().reduce((sum, item) => sum + item.price, 0);\n  });\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ ВСЕГДА используйте OnPush\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\n\n// ✅ Используйте Signals для реактивного состояния\ncount = signal(0);\n\n// ✅ Используйте Async Pipe для Observables\nusers$ = this.http.get<User[]>('/api/users');\n\n// ✅ Создавайте новые объекты/массивы вместо мутации\nupdateUser(userId: number, newName: string) {\n  this.users = this.users.map(u =>\n    u.id === userId ? { ...u, name: newName } : u\n  );\n}\n\n// ✅ Используйте trackBy для *ngFor\ntrackByUserId(index: number, user: User) {\n  return user.id;\n}\n\n// ❌ НЕ мутируйте @Input\n@Input() data!: any;\nngOnInit() {\n  this.data.value = 'new';  // ❌ Мутация\n}\n\n// ✅ Эмитьте новый объект\n@Output() dataChange = new EventEmitter();\nngOnInit() {\n  this.dataChange.emit({ ...this.data, value: 'new' });\n}\n\n// ❌ НЕ вызывайте функции в template\n<div>{{ expensiveCalculation() }}</div>  // ❌ Вызывается при каждом CD\n\n// ✅ Используйте Computed Signals\ntotal = computed(() => this.expensiveCalculation());\n<div>{{ total() }}</div>  // ✅ Пересчитывается только при изменении зависимостей\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 7,
          "question_number_in_chapter": 7,
          "question_chapter": 1,
          "question_title": "Что такое Standalone Components? Зачем они нужны?",
          "answer_markdown": "**Ответ:**\n\n**Standalone Components** (Angular 14+, по умолчанию с Angular 17) - это компоненты, которые **не требуют NgModule** для работы. Они самодостаточны и напрямую импортируют свои зависимости.\n\n**Зачем нужны:**\n\n1. ✅ **Проще понять** - все зависимости видны в одном файле\n2. ✅ **Меньше boilerplate** - не нужны NgModule файлы\n3. ✅ **Лучший tree-shaking** - неиспользуемый код удаляется\n4. ✅ **Ленивая загрузка** - проще загружать отдельные компоненты\n5. ✅ **Миграция с других фреймворков** - похоже на React/Vue\n\n**До Standalone (NgModule):**\n\n```typescript\n// user.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-user',\n  template: `<h2>{{ user.name }}</h2>`\n})\nexport class UserComponent {\n  user = { name: 'John' };\n}\n\n// user.module.ts (много boilerplate)\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { UserComponent } from './user.component';\n\n@NgModule({\n  declarations: [UserComponent],\n  imports: [CommonModule],\n  exports: [UserComponent]\n})\nexport class UserModule {}\n\n// app.module.ts\nimport { NgModule } from '@angular/core';\nimport { UserModule } from './user/user.module';\n\n@NgModule({\n  imports: [UserModule]\n})\nexport class AppModule {}\n```\n\n**После Standalone:**\n\n```typescript\n// user.component.ts (все в одном файле)\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-user',\n  standalone: true,  // ✅ Standalone компонент\n  template: `<h2>{{ user.name }}</h2>`\n})\nexport class UserComponent {\n  user = { name: 'John' };\n}\n\n// app.component.ts\nimport { Component } from '@angular/core';\nimport { UserComponent } from './user/user.component';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [UserComponent],  // ✅ Прямой импорт\n  template: `<app-user></app-user>`\n})\nexport class AppComponent {}\n\n// main.ts\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { AppComponent } from './app/app.component';\n\nbootstrapApplication(AppComponent);  // ✅ Без AppModule\n```\n\n**Импорт других компонентов и директив:**\n\n```typescript\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { UserListComponent } from './user-list.component';\nimport { HighlightDirective } from './highlight.directive';\n\n@Component({\n  selector: 'app-users',\n  standalone: true,\n  imports: [\n    CommonModule,        // *ngIf, *ngFor, async pipe\n    FormsModule,         // [(ngModel)]\n    UserListComponent,   // Другой standalone компонент\n    HighlightDirective   // Standalone директива\n  ],\n  template: `\n    <input [(ngModel)]=\"name\" />\n    <div *ngIf=\"users.length > 0\">\n      <app-user-list [users]=\"users\"></app-user-list>\n    </div>\n  `\n})\nexport class UsersComponent {\n  name = '';\n  users = [{ id: 1, name: 'John' }];\n}\n```\n\n**Standalone Directives:**\n\n```typescript\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n  selector: '[appHighlight]',\n  standalone: true  // ✅ Standalone директива\n})\nexport class HighlightDirective {\n  constructor(el: ElementRef) {\n    el.nativeElement.style.backgroundColor = 'yellow';\n  }\n}\n\n// Использование\n@Component({\n  selector: 'app-text',\n  standalone: true,\n  imports: [HighlightDirective],\n  template: `<p appHighlight>Highlighted text</p>`\n})\nexport class TextComponent {}\n```\n\n**Standalone Pipes:**\n\n```typescript\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'capitalize',\n  standalone: true  // ✅ Standalone pipe\n})\nexport class CapitalizePipe implements PipeTransform {\n  transform(value: string): string {\n    return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();\n  }\n}\n\n// Использование\n@Component({\n  selector: 'app-text',\n  standalone: true,\n  imports: [CapitalizePipe],\n  template: `<p>{{ 'hello' | capitalize }}</p>`  // \"Hello\"\n})\nexport class TextComponent {}\n```\n\n**Routing с Standalone:**\n\n```typescript\n// app.routes.ts\nimport { Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { AboutComponent } from './about/about.component';\n\nexport const routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n\n  // ✅ Lazy loading standalone компонента\n  {\n    path: 'users',\n    loadComponent: () =>\n      import('./users/users.component').then(m => m.UsersComponent)\n  },\n\n  // ✅ Lazy loading children routes\n  {\n    path: 'admin',\n    loadChildren: () =>\n      import('./admin/admin.routes').then(m => m.ADMIN_ROUTES)\n  }\n];\n\n// main.ts\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideRouter } from '@angular/router';\nimport { AppComponent } from './app/app.component';\nimport { routes } from './app.routes';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideRouter(routes)\n  ]\n});\n```\n\n**Провайдинг сервисов в Standalone:**\n\n```typescript\n// user.service.ts\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'  // ✅ Root-level singleton\n})\nexport class UserService {\n  getUsers() { /* ... */ }\n}\n\n// Или component-level\n@Component({\n  selector: 'app-users',\n  standalone: true,\n  providers: [UserService]  // ✅ Только для этого компонента\n})\nexport class UsersComponent {\n  constructor(private userService: UserService) {}\n}\n\n// Или в main.ts\nbootstrapApplication(AppComponent, {\n  providers: [\n    UserService,  // Application-level\n    provideHttpClient(),\n    provideAnimations()\n  ]\n});\n```\n\n**Миграция NgModule → Standalone:**\n\n```typescript\n// ❌ БЫЛО (NgModule)\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent\n  ],\n  imports: [\n    BrowserModule,\n    CommonModule,\n    FormsModule,\n    HttpClientModule\n  ],\n  providers: [UserService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n\n// ✅ СТАЛО (Standalone)\n// app.component.ts\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [\n    CommonModule,\n    FormsModule,\n    HeaderComponent,\n    FooterComponent\n  ],\n  template: `\n    <app-header></app-header>\n    <router-outlet></router-outlet>\n    <app-footer></app-footer>\n  `\n})\nexport class AppComponent {}\n\n// main.ts\nimport { provideHttpClient } from '@angular/common/http';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    UserService,\n    provideHttpClient()\n  ]\n});\n```\n\n**Смешивание Standalone и NgModule (переходный период):**\n\n```typescript\n// Импорт NgModule в Standalone компонент\n@Component({\n  selector: 'app-hybrid',\n  standalone: true,\n  imports: [\n    OldNgModule  // ✅ Можно импортировать NgModule в standalone\n  ]\n})\nexport class HybridComponent {}\n\n// Импорт Standalone в NgModule\n@NgModule({\n  imports: [\n    StandaloneComponent  // ✅ Можно импортировать standalone в NgModule\n  ]\n})\nexport class OldModule {}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте standalone: true для всех новых компонентов\n@Component({\n  selector: 'app-my-component',\n  standalone: true,\n  imports: [CommonModule, FormsModule]\n})\n\n// ✅ Импортируйте только то, что используете\nimports: [\n  CommonModule,      // ✅ *ngIf, *ngFor\n  FormsModule,       // ✅ [(ngModel)]\n  UserComponent      // ✅ Другой компонент\n]\n\n// ✅ Используйте loadComponent для lazy loading\n{\n  path: 'users',\n  loadComponent: () => import('./users.component').then(m => m.UsersComponent)\n}\n\n// ✅ Группируйте импорты\nimports: [\n  // Angular modules\n  CommonModule,\n  FormsModule,\n\n  // Third-party\n  NgChartsModule,\n\n  // App components\n  HeaderComponent,\n  FooterComponent\n]\n\n// ❌ НЕ создавайте NgModule для standalone компонентов\n// ❌ НЕ смешивайте подходы без необходимости\n\n// ✅ Мигрируйте постепенно\n// 1. Новые компоненты - standalone\n// 2. Старые компоненты - оставить в NgModule\n// 3. Постепенно конвертировать старые\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 8,
          "question_number_in_chapter": 8,
          "question_chapter": 1,
          "question_title": "Какие основные декораторы есть в Angular и как они работают?",
          "answer_markdown": "**Ответ:**\n\n**Декораторы** в Angular - это TypeScript функции, которые добавляют метаданные к классам, свойствам, методам и параметрам. Они используются для конфигурации компонентов, директив, сервисов и других элементов.\n\n**Основные категории декораторов:**\n\n| Категория | Декораторы | Назначение |\n|---|---|---|\n| **Class decorators** | @Component, @Directive, @Pipe, @Injectable, @NgModule | Определяют тип класса |\n| **Property decorators** | @Input, @Output, @HostBinding, @ContentChild, @ViewChild | Настройка свойств |\n| **Method decorators** | @HostListener | Обработка событий |\n| **Parameter decorators** | @Inject, @Optional, @Self, @SkipSelf, @Host | Настройка DI |\n\n**1. @Component - определение компонента:**\n\n```typescript\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-user',              // CSS selector для компонента\n  standalone: true,                   // Angular 14+: standalone компонент\n  imports: [CommonModule],            // Зависимости (для standalone)\n  template: `<h2>{{ title }}</h2>`,  // Inline template\n  // templateUrl: './user.component.html',  // Или внешний template\n  styles: [`h2 { color: blue; }`],   // Inline styles\n  // styleUrls: ['./user.component.css'],   // Или внешние styles\n  changeDetection: ChangeDetectionStrategy.OnPush,  // Стратегия CD\n  providers: [UserService],           // Component-level провайдеры\n  host: {                             // Host element bindings\n    '[class.active]': 'isActive',\n    '(click)': 'onClick()'\n  }\n})\nexport class UserComponent {\n  title = 'User Component';\n  isActive = true;\n\n  onClick() {\n    console.log('Host clicked');\n  }\n}\n```\n\n**2. @Input - входные свойства:**\n\n```typescript\nimport { Component, Input, input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `\n    <h2>{{ user.name }}</h2>\n    <p>Age: {{ age }}</p>\n  `\n})\nexport class UserCardComponent {\n  // ❌ Старый способ (decorator)\n  @Input() user!: User;\n  @Input() age: number = 0;\n\n  // ✅ Новый способ (Angular 17.1+): Signal inputs\n  userSignal = input.required<User>();  // Обязательный\n  ageSignal = input(0);                 // С default значением\n  nameSignal = input<string>();         // Опциональный\n\n  // Alias для input\n  @Input('userName') name!: string;     // <app-user-card [userName]=\"...\">\n\n  // Transform функция\n  @Input({ transform: booleanAttribute }) isActive!: boolean;\n  // <app-user-card isActive>  // Строка → boolean\n\n  // Setter для дополнительной логики\n  private _role: string = '';\n\n  @Input()\n  set role(value: string) {\n    this._role = value.toUpperCase();\n    console.log('Role changed:', this._role);\n  }\n\n  get role(): string {\n    return this._role;\n  }\n}\n\n// Использование\n@Component({\n  template: `\n    <app-user-card\n      [user]=\"currentUser\"\n      [age]=\"25\"\n      [userName]=\"'John'\"\n      [isActive]=\"true\"\n      [role]=\"'admin'\"\n    ></app-user-card>\n  `\n})\nexport class ParentComponent {\n  currentUser = { name: 'John', email: 'john@example.com' };\n}\n```\n\n**3. @Output - выходные события:**\n\n```typescript\nimport { Component, Output, EventEmitter, output } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  template: `\n    <button (click)=\"increment()\">+</button>\n    <span>{{ count }}</span>\n    <button (click)=\"decrement()\">-</button>\n  `\n})\nexport class CounterComponent {\n  count = 0;\n\n  // ❌ Старый способ (EventEmitter)\n  @Output() countChange = new EventEmitter<number>();\n  @Output() maxReached = new EventEmitter<void>();\n\n  // ✅ Новый способ (Angular 17.3+): Signal outputs\n  countChangeSignal = output<number>();\n  maxReachedSignal = output<void>();\n\n  // Alias\n  @Output('counterUpdated') update = new EventEmitter<number>();\n\n  increment() {\n    this.count++;\n    this.countChange.emit(this.count);  // Эмитим событие\n\n    if (this.count >= 10) {\n      this.maxReached.emit();\n    }\n  }\n\n  decrement() {\n    this.count--;\n    this.countChange.emit(this.count);\n  }\n}\n\n// Использование\n@Component({\n  template: `\n    <app-counter\n      (countChange)=\"onCountChange($event)\"\n      (maxReached)=\"onMaxReached()\"\n    ></app-counter>\n    <p>Parent count: {{ parentCount }}</p>\n  `\n})\nexport class ParentComponent {\n  parentCount = 0;\n\n  onCountChange(newCount: number) {\n    this.parentCount = newCount;\n  }\n\n  onMaxReached() {\n    console.log('Max count reached!');\n  }\n}\n```\n\n**4. @ViewChild и @ViewChildren - доступ к child элементам:**\n\n```typescript\nimport { Component, ViewChild, ViewChildren, QueryList, ElementRef, AfterViewInit } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <input #nameInput type=\"text\" />\n    <button (click)=\"focusInput()\">Focus</button>\n\n    <app-child></app-child>\n    <app-child></app-child>\n    <app-child></app-child>\n\n    <div #container>Container</div>\n  `\n})\nexport class ParentComponent implements AfterViewInit {\n  // ✅ ViewChild - получить первый элемент\n  @ViewChild('nameInput') nameInput!: ElementRef<HTMLInputElement>;\n  @ViewChild(ChildComponent) child!: ChildComponent;\n  @ViewChild('container', { read: ElementRef }) container!: ElementRef;\n\n  // ✅ ViewChildren - получить все элементы (QueryList)\n  @ViewChildren(ChildComponent) children!: QueryList<ChildComponent>;\n  @ViewChildren('nameInput') inputs!: QueryList<ElementRef>;\n\n  // ⚠️ ViewChild доступен только после ngAfterViewInit\n  ngAfterViewInit() {\n    console.log('Input element:', this.nameInput.nativeElement);\n    console.log('Child component:', this.child);\n    console.log('All children:', this.children.toArray());\n\n    // Подписка на изменения QueryList\n    this.children.changes.subscribe((children: QueryList<ChildComponent>) => {\n      console.log('Children changed:', children.length);\n    });\n  }\n\n  focusInput() {\n    this.nameInput.nativeElement.focus();\n  }\n\n  // ✅ ViewChild с { static: true } - доступен в ngOnInit\n  @ViewChild('container', { static: true }) staticContainer!: ElementRef;\n\n  ngOnInit() {\n    // ✅ static: true элементы доступны здесь\n    console.log('Static container:', this.staticContainer);\n\n    // ❌ static: false (default) элементы НЕ доступны\n    // console.log(this.nameInput);  // undefined\n  }\n}\n```\n\n**5. @ContentChild и @ContentChildren - доступ к projected content:**\n\n```typescript\nimport { Component, ContentChild, ContentChildren, QueryList, AfterContentInit } from '@angular/core';\n\n// Child компонент\n@Component({\n  selector: 'app-tab',\n  template: `<div><ng-content></ng-content></div>`\n})\nexport class TabComponent {\n  @Input() title!: string;\n}\n\n// Parent компонент с <ng-content>\n@Component({\n  selector: 'app-tabs',\n  template: `\n    <div class=\"tabs\">\n      <div class=\"tab-headers\">\n        <button *ngFor=\"let tab of tabs\" (click)=\"selectTab(tab)\">\n          {{ tab.title }}\n        </button>\n      </div>\n      <div class=\"tab-content\">\n        <ng-content></ng-content>  <!-- Проецируемый контент -->\n      </div>\n    </div>\n  `\n})\nexport class TabsComponent implements AfterContentInit {\n  // ✅ ContentChild - первый спроецированный элемент\n  @ContentChild(TabComponent) firstTab!: TabComponent;\n\n  // ✅ ContentChildren - все спроецированные элементы\n  @ContentChildren(TabComponent) tabs!: QueryList<TabComponent>;\n\n  // ⚠️ Доступны после ngAfterContentInit\n  ngAfterContentInit() {\n    console.log('First tab:', this.firstTab);\n    console.log('All tabs:', this.tabs.toArray());\n  }\n\n  selectTab(tab: TabComponent) {\n    console.log('Selected tab:', tab.title);\n  }\n}\n\n// Использование\n@Component({\n  template: `\n    <app-tabs>\n      <app-tab title=\"Tab 1\">Content 1</app-tab>\n      <app-tab title=\"Tab 2\">Content 2</app-tab>\n      <app-tab title=\"Tab 3\">Content 3</app-tab>\n    </app-tabs>\n  `\n})\nexport class AppComponent {}\n```\n\n**6. @HostListener и @HostBinding - работа с host элементом:**\n\n```typescript\nimport { Component, HostListener, HostBinding, Directive } from '@angular/core';\n\n@Directive({\n  selector: '[appClickable]',\n  standalone: true\n})\nexport class ClickableDirective {\n  // ✅ HostBinding - привязка к свойствам host элемента\n  @HostBinding('class.active') isActive = false;\n  @HostBinding('style.backgroundColor') bgColor = 'transparent';\n  @HostBinding('attr.aria-pressed') get ariaPressed() {\n    return this.isActive.toString();\n  }\n\n  // ✅ HostListener - обработка событий host элемента\n  @HostListener('click')\n  onClick() {\n    this.isActive = !this.isActive;\n    this.bgColor = this.isActive ? 'lightblue' : 'transparent';\n    console.log('Clicked!');\n  }\n\n  @HostListener('mouseenter')\n  onMouseEnter() {\n    this.bgColor = 'lightgray';\n  }\n\n  @HostListener('mouseleave')\n  onMouseLeave() {\n    this.bgColor = this.isActive ? 'lightblue' : 'transparent';\n  }\n\n  // С параметром $event\n  @HostListener('window:resize', ['$event'])\n  onResize(event: Event) {\n    console.log('Window resized:', (event.target as Window).innerWidth);\n  }\n\n  // Keyboard events\n  @HostListener('keydown', ['$event'])\n  onKeyDown(event: KeyboardEvent) {\n    if (event.key === 'Enter') {\n      this.onClick();\n    }\n  }\n}\n\n// Использование\n@Component({\n  template: `<button appClickable>Click me</button>`\n})\nexport class AppComponent {}\n```\n\n**7. @Injectable - сервисы:**\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n// ✅ providedIn: 'root' - singleton на всё приложение\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  constructor(private http: HttpClient) {}\n\n  getUsers() {\n    return this.http.get<User[]>('/api/users');\n  }\n}\n\n// ✅ providedIn: 'any' - отдельный экземпляр для каждого lazy-loaded модуля\n@Injectable({\n  providedIn: 'any'\n})\nexport class AnalyticsService {}\n\n// ✅ Без providedIn - нужно вручную добавить в providers\n@Injectable()\nexport class LocalService {}\n\n@Component({\n  providers: [LocalService]  // Component-level\n})\nexport class MyComponent {}\n```\n\n**8. Параметр декораторы (@Inject, @Optional, @Self):**\n\n```typescript\nimport { Component, Inject, Optional, Self, SkipSelf, Host } from '@angular/core';\n\nexport const API_URL = new InjectionToken<string>('API_URL');\n\n@Component({...})\nexport class MyComponent {\n  constructor(\n    // ✅ @Inject - инжекция по токену\n    @Inject(API_URL) private apiUrl: string,\n\n    // ✅ @Optional - не выбросит ошибку если не найден\n    @Optional() private logger?: LoggerService,\n\n    // ✅ @Self - ищет только в текущем injector\n    @Self() private localService: LocalService,\n\n    // ✅ @SkipSelf - пропускает текущий injector\n    @SkipSelf() private parentService: ParentService,\n\n    // ✅ @Host - ищет до ближайшего host\n    @Host() private hostService: HostService\n  ) {\n    console.log('API URL:', this.apiUrl);\n    this.logger?.log('Component created');\n  }\n}\n```\n\n**Современный подход - функции вместо декораторов:**\n\n```typescript\nimport { Component, input, output, viewChild, contentChild } from '@angular/core';\n\n@Component({\n  selector: 'app-modern',\n  template: `\n    <input #nameInput />\n    <button (click)=\"handleClick()\">Click</button>\n  `\n})\nexport class ModernComponent {\n  // ✅ Signal inputs (Angular 17.1+)\n  user = input.required<User>();\n  age = input(0);\n\n  // ✅ Signal outputs (Angular 17.3+)\n  userChange = output<User>();\n  deleteClick = output<void>();\n\n  // ✅ Signal queries (Angular 17.2+)\n  nameInput = viewChild<ElementRef>('nameInput');\n  children = viewChildren(ChildComponent);\n\n  projectedTab = contentChild(TabComponent);\n  projectedTabs = contentChildren(TabComponent);\n\n  handleClick() {\n    const inputEl = this.nameInput()?.nativeElement;\n    if (inputEl) {\n      inputEl.focus();\n    }\n\n    this.userChange.emit({ ...this.user(), age: this.age() + 1 });\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте Signal inputs/outputs (Angular 17+)\nuser = input.required<User>();\nuserChange = output<User>();\n\n// ✅ Используйте viewChild/contentChild вместо @ViewChild/@ContentChild\nnameInput = viewChild<ElementRef>('nameInput');\n\n// ✅ Используйте inject() вместо constructor injection\nprivate http = inject(HttpClient);\n\n// ✅ Required inputs\n@Input({ required: true }) userId!: number;\n// или\nuserId = input.required<number>();\n\n// ✅ Transform для inputs\n@Input({ transform: booleanAttribute }) isActive!: boolean;\n\n// ❌ НЕ мутируйте @Input значения\n@Input() user!: User;\nngOnInit() {\n  this.user.name = 'New';  // ❌ Плохо\n}\n\n// ✅ Эмитьте новое значение\n@Output() userChange = new EventEmitter<User>();\nngOnInit() {\n  this.userChange.emit({ ...this.user, name: 'New' });\n}\n\n// ❌ НЕ обращайтесь к @ViewChild в constructor или ngOnInit\nconstructor() {\n  console.log(this.nameInput);  // ❌ undefined\n}\n\n// ✅ Используйте ngAfterViewInit\nngAfterViewInit() {\n  console.log(this.nameInput);  // ✅ Доступен\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 9,
          "question_number_in_chapter": 9,
          "question_chapter": 1,
          "question_title": "Что такое Directives? В чем разница между Structural и Attribute директивами?",
          "answer_markdown": "**Ответ:**\n\n**Directives (директивы)** - это классы, которые добавляют поведение к DOM элементам. Директивы позволяют манипулировать DOM, изменять внешний вид элементов или их поведение.\n\n**Три типа директив в Angular:**\n\n| Тип | Описание | Примеры |\n|---|---|---|\n| **Component** | Директива с template (по сути, компонент - это директива) | @Component |\n| **Structural** | Изменяют структуру DOM (добавляют/удаляют элементы) | *ngIf, *ngFor, *ngSwitch |\n| **Attribute** | Изменяют внешний вид или поведение элемента | ngClass, ngStyle, ngModel |\n\n**1. Structural Directives (структурные):**\n\nСтруктурные директивы **изменяют DOM структуру**, добавляя или удаляя элементы. Используют символ `*` (синтаксический сахар).\n\n**ngIf - условный рендеринг:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Показать/скрыть элемент -->\n    <div *ngIf=\"isLoggedIn\">\n      Welcome, {{ userName }}!\n    </div>\n\n    <!-- ✅ С else блоком -->\n    <div *ngIf=\"users.length > 0; else noUsers\">\n      <ul>\n        <li *ngFor=\"let user of users\">{{ user.name }}</li>\n      </ul>\n    </div>\n    <ng-template #noUsers>\n      <p>No users found</p>\n    </ng-template>\n\n    <!-- ✅ С then и else -->\n    <div *ngIf=\"isLoading; then loading else content\"></div>\n    <ng-template #loading>Loading...</ng-template>\n    <ng-template #content>Content loaded!</ng-template>\n\n    <!-- ✅ С as для хранения результата -->\n    <div *ngIf=\"user$ | async as user\">\n      {{ user.name }}\n    </div>\n\n    <!-- ✅ Новый control flow (Angular 17+) -->\n    @if (isLoggedIn) {\n      <p>Welcome!</p>\n    } @else if (isGuest) {\n      <p>Guest mode</p>\n    } @else {\n      <p>Please login</p>\n    }\n  `\n})\nexport class AppComponent {\n  isLoggedIn = true;\n  isGuest = false;\n  userName = 'John';\n  users = [{ name: 'Alice' }, { name: 'Bob' }];\n  isLoading = false;\n  user$ = this.http.get<User>('/api/user');\n}\n```\n\n**ngFor - циклы:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Простой цикл -->\n    <div *ngFor=\"let user of users\">\n      {{ user.name }}\n    </div>\n\n    <!-- ✅ С index -->\n    <div *ngFor=\"let user of users; let i = index\">\n      {{ i + 1 }}. {{ user.name }}\n    </div>\n\n    <!-- ✅ Все переменные ngFor -->\n    <div *ngFor=\"let user of users;\n                 let i = index;\n                 let first = first;\n                 let last = last;\n                 let even = even;\n                 let odd = odd;\n                 trackBy: trackByUserId\">\n      <span [class.first]=\"first\" [class.last]=\"last\">\n        {{ i + 1 }}. {{ user.name }}\n      </span>\n    </div>\n\n    <!-- ✅ trackBy для оптимизации -->\n    <div *ngFor=\"let user of users; trackBy: trackByUserId\">\n      {{ user.name }}\n    </div>\n\n    <!-- ✅ Новый control flow (Angular 17+) -->\n    @for (user of users; track user.id) {\n      <div>{{ user.name }}</div>\n    } @empty {\n      <p>No users</p>\n    }\n  `\n})\nexport class AppComponent {\n  users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' }\n  ];\n\n  // ✅ trackBy функция для оптимизации\n  trackByUserId(index: number, user: User): number {\n    return user.id;  // Angular будет отслеживать по ID, а не по ссылке\n  }\n}\n```\n\n**ngSwitch - множественный выбор:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ ngSwitch -->\n    <div [ngSwitch]=\"role\">\n      <p *ngSwitchCase=\"'admin'\">Admin panel</p>\n      <p *ngSwitchCase=\"'user'\">User dashboard</p>\n      <p *ngSwitchCase=\"'guest'\">Guest view</p>\n      <p *ngSwitchDefault>Unknown role</p>\n    </div>\n\n    <!-- ✅ Новый control flow (Angular 17+) -->\n    @switch (role) {\n      @case ('admin') {\n        <p>Admin panel</p>\n      }\n      @case ('user') {\n        <p>User dashboard</p>\n      }\n      @default {\n        <p>Guest view</p>\n      }\n    }\n  `\n})\nexport class AppComponent {\n  role: 'admin' | 'user' | 'guest' = 'user';\n}\n```\n\n**Кастомная структурная директива:**\n\n```typescript\nimport { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\n\n// ✅ Директива *appUnless (противоположность *ngIf)\n@Directive({\n  selector: '[appUnless]',\n  standalone: true\n})\nexport class UnlessDirective {\n  constructor(\n    private templateRef: TemplateRef<any>,\n    private viewContainer: ViewContainerRef\n  ) {}\n\n  @Input() set appUnless(condition: boolean) {\n    if (!condition) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n    } else {\n      this.viewContainer.clear();\n    }\n  }\n}\n\n// Использование\n@Component({\n  template: `\n    <p *appUnless=\"isLoggedIn\">Please log in</p>\n  `\n})\nexport class AppComponent {\n  isLoggedIn = false;\n}\n\n// ✅ Директива *appRepeat (повторяет элемент N раз)\n@Directive({\n  selector: '[appRepeat]',\n  standalone: true\n})\nexport class RepeatDirective {\n  constructor(\n    private templateRef: TemplateRef<any>,\n    private viewContainer: ViewContainerRef\n  ) {}\n\n  @Input() set appRepeat(count: number) {\n    this.viewContainer.clear();\n    for (let i = 0; i < count; i++) {\n      this.viewContainer.createEmbeddedView(this.templateRef, {\n        $implicit: i,  // Доступно как let-i\n        index: i\n      });\n    }\n  }\n}\n\n// Использование\n@Component({\n  template: `\n    <div *appRepeat=\"5; let i\">\n      Item {{ i + 1 }}\n    </div>\n  `\n})\n```\n\n**2. Attribute Directives (атрибутные):**\n\nАтрибутные директивы **изменяют поведение или внешний вид** существующего элемента, но не изменяют DOM структуру.\n\n**ngClass - динамические CSS классы:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Строка -->\n    <div [ngClass]=\"'active'\"></div>\n\n    <!-- ✅ Массив -->\n    <div [ngClass]=\"['active', 'highlight']\"></div>\n\n    <!-- ✅ Объект (ключ: класс, значение: условие) -->\n    <div [ngClass]=\"{\n      'active': isActive,\n      'disabled': isDisabled,\n      'highlight': isHighlighted\n    }\"></div>\n\n    <!-- ✅ Выражение -->\n    <div [ngClass]=\"isActive ? 'active' : 'inactive'\"></div>\n\n    <!-- ✅ Функция -->\n    <div [ngClass]=\"getClasses()\"></div>\n  `\n})\nexport class AppComponent {\n  isActive = true;\n  isDisabled = false;\n  isHighlighted = true;\n\n  getClasses() {\n    return {\n      'active': this.isActive,\n      'disabled': this.isDisabled\n    };\n  }\n}\n```\n\n**ngStyle - динамические inline styles:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Объект стилей -->\n    <div [ngStyle]=\"{\n      'color': color,\n      'font-size': fontSize + 'px',\n      'background-color': bgColor\n    }\"></div>\n\n    <!-- ✅ Выражение -->\n    <div [ngStyle]=\"getStyles()\"></div>\n\n    <!-- ✅ Conditional styles -->\n    <div [ngStyle]=\"{\n      'color': isActive ? 'green' : 'red',\n      'font-weight': isActive ? 'bold' : 'normal'\n    }\"></div>\n  `\n})\nexport class AppComponent {\n  color = 'blue';\n  fontSize = 16;\n  bgColor = '#f0f0f0';\n  isActive = true;\n\n  getStyles() {\n    return {\n      'color': this.color,\n      'font-size': this.fontSize + 'px'\n    };\n  }\n}\n```\n\n**Кастомная атрибутная директива:**\n\n```typescript\nimport { Directive, ElementRef, Input, HostListener } from '@angular/core';\n\n// ✅ Директива для подсветки элемента\n@Directive({\n  selector: '[appHighlight]',\n  standalone: true\n})\nexport class HighlightDirective {\n  @Input() appHighlight = 'yellow';  // Цвет подсветки\n  @Input() defaultColor = 'transparent';\n\n  constructor(private el: ElementRef<HTMLElement>) {\n    this.el.nativeElement.style.backgroundColor = this.defaultColor;\n  }\n\n  @HostListener('mouseenter')\n  onMouseEnter() {\n    this.highlight(this.appHighlight);\n  }\n\n  @HostListener('mouseleave')\n  onMouseLeave() {\n    this.highlight(this.defaultColor);\n  }\n\n  private highlight(color: string) {\n    this.el.nativeElement.style.backgroundColor = color;\n  }\n}\n\n// Использование\n@Component({\n  template: `\n    <p appHighlight>Hover me (default yellow)</p>\n    <p [appHighlight]=\"'lightblue'\">Hover me (blue)</p>\n    <p [appHighlight]=\"'pink'\" defaultColor=\"lightgray\">Custom colors</p>\n  `\n})\n\n// ✅ Директива для автофокуса\n@Directive({\n  selector: '[appAutofocus]',\n  standalone: true\n})\nexport class AutofocusDirective {\n  constructor(private el: ElementRef<HTMLElement>) {}\n\n  ngOnInit() {\n    setTimeout(() => {\n      this.el.nativeElement.focus();\n    }, 100);\n  }\n}\n\n// ✅ Директива для debounce input\n@Directive({\n  selector: '[appDebounce]',\n  standalone: true\n})\nexport class DebounceDirective {\n  @Input() appDebounce = 300;  // ms\n  @Output() debounceClick = new EventEmitter();\n\n  private clicks = new Subject();\n\n  constructor() {\n    this.clicks.pipe(\n      debounceTime(this.appDebounce)\n    ).subscribe(e => this.debounceClick.emit(e));\n  }\n\n  @HostListener('click', ['$event'])\n  onClick(event: Event) {\n    event.preventDefault();\n    event.stopPropagation();\n    this.clicks.next(event);\n  }\n}\n```\n\n**Сравнение Structural vs Attribute:**\n\n| Аспект | Structural | Attribute |\n|---|---|---|\n| **Синтаксис** | `*` (звездочка) | `[directive]` |\n| **Влияние на DOM** | Добавляет/удаляет элементы | Изменяет существующие |\n| **Примеры** | *ngIf, *ngFor, *ngSwitch | ngClass, ngStyle, ngModel |\n| **<ng-template>** | Работает с шаблонами | Не использует |\n| **Количество на элементе** | Только одна | Множество |\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте trackBy для *ngFor\n<div *ngFor=\"let item of items; trackBy: trackById\"></div>\n\ntrackById(index: number, item: Item) {\n  return item.id;\n}\n\n// ✅ Используйте новый control flow (Angular 17+)\n@if (condition) {\n  <p>Content</p>\n}\n\n@for (item of items; track item.id) {\n  <div>{{ item.name }}</div>\n}\n\n// ✅ Async pipe для Observables\n<div *ngIf=\"user$ | async as user\">\n  {{ user.name }}\n</div>\n\n// ❌ НЕ используйте несколько structural директив на одном элементе\n<div *ngIf=\"condition\" *ngFor=\"let item of items\"></div>  // ❌ Ошибка\n\n// ✅ Используйте <ng-container>\n<ng-container *ngIf=\"condition\">\n  <div *ngFor=\"let item of items\">{{ item }}</div>\n</ng-container>\n\n// ✅ Именуйте кастомные директивы с префиксом\n@Directive({ selector: '[appHighlight]' })  // ✅ app prefix\n\n// ❌ НЕ используйте ng префикс (зарезервирован для Angular)\n@Directive({ selector: '[ngMyDirective]' })  // ❌ Плохо\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 10,
          "question_number_in_chapter": 10,
          "question_chapter": 1,
          "question_title": "Что такое NgModule? Какая структура и для чего используется?",
          "answer_markdown": "**Ответ:**\n\n**NgModule** - это класс с декоратором @NgModule, который группирует связанные компоненты, директивы, pipes и сервисы. NgModules помогают организовать приложение в cohesive блоки функциональности.\n\n> **Примечание:** С Angular 14+ появились Standalone Components, которые постепенно заменяют NgModules. Angular 17+ использует standalone по умолчанию.\n\n**Структура @NgModule:**\n\n```typescript\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { FormsModule } from '@angular/forms';\nimport { HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n  // 1️⃣ declarations - компоненты, директивы, pipes этого модуля\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    CustomPipe,\n    HighlightDirective\n  ],\n\n  // 2️⃣ imports - другие модули, чьи exported элементы нужны здесь\n  imports: [\n    BrowserModule,      // Для root модуля\n    FormsModule,        // ngModel\n    HttpClientModule,   // HttpClient\n    UserModule,         // Feature модуль\n    RouterModule.forRoot(routes)  // Routing\n  ],\n\n  // 3️⃣ providers - сервисы, доступные в этом модуле\n  providers: [\n    UserService,\n    AuthService,\n    { provide: API_URL, useValue: 'https://api.example.com' }\n  ],\n\n  // 4️⃣ bootstrap - только для root модуля (компонент для запуска)\n  bootstrap: [AppComponent],\n\n  // 5️⃣ exports - делает компоненты/директивы/pipes доступными для других модулей\n  exports: [\n    HeaderComponent,\n    FooterComponent,\n    CustomPipe\n  ]\n})\nexport class AppModule {}\n```\n\n**Типы модулей:**\n\n| Тип | Описание | Пример |\n|---|---|---|\n| **Root Module** | Главный модуль приложения | AppModule |\n| **Feature Module** | Модуль для конкретной фичи | UserModule, AdminModule |\n| **Shared Module** | Общие компоненты/директивы | SharedModule |\n| **Core Module** | Singleton сервисы | CoreModule |\n| **Routing Module** | Маршрутизация | AppRoutingModule |\n\n**1. Root Module (AppModule):**\n\n```typescript\n// app.module.ts\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,  // ✅ Только для root модуля\n    AppRoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]  // ✅ Только для root модуля\n})\nexport class AppModule {}\n\n// main.ts\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nplatformBrowserDynamic().bootstrapModule(AppModule);\n```\n\n**2. Feature Module:**\n\n```typescript\n// user/user.module.ts\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';  // ✅ НЕ BrowserModule\nimport { UserListComponent } from './user-list.component';\nimport { UserDetailComponent } from './user-detail.component';\nimport { UserRoutingModule } from './user-routing.module';\n\n@NgModule({\n  declarations: [\n    UserListComponent,\n    UserDetailComponent\n  ],\n  imports: [\n    CommonModule,  // ✅ Для *ngIf, *ngFor\n    UserRoutingModule\n  ],\n  exports: [\n    UserListComponent  // ✅ Делаем доступным для других модулей\n  ]\n})\nexport class UserModule {}\n```\n\n**3. Shared Module (переиспользуемые компоненты):**\n\n```typescript\n// shared/shared.module.ts\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { LoaderComponent } from './loader.component';\nimport { ModalComponent } from './modal.component';\nimport { CapitalizePipe } from './capitalize.pipe';\nimport { HighlightDirective } from './highlight.directive';\n\n@NgModule({\n  declarations: [\n    LoaderComponent,\n    ModalComponent,\n    CapitalizePipe,\n    HighlightDirective\n  ],\n  imports: [\n    CommonModule\n  ],\n  exports: [\n    // ✅ Экспортируем всё, что может понадобиться другим модулям\n    CommonModule,\n    FormsModule,\n    ReactiveFormsModule,\n    LoaderComponent,\n    ModalComponent,\n    CapitalizePipe,\n    HighlightDirective\n  ]\n})\nexport class SharedModule {}\n\n// Использование в других модулях\n@NgModule({\n  imports: [SharedModule],  // ✅ Получим всё exported из SharedModule\n  declarations: [MyComponent]\n})\nexport class FeatureModule {}\n```\n\n**4. Core Module (singleton сервисы):**\n\n```typescript\n// core/core.module.ts\nimport { NgModule, Optional, SkipSelf } from '@angular/core';\nimport { AuthService } from './auth.service';\nimport { LoggerService } from './logger.service';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { AuthInterceptor } from './auth.interceptor';\n\n@NgModule({\n  providers: [\n    AuthService,\n    LoggerService,\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: AuthInterceptor,\n      multi: true\n    }\n  ]\n})\nexport class CoreModule {\n  // ✅ Гарантируем что CoreModule импортируется только один раз\n  constructor(@Optional() @SkipSelf() parentModule?: CoreModule) {\n    if (parentModule) {\n      throw new Error('CoreModule is already loaded. Import it in AppModule only!');\n    }\n  }\n}\n\n// app.module.ts\n@NgModule({\n  imports: [CoreModule]  // ✅ Только один раз\n})\nexport class AppModule {}\n```\n\n**5. Routing Module:**\n\n```typescript\n// app-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home.component';\nimport { AboutComponent } from './about.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n\n  // ✅ Lazy loading модуля\n  {\n    path: 'users',\n    loadChildren: () =>\n      import('./user/user.module').then(m => m.UserModule)\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],  // forRoot для root модуля\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}\n\n// Feature routing module\n@NgModule({\n  imports: [RouterModule.forChild(routes)],  // forChild для feature модулей\n  exports: [RouterModule]\n})\nexport class UserRoutingModule {}\n```\n\n**Lazy Loading модулей:**\n\n```typescript\n// app-routing.module.ts\nconst routes: Routes = [\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),\n    canLoad: [AuthGuard]  // Guard для проверки доступа\n  },\n  {\n    path: 'users',\n    loadChildren: () => import('./users/users.module').then(m => m.UsersModule)\n  }\n];\n\n// Lazy loaded модуль будет загружен только при переходе на /admin или /users\n```\n\n**Preloading Strategy:**\n\n```typescript\n// app-routing.module.ts\nimport { PreloadAllModules } from '@angular/router';\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, {\n      preloadingStrategy: PreloadAllModules  // ✅ Предзагрузка всех lazy модулей\n    })\n  ]\n})\nexport class AppRoutingModule {}\n\n// Кастомная preloading стратегия\nimport { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nexport class CustomPreloadingStrategy implements PreloadingStrategy {\n  preload(route: Route, load: () => Observable<any>): Observable<any> {\n    return route.data?.['preload'] ? load() : of(null);\n  }\n}\n\n// Использование\nconst routes: Routes = [\n  {\n    path: 'users',\n    loadChildren: () => import('./users/users.module').then(m => m.UsersModule),\n    data: { preload: true }  // ✅ Будет предзагружен\n  }\n];\n```\n\n**forRoot() vs forChild() паттерн:**\n\n```typescript\n// Для модулей с providers (например, RouterModule)\n@NgModule({...})\nexport class CustomModule {\n  // ✅ forRoot() - для root модуля (регистрирует providers)\n  static forRoot(config: ModuleConfig): ModuleWithProviders<CustomModule> {\n    return {\n      ngModule: CustomModule,\n      providers: [\n        { provide: CONFIG, useValue: config }\n      ]\n    };\n  }\n\n  // ✅ forChild() - для feature модулей (без providers)\n  static forChild(): ModuleWithProviders<CustomModule> {\n    return {\n      ngModule: CustomModule,\n      providers: []  // Без providers\n    };\n  }\n}\n\n// Использование\n@NgModule({\n  imports: [\n    CustomModule.forRoot({ apiUrl: 'https://api.com' })  // В AppModule\n  ]\n})\nexport class AppModule {}\n\n@NgModule({\n  imports: [\n    CustomModule.forChild()  // В feature модулях\n  ]\n})\nexport class FeatureModule {}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте Standalone Components (Angular 14+)\n@Component({\n  standalone: true,\n  imports: [CommonModule, FormsModule]\n})\nexport class ModernComponent {}\n\n// ✅ BrowserModule только в AppModule\n@NgModule({\n  imports: [BrowserModule]  // ✅ Root модуль\n})\nexport class AppModule {}\n\n@NgModule({\n  imports: [CommonModule]  // ✅ Feature модули\n})\nexport class FeatureModule {}\n\n// ✅ Lazy loading для крупных модулей\n{\n  path: 'admin',\n  loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)\n}\n\n// ✅ SharedModule для переиспользуемых компонентов\n@NgModule({\n  exports: [CommonModule, FormsModule, LoaderComponent]\n})\nexport class SharedModule {}\n\n// ✅ CoreModule для singleton сервисов\n@NgModule({\n  providers: [AuthService, LoggerService]\n})\nexport class CoreModule {\n  constructor(@Optional() @SkipSelf() parentModule?: CoreModule) {\n    if (parentModule) {\n      throw new Error('CoreModule already loaded');\n    }\n  }\n}\n\n// ❌ НЕ импортируйте SharedModule в CoreModule\n// ❌ НЕ предоставляйте сервисы в SharedModule (используйте providedIn: 'root')\n// ❌ НЕ импортируйте CoreModule больше одного раза\n```",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 2,
      "chapter_title": "Components & Templates",
      "questions": [
        {
          "question_number": 11,
          "question_number_in_chapter": 1,
          "question_chapter": 2,
          "question_title": "Какие виды binding существуют в Angular templates? Примеры использования.",
          "answer_markdown": "**Ответ:**\n\nAngular поддерживает **4 основных типа data binding** для синхронизации данных между компонентом и template.\n\n**Типы Data Binding:**\n\n| Тип | Синтаксис | Направление | Описание |\n|---|---|---|---|\n| **Interpolation** | `{{ value }}` | Component → Template | Вывод данных в template |\n| **Property Binding** | `[property]=\"value\"` | Component → Template | Привязка к свойству DOM/компонента |\n| **Event Binding** | `(event)=\"handler()\"` | Template → Component | Обработка событий |\n| **Two-way Binding** | `[(ngModel)]=\"value\"` | Component ⇄ Template | Двусторонняя синхронизация |\n\n**1. Interpolation ({{ }}) - вставка данных:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Вывод свойств -->\n    <h1>{{ title }}</h1>\n    <p>{{ description }}</p>\n\n    <!-- ✅ Выражения -->\n    <p>2 + 2 = {{ 2 + 2 }}</p>\n    <p>{{ firstName + ' ' + lastName }}</p>\n\n    <!-- ✅ Вызов методов -->\n    <p>{{ getFullName() }}</p>\n    <p>{{ user.getName() }}</p>\n\n    <!-- ✅ Тернарный оператор -->\n    <p>{{ isActive ? 'Active' : 'Inactive' }}</p>\n\n    <!-- ✅ Template expression -->\n    <p>{{ items.length > 0 ? 'Has items' : 'Empty' }}</p>\n\n    <!-- ❌ НЕ РАБОТАЕТ: присваивание, new, ++/-- -->\n    {{ a = 10 }}  <!-- ❌ Ошибка -->\n    {{ new Date() }}  <!-- ❌ Ошибка -->\n    {{ count++ }}  <!-- ❌ Ошибка -->\n  `\n})\nexport class InterpolationComponent {\n  title = 'Angular App';\n  description = 'Learning data binding';\n  firstName = 'John';\n  lastName = 'Doe';\n  isActive = true;\n  items = [1, 2, 3];\n  user = { getName: () => 'John Doe' };\n\n  getFullName(): string {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n```\n\n**2. Property Binding ([property]) - привязка к свойствам:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ DOM свойства -->\n    <img [src]=\"imageUrl\" [alt]=\"imageAlt\">\n    <button [disabled]=\"isDisabled\">Click</button>\n    <input [value]=\"inputValue\" [placeholder]=\"placeholder\">\n\n    <!-- ✅ HTML атрибуты через attr. -->\n    <button [attr.aria-label]=\"ariaLabel\">Button</button>\n    <div [attr.data-id]=\"userId\"></div>\n    <td [attr.colspan]=\"2\"></td>\n\n    <!-- ✅ CSS классы через class. -->\n    <div [class.active]=\"isActive\"></div>\n    <div [class.disabled]=\"isDisabled\"></div>\n    <div [class]=\"'btn btn-primary'\"></div>\n\n    <!-- ✅ Inline styles через style. -->\n    <div [style.color]=\"textColor\"></div>\n    <div [style.font-size.px]=\"fontSize\"></div>\n    <div [style.background-color]=\"bgColor\"></div>\n\n    <!-- ✅ Component inputs -->\n    <app-user-card [user]=\"currentUser\" [age]=\"25\"></app-user-card>\n\n    <!-- ✅ Без квадратных скобок - строка -->\n    <app-user-card user=\"John\"></app-user-card>  <!-- \"John\" as string -->\n\n    <!-- ✅ С квадратными скобками - выражение -->\n    <app-user-card [user]=\"userName\"></app-user-card>  <!-- userName property -->\n  `\n})\nexport class PropertyBindingComponent {\n  imageUrl = 'assets/logo.png';\n  imageAlt = 'Logo';\n  isDisabled = false;\n  inputValue = 'Initial value';\n  placeholder = 'Enter text';\n  ariaLabel = 'Close button';\n  userId = 123;\n  isActive = true;\n  textColor = 'blue';\n  fontSize = 16;\n  bgColor = '#f0f0f0';\n  currentUser = { name: 'John', age: 30 };\n  userName = 'Alice';\n}\n```\n\n**3. Event Binding ((event)) - обработка событий:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Клик события -->\n    <button (click)=\"onClick()\">Click me</button>\n    <button (click)=\"onClickWithParam('Hello')\">Click with param</button>\n\n    <!-- ✅ $event объект -->\n    <button (click)=\"onClickEvent($event)\">Click with event</button>\n    <input (input)=\"onInput($event)\" />\n    <input (keyup)=\"onKeyUp($event)\" />\n\n    <!-- ✅ Keyboard события -->\n    <input (keydown)=\"onKeyDown($event)\" />\n    <input (keyup.enter)=\"onEnter()\" />\n    <input (keyup.escape)=\"onEscape()\" />\n    <input (keyup.shift.a)=\"onShiftA()\" />\n\n    <!-- ✅ Mouse события -->\n    <div (mouseenter)=\"onMouseEnter()\" (mouseleave)=\"onMouseLeave()\">\n      Hover me\n    </div>\n    <div (dblclick)=\"onDoubleClick()\">Double click</div>\n\n    <!-- ✅ Form события -->\n    <form (submit)=\"onSubmit($event)\">\n      <input (change)=\"onChange($event)\" />\n      <input (blur)=\"onBlur()\" (focus)=\"onFocus()\" />\n    </form>\n\n    <!-- ✅ Custom события компонента -->\n    <app-counter (countChange)=\"onCountChange($event)\"></app-counter>\n\n    <!-- ✅ Несколько обработчиков -->\n    <button (click)=\"onClick(); updateCount()\">Multi handlers</button>\n\n    <!-- ✅ Template statement -->\n    <button (click)=\"isActive = !isActive; log('Toggled')\">Toggle</button>\n  `\n})\nexport class EventBindingComponent {\n  onClick() {\n    console.log('Button clicked');\n  }\n\n  onClickWithParam(message: string) {\n    console.log('Message:', message);\n  }\n\n  onClickEvent(event: MouseEvent) {\n    console.log('Click coordinates:', event.clientX, event.clientY);\n    event.preventDefault();  // Отменить default поведение\n    event.stopPropagation(); // Остановить bubbling\n  }\n\n  onInput(event: Event) {\n    const value = (event.target as HTMLInputElement).value;\n    console.log('Input value:', value);\n  }\n\n  onKeyUp(event: KeyboardEvent) {\n    console.log('Key pressed:', event.key);\n  }\n\n  onKeyDown(event: KeyboardEvent) {\n    if (event.ctrlKey && event.key === 's') {\n      event.preventDefault();\n      console.log('Ctrl+S pressed');\n    }\n  }\n\n  onEnter() {\n    console.log('Enter key pressed');\n  }\n\n  onSubmit(event: Event) {\n    event.preventDefault();\n    console.log('Form submitted');\n  }\n\n  onCountChange(newCount: number) {\n    console.log('Count changed:', newCount);\n  }\n\n  log(message: string) {\n    console.log(message);\n  }\n}\n```\n\n**4. Two-way Binding ([(ngModel)]) - двусторонняя привязка:**\n\n```typescript\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  imports: [FormsModule],\n  template: `\n    <!-- ✅ ngModel для input -->\n    <input [(ngModel)]=\"name\" />\n    <p>Hello, {{ name }}</p>\n\n    <!-- ✅ Эквивалент без ngModel (banana in a box) -->\n    <input\n      [value]=\"name\"\n      (input)=\"name = $any($event.target).value\"\n    />\n\n    <!-- ✅ ngModel для checkbox -->\n    <input type=\"checkbox\" [(ngModel)]=\"isActive\" />\n    <p>Active: {{ isActive }}</p>\n\n    <!-- ✅ ngModel для radio -->\n    <input type=\"radio\" [(ngModel)]=\"role\" value=\"admin\" /> Admin\n    <input type=\"radio\" [(ngModel)]=\"role\" value=\"user\" /> User\n    <p>Role: {{ role }}</p>\n\n    <!-- ✅ ngModel для select -->\n    <select [(ngModel)]=\"selectedCity\">\n      <option value=\"NYC\">New York</option>\n      <option value=\"LA\">Los Angeles</option>\n      <option value=\"CHI\">Chicago</option>\n    </select>\n    <p>City: {{ selectedCity }}</p>\n\n    <!-- ✅ Custom two-way binding -->\n    <app-size-picker [(size)]=\"fontSize\"></app-size-picker>\n    <p [style.font-size.px]=\"fontSize\">Text</p>\n  `\n})\nexport class TwoWayBindingComponent {\n  name = 'John';\n  isActive = true;\n  role = 'user';\n  selectedCity = 'NYC';\n  fontSize = 16;\n}\n\n// Custom two-way binding компонент\n@Component({\n  selector: 'app-size-picker',\n  template: `\n    <button (click)=\"decrease()\">-</button>\n    <span>{{ size }}</span>\n    <button (click)=\"increase()\">+</button>\n  `\n})\nexport class SizePickerComponent {\n  @Input() size = 16;\n  @Output() sizeChange = new EventEmitter<number>();\n\n  decrease() {\n    this.size--;\n    this.sizeChange.emit(this.size);\n  }\n\n  increase() {\n    this.size++;\n    this.sizeChange.emit(this.size);\n  }\n}\n```\n\n**Специальные типы binding:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Attribute binding (attr.) -->\n    <button [attr.aria-label]=\"'Close button'\">X</button>\n    <td [attr.colspan]=\"columnSpan\"></td>\n\n    <!-- ✅ Class binding (class.) -->\n    <div [class.active]=\"isActive\"></div>\n    <div [class]=\"'btn btn-primary'\"></div>\n    <div [ngClass]=\"{ 'active': isActive, 'disabled': isDisabled }\"></div>\n\n    <!-- ✅ Style binding (style.) -->\n    <div [style.color]=\"'blue'\"></div>\n    <div [style.font-size.px]=\"16\"></div>\n    <div [ngStyle]=\"{ 'color': 'blue', 'font-size': '16px' }\"></div>\n\n    <!-- ✅ Property vs Attribute -->\n    <input [value]=\"inputValue\">  <!-- Property binding -->\n    <input [attr.value]=\"inputValue\">  <!-- Attribute binding -->\n\n    <!-- ⚠️ Разница: property изменяет DOM, attribute изменяет HTML -->\n  `\n})\nexport class SpecialBindingComponent {\n  columnSpan = 2;\n  isActive = true;\n  isDisabled = false;\n  inputValue = 'test';\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте property binding вместо interpolation для свойств\n<img [src]=\"imageUrl\">  // ✅ Правильно\n<img src=\"{{ imageUrl }}\">  // ❌ Работает, но не рекомендуется\n\n// ✅ Используйте event binding без скобок для template statements\n<button (click)=\"count = count + 1\">+</button>\n\n// ✅ Используйте $event для доступа к event объекту\n<input (input)=\"onInput($event)\">\n\n// ✅ preventDefault и stopPropagation в обработчике\nonClick(event: Event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\n// ❌ НЕ вызывайте сложные функции в template\n{{ expensiveCalculation() }}  // ❌ Вызывается при каждом CD\n\n// ✅ Используйте computed signals\ntotal = computed(() => this.expensiveCalculation());\n{{ total() }}  // ✅ Пересчитывается только при изменении зависимостей\n\n// ❌ НЕ используйте side-effects в template expressions\n{{ updateCounter() }}  // ❌ Плохо\n\n// ✅ Используйте event handlers\n<button (click)=\"updateCounter()\">Update</button>\n\n// ✅ Используйте OnPush + Signals для оптимизации\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class OptimizedComponent {\n  count = signal(0);  // ✅ Signals автоматически обновляют view\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 12,
          "question_number_in_chapter": 2,
          "question_chapter": 2,
          "question_title": "Что такое Template Reference Variables (#var)? Как их использовать?",
          "answer_markdown": "**Ответ:**\n\n**Template Reference Variables** - это переменные, объявленные в template с помощью символа `#` или `ref-`, которые позволяют получить доступ к DOM элементу или директиве/компоненту из template.\n\n**Синтаксис:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Через # -->\n    <input #nameInput type=\"text\" />\n\n    <!-- ✅ Через ref- -->\n    <input ref-emailInput type=\"email\" />\n  `\n})\n```\n\n**Примеры использования:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Доступ к DOM элементу -->\n    <input #nameInput type=\"text\" placeholder=\"Name\" />\n    <button (click)=\"nameInput.focus()\">Focus Input</button>\n    <p>Value: {{ nameInput.value }}</p>\n\n    <!-- ✅ Передача в методы -->\n    <input #emailInput type=\"email\" />\n    <button (click)=\"logValue(emailInput.value)\">Log Email</button>\n\n    <!-- ✅ Доступ к директиве NgForm -->\n    <form #myForm=\"ngForm\" (submit)=\"onSubmit(myForm)\">\n      <input name=\"username\" ngModel required />\n      <button [disabled]=\"!myForm.valid\">Submit</button>\n    </form>\n    <p>Form valid: {{ myForm.valid }}</p>\n\n    <!-- ✅ Доступ к компоненту -->\n    <app-counter #counter></app-counter>\n    <button (click)=\"counter.increment()\">Increment from parent</button>\n    <p>Count: {{ counter.count }}</p>\n\n    <!-- ✅ Использование в *ngFor -->\n    <div *ngFor=\"let item of items; let i = index\">\n      <input #itemInput value=\"{{ item }}\" />\n      <button (click)=\"update(i, itemInput.value)\">Update</button>\n    </div>\n\n    <!-- ✅ С @ViewChild в компоненте -->\n    <video #videoPlayer src=\"movie.mp4\"></video>\n    <button (click)=\"play()\">Play</button>\n  `\n})\nexport class TemplateRefComponent {\n  @ViewChild('videoPlayer') videoPlayer!: ElementRef<HTMLVideoElement>;\n\n  items = ['Item 1', 'Item 2', 'Item 3'];\n\n  logValue(value: string) {\n    console.log('Email:', value);\n  }\n\n  onSubmit(form: NgForm) {\n    console.log('Form value:', form.value);\n    console.log('Form valid:', form.valid);\n  }\n\n  update(index: number, value: string) {\n    this.items[index] = value;\n  }\n\n  play() {\n    this.videoPlayer.nativeElement.play();\n  }\n}\n```\n\n**Типы reference переменных:**\n\n```typescript\n@Component({\n  template: `\n    <!-- 1️⃣ DOM Element -->\n    <input #input1 type=\"text\" />\n    <!-- input1 = HTMLInputElement -->\n\n    <!-- 2️⃣ Directive -->\n    <form #form1=\"ngForm\">\n      <!-- form1 = NgForm directive -->\n    </form>\n\n    <!-- 3️⃣ Component -->\n    <app-child #child1></app-child>\n    <!-- child1 = ChildComponent instance -->\n\n    <!-- 4️⃣ TemplateRef -->\n    <ng-template #template1>\n      <p>Template content</p>\n    </ng-template>\n    <!-- template1 = TemplateRef -->\n\n    <!-- 5️⃣ ng-container -->\n    <ng-container #container1>\n      Content\n    </ng-container>\n    <!-- container1 = Comment node -->\n  `\n})\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте для простых операций в template\n<input #search type=\"text\" />\n<button (click)=\"onSearch(search.value)\">Search</button>\n\n// ✅ Используйте @ViewChild для программного доступа\n@ViewChild('search') searchInput!: ElementRef;\nngAfterViewInit() {\n  this.searchInput.nativeElement.focus();\n}\n\n// ❌ НЕ злоупотребляйте template variables для сложной логики\n<div>{{ nameInput.value.toUpperCase().trim().substring(0, 10) }}</div>  // ❌\n\n// ✅ Используйте методы компонента\n<div>{{ formatName(nameInput.value) }}</div>  // ✅\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 13,
          "question_number_in_chapter": 3,
          "question_chapter": 2,
          "question_title": "Что такое Content Projection (<ng-content>)? Multi-slot projection.",
          "answer_markdown": "**Ответ:**\n\n**Content Projection** - это механизм для вставки контента из родительского компонента в определенные места дочернего компонента через `<ng-content>`.\n\n**Single-slot projection:**\n\n```typescript\n// Child компонент\n@Component({\n  selector: 'app-card',\n  template: `\n    <div class=\"card\">\n      <ng-content></ng-content>  <!-- Весь контент вставится сюда -->\n    </div>\n  `,\n  styles: [`\n    .card {\n      border: 1px solid #ddd;\n      padding: 20px;\n      border-radius: 8px;\n    }\n  `]\n})\nexport class CardComponent {}\n\n// Parent компонент\n@Component({\n  template: `\n    <app-card>\n      <h2>Card Title</h2>\n      <p>Card content goes here</p>\n    </app-card>\n  `\n})\n// Результат:\n// <div class=\"card\">\n//   <h2>Card Title</h2>\n//   <p>Card content goes here</p>\n// </div>\n```\n\n**Multi-slot projection (с селекторами):**\n\n```typescript\n// Child компонент с именованными слотами\n@Component({\n  selector: 'app-card',\n  template: `\n    <div class=\"card\">\n      <div class=\"card-header\">\n        <ng-content select=\"[card-header]\"></ng-content>\n      </div>\n\n      <div class=\"card-body\">\n        <ng-content select=\"[card-body]\"></ng-content>\n      </div>\n\n      <div class=\"card-footer\">\n        <ng-content select=\"[card-footer]\"></ng-content>\n      </div>\n\n      <!-- Default slot для контента без селектора -->\n      <ng-content></ng-content>\n    </div>\n  `\n})\nexport class CardComponent {}\n\n// Parent компонент\n@Component({\n  template: `\n    <app-card>\n      <h2 card-header>My Card Title</h2>\n\n      <div card-body>\n        <p>This is the card body content</p>\n        <button>Action</button>\n      </div>\n\n      <div card-footer>\n        <small>Footer text</small>\n      </div>\n\n      <p>This goes to default slot</p>\n    </app-card>\n  `\n})\n```\n\n**Селекторы для ng-content:**\n\n```typescript\n@Component({\n  selector: 'app-complex-card',\n  template: `\n    <!-- 1️⃣ По атрибуту -->\n    <ng-content select=\"[card-title]\"></ng-content>\n\n    <!-- 2️⃣ По CSS классу -->\n    <ng-content select=\".card-content\"></ng-content>\n\n    <!-- 3️⃣ По тегу -->\n    <ng-content select=\"h1\"></ng-content>\n\n    <!-- 4️⃣ По селектору компонента -->\n    <ng-content select=\"app-custom-component\"></ng-content>\n\n    <!-- 5️⃣ Комбинированный селектор -->\n    <ng-content select=\"div.highlight[important]\"></ng-content>\n\n    <!-- 6️⃣ Default slot (должен быть последним) -->\n    <ng-content></ng-content>\n  `\n})\n```\n\n**Практический пример - Modal компонент:**\n\n```typescript\n@Component({\n  selector: 'app-modal',\n  template: `\n    <div class=\"modal-backdrop\" (click)=\"close()\">\n      <div class=\"modal-content\" (click)=\"$event.stopPropagation()\">\n        <div class=\"modal-header\">\n          <ng-content select=\"[modal-title]\"></ng-content>\n          <button class=\"close\" (click)=\"close()\">×</button>\n        </div>\n\n        <div class=\"modal-body\">\n          <ng-content select=\"[modal-body]\"></ng-content>\n        </div>\n\n        <div class=\"modal-footer\">\n          <ng-content select=\"[modal-footer]\"></ng-content>\n        </div>\n      </div>\n    </div>\n  `\n})\nexport class ModalComponent {\n  @Output() closeModal = new EventEmitter();\n\n  close() {\n    this.closeModal.emit();\n  }\n}\n\n// Использование\n@Component({\n  template: `\n    <app-modal (closeModal)=\"isOpen = false\" *ngIf=\"isOpen\">\n      <h2 modal-title>Confirm Action</h2>\n\n      <div modal-body>\n        <p>Are you sure you want to delete this item?</p>\n      </div>\n\n      <div modal-footer>\n        <button (click)=\"onConfirm()\">Confirm</button>\n        <button (click)=\"isOpen = false\">Cancel</button>\n      </div>\n    </app-modal>\n  `\n})\n```\n\n**@ContentChild и @ContentChildren:**\n\n```typescript\n@Component({\n  selector: 'app-tabs',\n  template: `\n    <div class=\"tab-headers\">\n      <button *ngFor=\"let tab of tabs; let i = index\"\n              (click)=\"selectTab(i)\"\n              [class.active]=\"i === activeIndex\">\n        {{ tab.title }}\n      </button>\n    </div>\n    <div class=\"tab-content\">\n      <ng-content></ng-content>\n    </div>\n  `\n})\nexport class TabsComponent implements AfterContentInit {\n  @ContentChildren(TabComponent) tabs!: QueryList<TabComponent>;\n  activeIndex = 0;\n\n  ngAfterContentInit() {\n    // Показываем только активный таб\n    this.tabs.forEach((tab, i) => {\n      tab.active = i === this.activeIndex;\n    });\n  }\n\n  selectTab(index: number) {\n    this.activeIndex = index;\n    this.tabs.forEach((tab, i) => {\n      tab.active = i === index;\n    });\n  }\n}\n\n@Component({\n  selector: 'app-tab',\n  template: `\n    <div [hidden]=\"!active\">\n      <ng-content></ng-content>\n    </div>\n  `\n})\nexport class TabComponent {\n  @Input() title = '';\n  active = false;\n}\n\n// Использование\n@Component({\n  template: `\n    <app-tabs>\n      <app-tab title=\"Tab 1\">Content 1</app-tab>\n      <app-tab title=\"Tab 2\">Content 2</app-tab>\n      <app-tab title=\"Tab 3\">Content 3</app-tab>\n    </app-tabs>\n  `\n})\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте ng-content для переиспользуемых компонентов-оболочек\n// ✅ Используйте селекторы для структурированного контента\n// ✅ Предоставляйте default slot для гибкости\n\n// ❌ НЕ используйте слишком много слотов (усложняет API)\n// ❌ НЕ передавайте критичную логику через projection (используйте @Input)\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 14,
          "question_number_in_chapter": 4,
          "question_chapter": 2,
          "question_title": "В чем разница между ng-container и ng-template?",
          "answer_markdown": "**Ответ:**\n\n**ng-container** и **ng-template** - это специальные Angular элементы для управления структурой template.\n\n| Аспект | ng-container | ng-template |\n|---|---|---|\n| **Рендеринг** | Не создает DOM элемент | Не рендерится сам по себе |\n| **Использование** | Группировка без создания элемента | Шаблон для условного рендера |\n| **Директивы** | Можно применять структурные директивы | Используется как шаблон |\n| **Видимость** | Контент сразу виден | Требует явного рендера |\n\n**ng-container - группировка без DOM элемента:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ❌ Проблема: нужен wrapper, но не хотим лишний div -->\n    <div *ngIf=\"isLoggedIn\">\n      <h2>Welcome</h2>\n      <p>User dashboard</p>\n    </div>\n    <!-- Создаст: <div><h2>...</h2><p>...</p></div> -->\n\n    <!-- ✅ Решение: ng-container не создает элемент -->\n    <ng-container *ngIf=\"isLoggedIn\">\n      <h2>Welcome</h2>\n      <p>User dashboard</p>\n    </ng-container>\n    <!-- Создаст: <h2>...</h2><p>...</p> (без wrapper) -->\n\n    <!-- ✅ Множественные структурные директивы -->\n    <!-- ❌ Нельзя: <div *ngIf=\"...\" *ngFor=\"...\"> -->\n\n    <!-- ✅ Можно через ng-container -->\n    <ng-container *ngIf=\"users.length > 0\">\n      <div *ngFor=\"let user of users\">\n        {{ user.name }}\n      </div>\n    </ng-container>\n\n    <!-- ✅ Группировка для ngSwitch -->\n    <div [ngSwitch]=\"role\">\n      <ng-container *ngSwitchCase=\"'admin'\">\n        <h2>Admin Panel</h2>\n        <p>Admin features</p>\n      </ng-container>\n      <ng-container *ngSwitchDefault>\n        <h2>User Panel</h2>\n      </ng-container>\n    </div>\n  `\n})\n```\n\n**ng-template - шаблон для условного рендера:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Шаблон не рендерится сам по себе -->\n    <ng-template>\n      <p>This won't be rendered</p>\n    </ng-template>\n\n    <!-- ✅ Использование с *ngIf else -->\n    <div *ngIf=\"users.length > 0; else noUsers\">\n      <ul>\n        <li *ngFor=\"let user of users\">{{ user.name }}</li>\n      </ul>\n    </div>\n    <ng-template #noUsers>\n      <p>No users found</p>\n    </ng-template>\n\n    <!-- ✅ Использование с *ngIf then/else -->\n    <div *ngIf=\"isLoading; then loading else content\"></div>\n    <ng-template #loading>\n      <p>Loading...</p>\n    </ng-template>\n    <ng-template #content>\n      <p>Content loaded!</p>\n    </ng-template>\n\n    <!-- ✅ Переиспользуемый шаблон -->\n    <ng-template #userCard let-user>\n      <div class=\"card\">\n        <h3>{{ user.name }}</h3>\n        <p>{{ user.email }}</p>\n      </div>\n    </ng-template>\n\n    <!-- Использование через ngTemplateOutlet -->\n    <ng-container *ngFor=\"let user of users\">\n      <ng-container *ngTemplateOutlet=\"userCard; context: { $implicit: user }\">\n      </ng-container>\n    </ng-container>\n  `\n})\n```\n\n**ngTemplateOutlet - динамический рендер шаблонов:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Шаблоны -->\n    <ng-template #defaultView>\n      <p>Default view</p>\n    </ng-template>\n\n    <ng-template #detailedView let-data>\n      <div>\n        <h2>{{ data.title }}</h2>\n        <p>{{ data.description }}</p>\n      </div>\n    </ng-template>\n\n    <!-- ✅ Динамический выбор шаблона -->\n    <ng-container *ngTemplateOutlet=\"\n      isDetailed ? detailedView : defaultView;\n      context: { $implicit: itemData }\n    \"></ng-container>\n\n    <!-- ✅ Или через property binding -->\n    <ng-container\n      [ngTemplateOutlet]=\"currentTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: data, index: i }\"\n    ></ng-container>\n  `\n})\nexport class DynamicTemplateComponent {\n  isDetailed = false;\n  itemData = { title: 'Item', description: 'Details' };\n  @ViewChild('detailedView') detailedView!: TemplateRef<any>;\n  @ViewChild('defaultView') defaultView!: TemplateRef<any>;\n\n  get currentTemplate() {\n    return this.isDetailed ? this.detailedView : this.defaultView;\n  }\n}\n```\n\n**Структурные директивы разворачиваются в ng-template:**\n\n```typescript\n// Когда пишем:\n<div *ngIf=\"condition\">Content</div>\n\n// Angular разворачивает в:\n<ng-template [ngIf]=\"condition\">\n  <div>Content</div>\n</ng-template>\n\n// Когда пишем:\n<div *ngFor=\"let item of items; let i = index\">{{ item }}</div>\n\n// Angular разворачивает в:\n<ng-template ngFor let-item [ngForOf]=\"items\" let-i=\"index\">\n  <div>{{ item }}</div>\n</ng-template>\n```\n\n**Практический пример - Loading компонент:**\n\n```typescript\n@Component({\n  selector: 'app-data-view',\n  template: `\n    <ng-container [ngSwitch]=\"state\">\n      <!-- Loading state -->\n      <ng-container *ngSwitchCase=\"'loading'\">\n        <ng-container *ngTemplateOutlet=\"loadingTemplate\"></ng-container>\n      </ng-container>\n\n      <!-- Error state -->\n      <ng-container *ngSwitchCase=\"'error'\">\n        <ng-container *ngTemplateOutlet=\"errorTemplate; context: { $implicit: error }\">\n        </ng-container>\n      </ng-container>\n\n      <!-- Success state -->\n      <ng-container *ngSwitchCase=\"'success'\">\n        <ng-container *ngTemplateOutlet=\"contentTemplate; context: { $implicit: data }\">\n        </ng-container>\n      </ng-container>\n\n      <!-- Empty state -->\n      <ng-container *ngSwitchDefault>\n        <ng-container *ngTemplateOutlet=\"emptyTemplate\"></ng-container>\n      </ng-container>\n    </ng-container>\n\n    <!-- Templates -->\n    <ng-template #loadingTemplate>\n      <div class=\"spinner\">Loading...</div>\n    </ng-template>\n\n    <ng-template #errorTemplate let-error>\n      <div class=\"error\">Error: {{ error.message }}</div>\n    </ng-template>\n\n    <ng-template #contentTemplate let-data>\n      <div class=\"content\">\n        <h2>{{ data.title }}</h2>\n        <p>{{ data.description }}</p>\n      </div>\n    </ng-template>\n\n    <ng-template #emptyTemplate>\n      <p>No data available</p>\n    </ng-template>\n  `\n})\nexport class DataViewComponent {\n  state: 'loading' | 'error' | 'success' | 'empty' = 'loading';\n  data: any;\n  error: any;\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ ng-container для группировки без создания DOM\n<ng-container *ngIf=\"condition\">\n  <h2>Title</h2>\n  <p>Content</p>\n</ng-container>\n\n// ✅ ng-template для условных блоков и переиспользования\n<ng-template #myTemplate let-data>\n  <div>{{ data }}</div>\n</ng-template>\n\n// ✅ Используйте ngTemplateOutlet для динамических шаблонов\n<ng-container *ngTemplateOutlet=\"template; context: ctx\"></ng-container>\n\n// ❌ НЕ используйте ng-container когда нужен реальный DOM элемент\n// ❌ НЕ забывайте про context при использовании let-переменных\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 15,
          "question_number_in_chapter": 5,
          "question_chapter": 2,
          "question_title": "Что такое ViewEncapsulation? Какие режимы существуют?",
          "answer_markdown": "**Ответ:**\n\n**ViewEncapsulation** определяет, как Angular инкапсулирует стили компонента, чтобы они не влияли на другие компоненты.\n\n**Режимы ViewEncapsulation:**\n\n| Режим | Поведение | Использование |\n|---|---|---|\n| **Emulated** (по умолчанию) | Эмулирует Shadow DOM через уникальные атрибуты | Большинство случаев |\n| **ShadowDom** | Использует нативный Shadow DOM | Современные браузеры, изоляция |\n| **None** | Нет инкапсуляции, глобальные стили | Утилитарные компоненты |\n\n**1. Emulated (по умолчанию):**\n\n```typescript\nimport { Component, ViewEncapsulation } from '@angular/core';\n\n@Component({\n  selector: 'app-emulated',\n  encapsulation: ViewEncapsulation.Emulated,  // По умолчанию\n  template: `\n    <h2>Emulated Encapsulation</h2>\n    <p class=\"text\">This text has scoped styles</p>\n  `,\n  styles: [`\n    .text {\n      color: blue;\n      font-size: 16px;\n    }\n  `]\n})\nexport class EmulatedComponent {}\n\n// Сгенерированный HTML:\n// <app-emulated _ngcontent-abc-c123>\n//   <h2 _ngcontent-abc-c123>Emulated Encapsulation</h2>\n//   <p class=\"text\" _ngcontent-abc-c123>This text has scoped styles</p>\n// </app-emulated>\n\n// Сгенерированный CSS:\n// .text[_ngcontent-abc-c123] {\n//   color: blue;\n//   font-size: 16px;\n// }\n```\n\n**2. ShadowDom (нативный):**\n\n```typescript\n@Component({\n  selector: 'app-shadow',\n  encapsulation: ViewEncapsulation.ShadowDom,\n  template: `\n    <h2>Shadow DOM Encapsulation</h2>\n    <p class=\"text\">Fully isolated styles</p>\n  `,\n  styles: [`\n    .text {\n      color: red;\n    }\n  `]\n})\nexport class ShadowComponent {}\n\n// Создает реальный Shadow DOM:\n// <app-shadow>\n//   #shadow-root (open)\n//     <style>\n//       .text { color: red; }\n//     </style>\n//     <h2>Shadow DOM Encapsulation</h2>\n//     <p class=\"text\">Fully isolated styles</p>\n// </app-shadow>\n```\n\n**3. None (без инкапсуляции):**\n\n```typescript\n@Component({\n  selector: 'app-none',\n  encapsulation: ViewEncapsulation.None,\n  template: `\n    <h2>No Encapsulation</h2>\n    <p class=\"global-text\">Global styles</p>\n  `,\n  styles: [`\n    .global-text {\n      color: green;\n      font-weight: bold;\n    }\n  `]\n})\nexport class NoneComponent {}\n\n// Стили добавляются в <head> как глобальные:\n// <style>\n//   .global-text {\n//     color: green;\n//     font-weight: bold;\n//   }\n// </style>\n//\n// ⚠️ Стили будут применены ко всем .global-text в приложении\n```\n\n**Сравнение режимов:**\n\n```typescript\n// Родительский компонент\n@Component({\n  selector: 'app-parent',\n  template: `\n    <style>\n      .text { color: purple; }  /* Глобальный стиль */\n    </style>\n\n    <p class=\"text\">Parent text</p>\n\n    <app-emulated></app-emulated>  <!-- Не затронут parent стилями -->\n    <app-shadow></app-shadow>      <!-- Полностью изолирован -->\n    <app-none></app-none>          <!-- Может быть затронут -->\n  `,\n  encapsulation: ViewEncapsulation.None\n})\n```\n\n**::ng-deep для проникновения через границы:**\n\n```typescript\n@Component({\n  selector: 'app-parent',\n  template: `\n    <app-child>\n      <p class=\"projected\">Projected content</p>\n    </app-child>\n  `,\n  styles: [`\n    /* ❌ Не работает - стили не проникают в child */\n    app-child .projected {\n      color: red;\n    }\n\n    /* ✅ Работает с ::ng-deep */\n    ::ng-deep app-child .projected {\n      color: red;\n    }\n\n    /* ✅ Рекомендуется ограничивать scope */\n    :host ::ng-deep .projected {\n      color: red;\n    }\n  `]\n})\n```\n\n**:host и :host-context:**\n\n```typescript\n@Component({\n  selector: 'app-themed',\n  template: `<p>Themed component</p>`,\n  styles: [`\n    /* ✅ :host - стили для host элемента компонента */\n    :host {\n      display: block;\n      padding: 20px;\n      border: 1px solid #ddd;\n    }\n\n    /* ✅ :host с классом */\n    :host(.active) {\n      border-color: blue;\n    }\n\n    /* ✅ :host-context - стили в зависимости от родителя */\n    :host-context(.dark-theme) p {\n      color: white;\n      background: #333;\n    }\n\n    :host-context(.light-theme) p {\n      color: black;\n      background: #fff;\n    }\n  `]\n})\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте Emulated (default) для большинства компонентов\n@Component({\n  encapsulation: ViewEncapsulation.Emulated\n})\n\n// ✅ Используйте ShadowDom для строгой изоляции\n@Component({\n  encapsulation: ViewEncapsulation.ShadowDom\n})\n\n// ⚠️ Используйте None только для утилитарных/глобальных компонентов\n@Component({\n  encapsulation: ViewEncapsulation.None  // Только для глобальных стилей\n})\n\n// ❌ Избегайте ::ng-deep (deprecated)\n::ng-deep .class { }  // ❌ Будет удалено в будущем\n\n// ✅ Используйте CSS variables для кастомизации\n:host {\n  --primary-color: blue;\n}\np {\n  color: var(--primary-color);\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 16,
          "question_number_in_chapter": 6,
          "question_chapter": 2,
          "question_title": "Что такое Pipes? Как создать кастомный Pipe?",
          "answer_markdown": "**Ответ:**\n\n**Pipes** - это функции для трансформации данных в template. Используются через оператор `|`.\n\n**Встроенные Pipes:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ DatePipe -->\n    {{ today | date }}  <!-- Nov 8, 2025 -->\n    {{ today | date:'short' }}  <!-- 11/8/25, 2:05 PM -->\n    {{ today | date:'fullDate' }}  <!-- Sunday, November 8, 2025 -->\n    {{ today | date:'yyyy-MM-dd HH:mm:ss' }}  <!-- 2025-11-08 14:05:30 -->\n\n    <!-- ✅ UpperCasePipe / LowerCasePipe -->\n    {{ 'hello' | uppercase }}  <!-- HELLO -->\n    {{ 'WORLD' | lowercase }}  <!-- world -->\n\n    <!-- ✅ CurrencyPipe -->\n    {{ 1234.56 | currency }}  <!-- $1,234.56 -->\n    {{ 1234.56 | currency:'EUR' }}  <!-- €1,234.56 -->\n    {{ 1234.56 | currency:'USD':'symbol':'1.0-0' }}  <!-- $1,235 -->\n\n    <!-- ✅ DecimalPipe (number) -->\n    {{ 3.14159 | number }}  <!-- 3.142 -->\n    {{ 3.14159 | number:'1.0-5' }}  <!-- 3.14159 -->\n    {{ 0.259 | percent }}  <!-- 26% -->\n\n    <!-- ✅ JsonPipe (для debug) -->\n    {{ user | json }}  <!-- { \"name\": \"John\", \"age\": 30 } -->\n\n    <!-- ✅ SlicePipe -->\n    {{ 'Hello World' | slice:0:5 }}  <!-- Hello -->\n    {{ [1,2,3,4,5] | slice:1:3 }}  <!-- [2, 3] -->\n\n    <!-- ✅ AsyncPipe (для Observables/Promises) -->\n    {{ users$ | async }}\n\n    <!-- ✅ Chaining pipes -->\n    {{ today | date:'short' | uppercase }}  <!-- 11/8/25, 2:05 PM -->\n    {{ price | currency:'EUR' | uppercase }}  <!-- €1,234.56 -->\n  `\n})\nexport class PipesExampleComponent {\n  today = new Date();\n  user = { name: 'John', age: 30 };\n  price = 1234.56;\n  users$ = this.http.get<User[]>('/api/users');\n}\n```\n\n**Создание кастомного Pipe:**\n\n```typescript\nimport { Pipe, PipeTransform } from '@angular/core';\n\n// ✅ Simple pipe\n@Pipe({\n  name: 'capitalize',\n  standalone: true\n})\nexport class CapitalizePipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) return value;\n    return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();\n  }\n}\n\n// Использование\n@Component({\n  imports: [CapitalizePipe],\n  template: `\n    {{ 'hello world' | capitalize }}  <!-- Hello world -->\n  `\n})\n```\n\n**Pipe с параметрами:**\n\n```typescript\n@Pipe({\n  name: 'truncate',\n  standalone: true\n})\nexport class TruncatePipe implements PipeTransform {\n  transform(value: string, limit: number = 50, suffix: string = '...'): string {\n    if (!value) return value;\n    if (value.length <= limit) return value;\n    return value.substring(0, limit) + suffix;\n  }\n}\n\n// Использование\n@Component({\n  template: `\n    {{ longText | truncate }}  <!-- Default: 50 chars + '...' -->\n    {{ longText | truncate:20 }}  <!-- 20 chars + '...' -->\n    {{ longText | truncate:30:'---' }}  <!-- 30 chars + '---' -->\n  `\n})\n```\n\n**Pure vs Impure Pipes:**\n\n```typescript\n// ✅ Pure Pipe (по умолчанию) - вызывается только при изменении входных данных\n@Pipe({\n  name: 'purePipe',\n  pure: true  // По умолчанию\n})\nexport class PurePipe implements PipeTransform {\n  transform(value: any[]): any[] {\n    console.log('Pure pipe called');  // Вызовется только при изменении ссылки на массив\n    return value.filter(item => item.active);\n  }\n}\n\n// ⚠️ Impure Pipe - вызывается при КАЖДОМ Change Detection\n@Pipe({\n  name: 'impurePipe',\n  pure: false  // Вызывается часто!\n})\nexport class ImpurePipe implements PipeTransform {\n  transform(value: any[]): any[] {\n    console.log('Impure pipe called');  // Вызывается ОЧЕНЬ часто\n    return value.filter(item => item.active);\n  }\n}\n\n@Component({\n  template: `\n    <!-- Pure pipe - нужна новая ссылка для update -->\n    <div *ngFor=\"let item of items | purePipe\">{{ item.name }}</div>\n\n    <!-- Impure pipe - обновится при любом изменении -->\n    <div *ngFor=\"let item of items | impurePipe\">{{ item.name }}</div>\n  `\n})\nexport class PipeComponent {\n  items = [\n    { name: 'Item 1', active: true },\n    { name: 'Item 2', active: false }\n  ];\n\n  addItem() {\n    // ❌ Pure pipe НЕ обновится (та же ссылка)\n    this.items.push({ name: 'Item 3', active: true });\n\n    // ✅ Pure pipe обновится (новая ссылка)\n    this.items = [...this.items, { name: 'Item 3', active: true }];\n  }\n}\n```\n\n**Async Pipe (для Observables):**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Async pipe автоматически подписывается и отписывается -->\n    <div *ngIf=\"users$ | async as users\">\n      <div *ngFor=\"let user of users\">\n        {{ user.name }}\n      </div>\n    </div>\n\n    <!-- ❌ Плохо - создает 3 подписки! -->\n    <div>{{ users$ | async }}</div>\n    <div>{{ users$ | async }}</div>\n    <div>{{ users$ | async }}</div>\n\n    <!-- ✅ Хорошо - одна подписка через as -->\n    <ng-container *ngIf=\"users$ | async as users\">\n      <div>{{ users.length }}</div>\n      <div>{{ users[0]?.name }}</div>\n      <div>{{ users[1]?.name }}</div>\n    </ng-container>\n  `\n})\nexport class AsyncPipeComponent {\n  users$ = this.http.get<User[]>('/api/users');\n\n  constructor(private http: HttpClient) {}\n\n  // ❌ Плохо - нужно вручную отписываться\n  users: User[] = [];\n  subscription?: Subscription;\n\n  ngOnInit() {\n    this.subscription = this.users$.subscribe(users => {\n      this.users = users;\n    });\n  }\n\n  ngOnDestroy() {\n    this.subscription?.unsubscribe();\n  }\n}\n```\n\n**Практические примеры кастомных Pipes:**\n\n```typescript\n// ✅ FilterPipe\n@Pipe({ name: 'filter', standalone: true })\nexport class FilterPipe implements PipeTransform {\n  transform<T>(items: T[], searchText: string, key: keyof T): T[] {\n    if (!items || !searchText) return items;\n    return items.filter(item =>\n      String(item[key]).toLowerCase().includes(searchText.toLowerCase())\n    );\n  }\n}\n// Использование: {{ users | filter:searchText:'name' }}\n\n// ✅ SortPipe\n@Pipe({ name: 'sort', standalone: true })\nexport class SortPipe implements PipeTransform {\n  transform<T>(items: T[], field: keyof T, order: 'asc' | 'desc' = 'asc'): T[] {\n    if (!items) return items;\n    const sorted = [...items].sort((a, b) => {\n      if (a[field] < b[field]) return -1;\n      if (a[field] > b[field]) return 1;\n      return 0;\n    });\n    return order === 'asc' ? sorted : sorted.reverse();\n  }\n}\n// Использование: {{ users | sort:'name':'desc' }}\n\n// ✅ TimeAgoPipe\n@Pipe({ name: 'timeAgo', standalone: true })\nexport class TimeAgoPipe implements PipeTransform {\n  transform(value: Date | string): string {\n    const date = new Date(value);\n    const seconds = Math.floor((Date.now() - date.getTime()) / 1000);\n\n    if (seconds < 60) return 'just now';\n    if (seconds < 3600) return `${Math.floor(seconds / 60)} minutes ago`;\n    if (seconds < 86400) return `${Math.floor(seconds / 3600)} hours ago`;\n    return `${Math.floor(seconds / 86400)} days ago`;\n  }\n}\n// Использование: {{ post.createdAt | timeAgo }}\n\n// ✅ SafeHtmlPipe\n@Pipe({ name: 'safeHtml', standalone: true })\nexport class SafeHtmlPipe implements PipeTransform {\n  constructor(private sanitizer: DomSanitizer) {}\n\n  transform(value: string): SafeHtml {\n    return this.sanitizer.sanitize(SecurityContext.HTML, value) || '';\n  }\n}\n// Использование: <div [innerHTML]=\"htmlContent | safeHtml\"></div>\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте pure pipes (по умолчанию)\n@Pipe({ name: 'myPipe', pure: true })\n\n// ❌ Избегайте impure pipes (performance проблемы)\n@Pipe({ name: 'myPipe', pure: false })  // Вызывается при каждом CD!\n\n// ✅ Используйте async pipe для Observables\n{{ data$ | async }}\n\n// ✅ Создавайте standalone pipes (Angular 14+)\n@Pipe({ name: 'myPipe', standalone: true })\n\n// ❌ НЕ выполняйте тяжелые операции в pipes\ntransform(value: any[]) {\n  return value.filter(...).map(...).reduce(...);  // ❌ Слишком тяжело\n}\n\n// ✅ Кешируйте результаты для impure pipes\nprivate cache = new Map();\ntransform(value: any[]) {\n  if (this.cache.has(value)) return this.cache.get(value);\n  const result = /* computation */;\n  this.cache.set(value, result);\n  return result;\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 17,
          "question_number_in_chapter": 7,
          "question_chapter": 2,
          "question_title": "Как компоненты могут общаться между собой (Component Communication)?",
          "answer_markdown": "**Ответ:**\n\nAngular предоставляет множество способов общения между компонентами.\n\n**1. Parent → Child через @Input:**\n\n```typescript\n// Child компонент\n@Component({\n  selector: 'app-child',\n  template: `<p>{{ message }}</p>`\n})\nexport class ChildComponent {\n  @Input() message!: string;\n  @Input() user!: User;\n\n  // ✅ Modern way (Angular 17.1+)\n  messageSignal = input.required<string>();\n  userSignal = input<User>();\n}\n\n// Parent компонент\n@Component({\n  template: `\n    <app-child [message]=\"parentMessage\" [user]=\"currentUser\"></app-child>\n  `\n})\nexport class ParentComponent {\n  parentMessage = 'Hello from parent';\n  currentUser = { name: 'John', age: 30 };\n}\n```\n\n**2. Child → Parent через @Output:**\n\n```typescript\n// Child компонент\n@Component({\n  selector: 'app-child',\n  template: `\n    <button (click)=\"sendMessage()\">Send to Parent</button>\n  `\n})\nexport class ChildComponent {\n  @Output() messageEvent = new EventEmitter<string>();\n\n  // ✅ Modern way (Angular 17.3+)\n  messageEventSignal = output<string>();\n\n  sendMessage() {\n    this.messageEvent.emit('Hello from child');\n  }\n}\n\n// Parent компонент\n@Component({\n  template: `\n    <app-child (messageEvent)=\"receiveMessage($event)\"></app-child>\n    <p>{{ childMessage }}</p>\n  `\n})\nexport class ParentComponent {\n  childMessage = '';\n\n  receiveMessage(message: string) {\n    this.childMessage = message;\n  }\n}\n```\n\n**3. Parent → Child через @ViewChild:**\n\n```typescript\n// Child компонент\n@Component({\n  selector: 'app-child'\n})\nexport class ChildComponent {\n  childMethod() {\n    console.log('Called from parent');\n  }\n\n  childProperty = 'Child data';\n}\n\n// Parent компонент\n@Component({\n  template: `\n    <app-child></app-child>\n    <button (click)=\"callChild()\">Call Child Method</button>\n  `\n})\nexport class ParentComponent implements AfterViewInit {\n  @ViewChild(ChildComponent) child!: ChildComponent;\n\n  // ✅ Modern way (Angular 17.2+)\n  childSignal = viewChild(ChildComponent);\n\n  ngAfterViewInit() {\n    console.log(this.child.childProperty);  // 'Child data'\n  }\n\n  callChild() {\n    this.child.childMethod();\n  }\n}\n```\n\n**4. Sibling Components через Service:**\n\n```typescript\n// Shared Service\n@Injectable({ providedIn: 'root' })\nexport class MessageService {\n  // ❌ Old way (Subject)\n  private messageSource = new Subject<string>();\n  message$ = this.messageSource.asObservable();\n\n  sendMessage(message: string) {\n    this.messageSource.next(message);\n  }\n\n  // ✅ New way (Signal)\n  private messageSignal = signal<string>('');\n  message = this.messageSignal.asReadonly();\n\n  sendMessageSignal(message: string) {\n    this.messageSignal.set(message);\n  }\n}\n\n// Sibling 1\n@Component({\n  selector: 'app-sibling-one',\n  template: `\n    <button (click)=\"send()\">Send to Sibling 2</button>\n  `\n})\nexport class SiblingOneComponent {\n  constructor(private messageService: MessageService) {}\n\n  send() {\n    this.messageService.sendMessageSignal('Hello from Sibling 1');\n  }\n}\n\n// Sibling 2\n@Component({\n  selector: 'app-sibling-two',\n  template: `<p>{{ message() }}</p>`\n})\nexport class SiblingTwoComponent {\n  message = inject(MessageService).message;\n}\n```\n\n**5. Template Reference Variables:**\n\n```typescript\n@Component({\n  template: `\n    <app-child #child></app-child>\n    <button (click)=\"child.childMethod()\">Call Child</button>\n    <p>{{ child.childProperty }}</p>\n  `\n})\n```\n\n**6. State Management (NgRx, Signals Store):**\n\n```typescript\n// ✅ Angular Signals Store (Angular 17+)\nimport { signalStore, withState, withMethods } from '@ngrx/signals';\n\nexport const UserStore = signalStore(\n  { providedIn: 'root' },\n  withState({ users: [] as User[] }),\n  withMethods((store) => ({\n    addUser(user: User) {\n      patchState(store, { users: [...store.users(), user] });\n    }\n  }))\n);\n\n// Component 1\n@Component({...})\nexport class Component1 {\n  store = inject(UserStore);\n\n  addUser() {\n    this.store.addUser({ name: 'John' });\n  }\n}\n\n// Component 2\n@Component({\n  template: `{{ store.users() | json }}`\n})\nexport class Component2 {\n  store = inject(UserStore);\n}\n```\n\n**7. RxJS Subject для Event Bus:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class EventBusService {\n  private subject$ = new Subject<Event>();\n\n  emit(event: Event) {\n    this.subject$.next(event);\n  }\n\n  on(eventType: string): Observable<Event> {\n    return this.subject$.pipe(\n      filter(event => event.type === eventType)\n    );\n  }\n}\n\n// Component 1 - emitter\n@Component({...})\nexport class EmitterComponent {\n  constructor(private eventBus: EventBusService) {}\n\n  onClick() {\n    this.eventBus.emit({ type: 'USER_CLICK', data: { id: 1 } });\n  }\n}\n\n// Component 2 - listener\n@Component({...})\nexport class ListenerComponent implements OnInit {\n  constructor(private eventBus: EventBusService) {}\n\n  ngOnInit() {\n    this.eventBus.on('USER_CLICK').subscribe(event => {\n      console.log('Received event:', event);\n    });\n  }\n}\n```\n\n**8. Route Parameters:**\n\n```typescript\n// Component 1 - navigate\n@Component({...})\nexport class Component1 {\n  constructor(private router: Router) {}\n\n  navigateWithData() {\n    this.router.navigate(['/details', 123], {\n      queryParams: { name: 'John' },\n      state: { extraData: 'some data' }\n    });\n  }\n}\n\n// Component 2 - receive\n@Component({...})\nexport class Component2 implements OnInit {\n  constructor(\n    private route: ActivatedRoute,\n    private router: Router\n  ) {}\n\n  ngOnInit() {\n    // Route params\n    const id = this.route.snapshot.params['id'];  // 123\n\n    // Query params\n    const name = this.route.snapshot.queryParams['name'];  // 'John'\n\n    // Navigation state\n    const state = this.router.getCurrentNavigation()?.extras.state;\n    console.log(state?.['extraData']);  // 'some data'\n  }\n}\n```\n\n**Сравнение методов:**\n\n| Метод | Использование | Performance |\n|---|---|---|\n| **@Input/@Output** | Parent-Child прямая связь | ✅ Лучший |\n| **@ViewChild** | Parent вызывает Child методы | ✅ Хороший |\n| **Service + Signal** | Any-to-Any, простое состояние | ✅ Отличный |\n| **Service + RxJS** | Any-to-Any, сложные потоки | ⚠️ Средний |\n| **State Management** | Глобальное состояние | ⚠️ Overhead |\n| **Event Bus** | Loosely coupled компоненты | ⚠️ Сложный debugging |\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте @Input/@Output для parent-child\n<app-child [data]=\"parentData\" (event)=\"onChildEvent($event)\"></app-child>\n\n// ✅ Используйте Signals для shared state\n@Injectable({ providedIn: 'root' })\nexport class StateService {\n  count = signal(0);\n  increment() { this.count.update(v => v + 1); }\n}\n\n// ✅ Используйте RxJS для async операций\ndata$ = this.http.get('/api/data');\n\n// ❌ НЕ используйте EventEmitter для сервисов\n@Injectable()\nexport class BadService {\n  event = new EventEmitter();  // ❌ Только для @Output!\n}\n\n// ✅ Используйте Subject/BehaviorSubject\n@Injectable()\nexport class GoodService {\n  private subject = new BehaviorSubject<any>(null);\n  data$ = this.subject.asObservable();\n}\n\n// ❌ НЕ создавайте сложные цепочки @Input/@Output\n// ✅ Используйте service для глубокой передачи данных\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 18,
          "question_number_in_chapter": 8,
          "question_chapter": 2,
          "question_title": "Как создавать Dynamic Components? ComponentFactory и ViewContainerRef.",
          "answer_markdown": "**Ответ:**\n\n**Dynamic Components** - это компоненты, которые создаются программно в runtime, а не объявляются в template.\n\n**Современный подход (Angular 13+):**\n\n```typescript\nimport { Component, ViewChild, ViewContainerRef, inject } from '@angular/core';\nimport { DynamicComponent } from './dynamic.component';\n\n@Component({\n  selector: 'app-host',\n  template: `\n    <button (click)=\"loadComponent()\">Load Dynamic Component</button>\n    <ng-container #dynamicContainer></ng-container>\n  `\n})\nexport class HostComponent {\n  @ViewChild('dynamicContainer', { read: ViewContainerRef })\n  container!: ViewContainerRef;\n\n  // ✅ Modern way (Angular 13+)\n  loadComponent() {\n    // Очищаем предыдущий контент\n    this.container.clear();\n\n    // Создаем компонент\n    const componentRef = this.container.createComponent(DynamicComponent);\n\n    // Устанавливаем @Input значения\n    componentRef.instance.title = 'Dynamic Title';\n    componentRef.instance.data = { id: 1, name: 'Item' };\n\n    // Подписываемся на @Output события\n    componentRef.instance.closeEvent.subscribe(() => {\n      console.log('Component closed');\n      componentRef.destroy();  // Удаляем компонент\n    });\n\n    // Запускаем Change Detection\n    componentRef.changeDetectorRef.detectChanges();\n  }\n}\n\n// Dynamic компонент\n@Component({\n  selector: 'app-dynamic',\n  standalone: true,\n  template: `\n    <div class=\"dynamic\">\n      <h2>{{ title }}</h2>\n      <p>{{ data.name }}</p>\n      <button (click)=\"close()\">Close</button>\n    </div>\n  `\n})\nexport class DynamicComponent {\n  @Input() title = '';\n  @Input() data: any;\n  @Output() closeEvent = new EventEmitter();\n\n  close() {\n    this.closeEvent.emit();\n  }\n}\n```\n\n**Динамическая загрузка разных компонентов:**\n\n```typescript\n@Component({\n  selector: 'app-dynamic-loader',\n  template: `\n    <button (click)=\"loadComponent('user')\">Load User</button>\n    <button (click)=\"loadComponent('admin')\">Load Admin</button>\n    <button (click)=\"clearAll()\">Clear All</button>\n    <ng-container #container></ng-container>\n  `\n})\nexport class DynamicLoaderComponent {\n  @ViewChild('container', { read: ViewContainerRef })\n  container!: ViewContainerRef;\n\n  private componentMap = {\n    user: UserComponent,\n    admin: AdminComponent\n  };\n\n  loadComponent(type: 'user' | 'admin') {\n    const componentType = this.componentMap[type];\n    const componentRef = this.container.createComponent(componentType);\n\n    // Общая настройка\n    componentRef.instance.id = Date.now();\n  }\n\n  clearAll() {\n    this.container.clear();\n  }\n}\n```\n\n**Создание Modal через Dynamic Component:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class ModalService {\n  private modalContainer = inject(ViewContainerRef, { optional: true });\n\n  open<T>(component: Type<T>, config?: { data?: any }): ComponentRef<T> {\n    if (!this.modalContainer) {\n      throw new Error('Modal container not found');\n    }\n\n    const componentRef = this.modalContainer.createComponent(component);\n\n    // Передаем данные\n    if (config?.data) {\n      Object.assign(componentRef.instance, config.data);\n    }\n\n    return componentRef;\n  }\n\n  close(componentRef: ComponentRef<any>) {\n    componentRef.destroy();\n  }\n}\n\n// Использование\n@Component({...})\nexport class AppComponent {\n  constructor(private modalService: ModalService) {}\n\n  openModal() {\n    const modalRef = this.modalService.open(ConfirmDialogComponent, {\n      data: {\n        title: 'Confirm',\n        message: 'Are you sure?'\n      }\n    });\n\n    modalRef.instance.confirmed.subscribe(() => {\n      console.log('Confirmed');\n      this.modalService.close(modalRef);\n    });\n  }\n}\n```\n\n**Dynamic Component с Dependency Injection:**\n\n```typescript\n@Component({...})\nexport class DynamicWithDIComponent {\n  // Компонент получит зависимости из родительского инжектора\n  constructor(\n    private http: HttpClient,\n    private route: ActivatedRoute\n  ) {}\n\n  ngOnInit() {\n    // DI работает нормально\n    this.http.get('/api/data').subscribe();\n  }\n}\n\n// При создании можно передать кастомный инжектор\n@Component({...})\nexport class HostComponent {\n  @ViewChild('container', { read: ViewContainerRef })\n  container!: ViewContainerRef;\n\n  loadWithCustomInjector() {\n    // Создаем кастомный инжектор с дополнительными провайдерами\n    const customInjector = Injector.create({\n      providers: [\n        { provide: API_URL, useValue: 'https://custom-api.com' }\n      ],\n      parent: this.container.injector\n    });\n\n    const componentRef = this.container.createComponent(\n      DynamicComponent,\n      { injector: customInjector }\n    );\n  }\n}\n```\n\n**Lazy Loading динамических компонентов:**\n\n```typescript\n@Component({...})\nexport class LazyLoaderComponent {\n  @ViewChild('container', { read: ViewContainerRef })\n  container!: ViewContainerRef;\n\n  async loadLazyComponent() {\n    // Динамический импорт\n    const { LazyComponent } = await import('./lazy.component');\n\n    const componentRef = this.container.createComponent(LazyComponent);\n    componentRef.instance.data = 'Lazy loaded!';\n  }\n}\n```\n\n**Старый подход (до Angular 13) - ComponentFactoryResolver:**\n\n```typescript\n// ❌ Deprecated (Angular 13+)\n@Component({...})\nexport class OldWayComponent {\n  @ViewChild('container', { read: ViewContainerRef })\n  container!: ViewContainerRef;\n\n  constructor(\n    private componentFactoryResolver: ComponentFactoryResolver  // Deprecated\n  ) {}\n\n  loadComponent() {\n    const factory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent);\n    const componentRef = this.container.createComponentFactory(factory);\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте ViewContainerRef.createComponent() (Angular 13+)\nconst ref = this.container.createComponent(MyComponent);\n\n// ✅ Очищайте контейнер перед добавлением\nthis.container.clear();\nthis.container.createComponent(MyComponent);\n\n// ✅ Уничтожайте компоненты вручную\nngOnDestroy() {\n  this.componentRef?.destroy();\n}\n\n// ✅ Используйте standalone components для динамической загрузки\n@Component({ standalone: true, ... })\n\n// ❌ НЕ забывайте отписываться от событий\ncomponentRef.instance.event.subscribe();  // ❌ Memory leak\n\n// ✅ Отписывайтесь при destroy\nconst sub = componentRef.instance.event.subscribe();\ncomponentRef.onDestroy(() => sub.unsubscribe());\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 19,
          "question_number_in_chapter": 9,
          "question_chapter": 2,
          "question_title": "Что такое Angular Animations? Основные концепции.",
          "answer_markdown": "**Ответ:**\n\n**Angular Animations** - встроенный механизм для создания анимаций на основе Web Animations API.\n\n**Установка:**\n\n```typescript\n// main.ts\nimport { provideAnimations } from '@angular/platform-browser/animations';\n\nbootstrapApplication(AppComponent, {\n  providers: [provideAnimations()]\n});\n```\n\n**Основные building blocks:**\n\n```typescript\nimport { trigger, state, style, transition, animate } from '@angular/animations';\n\n@Component({\n  selector: 'app-animated',\n  template: `\n    <button (click)=\"toggle()\">Toggle</button>\n    <div [@openClose]=\"isOpen ? 'open' : 'closed'\" class=\"box\">\n      Animated Box\n    </div>\n  `,\n  animations: [\n    trigger('openClose', [\n      // Состояния\n      state('open', style({\n        height: '200px',\n        opacity: 1,\n        backgroundColor: 'lightgreen'\n      })),\n      state('closed', style({\n        height: '100px',\n        opacity: 0.8,\n        backgroundColor: 'lightblue'\n      })),\n\n      // Переходы\n      transition('open => closed', [\n        animate('0.3s')\n      ]),\n      transition('closed => open', [\n        animate('0.5s ease-in')\n      ])\n    ])\n  ]\n})\nexport class AnimatedComponent {\n  isOpen = true;\n\n  toggle() {\n    this.isOpen = !this.isOpen;\n  }\n}\n```\n\n**Wildcard states (*) и void:**\n\n```typescript\nanimations: [\n  trigger('fadeInOut', [\n    // void => * (элемент появляется)\n    transition(':enter', [\n      style({ opacity: 0 }),\n      animate('300ms', style({ opacity: 1 }))\n    ]),\n\n    // * => void (элемент исчезает)\n    transition(':leave', [\n      animate('300ms', style({ opacity: 0 }))\n    ]),\n\n    // Любое состояние => любое состояние\n    transition('* => *', [\n      animate('200ms')\n    ])\n  ])\n]\n\n// Использование\n<div @fadeInOut *ngIf=\"show\">Content</div>\n```\n\n**Animations с параметрами:**\n\n```typescript\nanimations: [\n  trigger('slideIn', [\n    transition(':enter', [\n      style({ transform: 'translateX({{ start }})' }),\n      animate('{{ duration }}', style({ transform: 'translateX(0)' }))\n    ], { params: { start: '-100%', duration: '300ms' } })  // Default параметры\n  ])\n]\n\n// Использование с кастомными параметрами\n<div @slideIn=\"{ value: show, params: { start: '100%', duration: '500ms' } }\">\n  Content\n</div>\n```\n\n**Query и Stagger (для списков):**\n\n```typescript\nimport { query, stagger, animateChild } from '@angular/animations';\n\nanimations: [\n  trigger('listAnimation', [\n    transition('* => *', [\n      // Выбираем все элементы с анимацией :enter\n      query(':enter', [\n        style({ opacity: 0, transform: 'translateY(20px)' }),\n        stagger(100, [  // Задержка 100ms между элементами\n          animate('300ms', style({ opacity: 1, transform: 'translateY(0)' }))\n        ])\n      ], { optional: true })  // optional - не выбросит ошибку если элементов нет\n    ])\n  ])\n]\n\n// Использование\n<ul @listAnimation>\n  <li *ngFor=\"let item of items\">{{ item }}</li>\n</ul>\n```\n\n**Keyframes для сложных анимаций:**\n\n```typescript\nimport { keyframes } from '@angular/animations';\n\nanimations: [\n  trigger('bounce', [\n    transition('* => *', [\n      animate('1s', keyframes([\n        style({ transform: 'translateY(0)', offset: 0 }),\n        style({ transform: 'translateY(-30px)', offset: 0.3 }),\n        style({ transform: 'translateY(0)', offset: 0.5 }),\n        style({ transform: 'translateY(-15px)', offset: 0.7 }),\n        style({ transform: 'translateY(0)', offset: 1.0 })\n      ]))\n    ])\n  ])\n]\n```\n\n**Callback события:**\n\n```typescript\n@Component({\n  template: `\n    <div @fadeInOut\n         (@fadeInOut.start)=\"animationStarted($event)\"\n         (@fadeInOut.done)=\"animationDone($event)\"\n         *ngIf=\"show\">\n      Content\n    </div>\n  `,\n  animations: [...]\n})\nexport class CallbackComponent {\n  animationStarted(event: AnimationEvent) {\n    console.log('Animation started:', event);\n  }\n\n  animationDone(event: AnimationEvent) {\n    console.log('Animation done:', event);\n    console.log('From state:', event.fromState);\n    console.log('To state:', event.toState);\n    console.log('Total time:', event.totalTime);\n  }\n}\n```\n\n**Переиспользуемые анимации:**\n\n```typescript\n// animations.ts\nimport { animation, style, animate, trigger, transition, useAnimation } from '@angular/animations';\n\nexport const fadeIn = animation([\n  style({ opacity: 0 }),\n  animate('{{ duration }}', style({ opacity: 1 }))\n]);\n\nexport const fadeOut = animation([\n  animate('{{ duration }}', style({ opacity: 0 }))\n]);\n\n// component.ts\n@Component({\n  animations: [\n    trigger('fade', [\n      transition(':enter', [\n        useAnimation(fadeIn, { params: { duration: '300ms' } })\n      ]),\n      transition(':leave', [\n        useAnimation(fadeOut, { params: { duration: '200ms' } })\n      ])\n    ])\n  ]\n})\n```\n\n**Router Animations:**\n\n```typescript\n// app.component.ts\n@Component({\n  selector: 'app-root',\n  template: `\n    <div [@routeAnimations]=\"prepareRoute(outlet)\">\n      <router-outlet #outlet=\"outlet\"></router-outlet>\n    </div>\n  `,\n  animations: [\n    trigger('routeAnimations', [\n      transition('HomePage => AboutPage', [\n        query(':enter, :leave', [\n          style({\n            position: 'absolute',\n            left: 0,\n            width: '100%',\n          })\n        ], { optional: true }),\n        query(':enter', [\n          style({ left: '100%' })\n        ], { optional: true }),\n        query(':leave', animateChild(), { optional: true }),\n        group([\n          query(':leave', [\n            animate('300ms ease-out', style({ left: '-100%' }))\n          ], { optional: true }),\n          query(':enter', [\n            animate('300ms ease-out', style({ left: '0%' }))\n          ], { optional: true })\n        ]),\n        query(':enter', animateChild(), { optional: true }),\n      ])\n    ])\n  ]\n})\nexport class AppComponent {\n  prepareRoute(outlet: RouterOutlet) {\n    return outlet?.activatedRouteData?.['animation'];\n  }\n}\n\n// routes\nconst routes: Routes = [\n  { path: '', component: HomeComponent, data: { animation: 'HomePage' } },\n  { path: 'about', component: AboutComponent, data: { animation: 'AboutPage' } }\n];\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте :enter и :leave вместо void\ntransition(':enter', [...])  // ✅ Читаемо\ntransition('void => *', [...])  // ❌ Менее читаемо\n\n// ✅ Добавляйте { optional: true } для query\nquery(':enter', [...], { optional: true })  // ✅ Не выбросит ошибку\n\n// ✅ Используйте параметры для переиспользования\nanimations: [\n  trigger('slide', [\n    transition(':enter', [\n      style({ transform: 'translateX({{ start }})' }),\n      animate('{{ time }}')\n    ], { params: { start: '-100%', time: '300ms' } })\n  ])\n]\n\n// ❌ Не делайте слишком сложные анимации (performance)\n// ✅ Используйте transform и opacity (GPU accelerated)\nstyle({ transform: 'translateX(100px)', opacity: 0.5 })  // ✅\n\n// ❌ Избегайте width/height/margin (вызывают reflow)\nstyle({ width: '100px', height: '200px' })  // ❌ Медленно\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 20,
          "question_number_in_chapter": 10,
          "question_chapter": 2,
          "question_title": "Как обрабатывать ошибки в Templates? Safe navigation и Elvis operator.",
          "answer_markdown": "**Ответ:**\n\nAngular предоставляет несколько механизмов для безопасной работы с данными в templates.\n\n**1. Safe Navigation Operator (?.):**\n\n```typescript\n@Component({\n  template: `\n    <!-- ❌ Ошибка если user === null/undefined -->\n    <p>{{ user.name }}</p>\n\n    <!-- ✅ Безопасно - вернет undefined если user null -->\n    <p>{{ user?.name }}</p>\n\n    <!-- ✅ Цепочка вызовов -->\n    <p>{{ user?.address?.city?.name }}</p>\n\n    <!-- ✅ С методами -->\n    <p>{{ user?.getName() }}</p>\n\n    <!-- ✅ С массивами -->\n    <p>{{ users?.[0]?.name }}</p>\n\n    <!-- ✅ Комбинация с || для default значения -->\n    <p>{{ user?.name || 'Guest' }}</p>\n  `\n})\nexport class SafeNavigationComponent {\n  user?: User;  // может быть undefined\n}\n```\n\n**2. Nullish Coalescing (??) и Default значения:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ ?? вернет правую часть только если левая null/undefined -->\n    <p>{{ user?.name ?? 'Anonymous' }}</p>\n\n    <!-- ⚠️ || вернет правую часть если левая falsy (0, '', false) -->\n    <p>{{ count || 'No count' }}</p>  <!-- \"No count\" даже если count = 0 -->\n    <p>{{ count ?? 'No count' }}</p>  <!-- 0 если count = 0 -->\n\n    <!-- ✅ Тернарный оператор для сложной логики -->\n    <p>{{ user ? user.name : 'Guest' }}</p>\n  `\n})\n```\n\n**3. *ngIf для проверки существования:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Рендерим только если данные есть -->\n    <div *ngIf=\"user\">\n      <h2>{{ user.name }}</h2>\n      <p>{{ user.email }}</p>\n    </div>\n\n    <!-- ✅ С else блоком -->\n    <div *ngIf=\"user; else loading\">\n      <p>{{ user.name }}</p>\n    </div>\n    <ng-template #loading>\n      <p>Loading...</p>\n    </ng-template>\n\n    <!-- ✅ С as для типизации -->\n    <div *ngIf=\"user$ | async as user\">\n      <p>{{ user.name }}</p>  <!-- user точно не null -->\n    </div>\n  `\n})\n```\n\n**4. Defensive Programming в Component:**\n\n```typescript\n@Component({\n  template: `\n    <p>{{ getUsername() }}</p>\n    <p>{{ getUserCity() }}</p>\n  `\n})\nexport class DefensiveComponent {\n  user?: User;\n\n  // ✅ Защита в методе\n  getUsername(): string {\n    return this.user?.name ?? 'Guest';\n  }\n\n  // ✅ Защита с default объектом\n  getUserCity(): string {\n    const defaultAddress = { city: 'Unknown' };\n    return (this.user?.address ?? defaultAddress).city;\n  }\n\n  // ✅ Getter с проверкой\n  get safeUser(): User {\n    return this.user ?? { name: 'Guest', email: '' };\n  }\n}\n```\n\n**5. @if control flow (Angular 17+):**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Новый синтаксис control flow -->\n    @if (user) {\n      <p>{{ user.name }}</p>\n    } @else {\n      <p>No user</p>\n    }\n\n    <!-- ✅ С else if -->\n    @if (user?.role === 'admin') {\n      <p>Admin panel</p>\n    } @else if (user?.role === 'user') {\n      <p>User dashboard</p>\n    } @else {\n      <p>Guest view</p>\n    }\n  `\n})\n```\n\n**6. Обработка ошибок Async Pipe:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ С catchError в Observable -->\n    <div *ngIf=\"users$ | async as users; else error\">\n      <div *ngFor=\"let user of users\">{{ user.name }}</div>\n    </div>\n    <ng-template #error>\n      <p>Error loading users</p>\n    </ng-template>\n  `\n})\nexport class AsyncErrorComponent {\n  users$ = this.http.get<User[]>('/api/users').pipe(\n    catchError(error => {\n      console.error('Error:', error);\n      return of([]);  // Вернуть пустой массив при ошибке\n    })\n  );\n}\n```\n\n**7. Custom Error Boundary (ErrorHandler):**\n\n```typescript\nimport { ErrorHandler, Injectable, Injector } from '@angular/core';\n\n@Injectable()\nexport class GlobalErrorHandler implements ErrorHandler {\n  constructor(private injector: Injector) {}\n\n  handleError(error: Error) {\n    console.error('Global error caught:', error);\n\n    // Можно логировать на сервер\n    const http = this.injector.get(HttpClient);\n    http.post('/api/log-error', {\n      message: error.message,\n      stack: error.stack\n    }).subscribe();\n\n    // Показать пользователю\n    const snackbar = this.injector.get(MatSnackBar);\n    snackbar.open('An error occurred', 'Close', { duration: 3000 });\n  }\n}\n\n// Регистрация\nbootstrapApplication(AppComponent, {\n  providers: [\n    { provide: ErrorHandler, useClass: GlobalErrorHandler }\n  ]\n});\n```\n\n**8. Template error handling patterns:**\n\n```typescript\n@Component({\n  template: `\n    <!-- ✅ Pattern 1: Default значения -->\n    <p>{{ user?.name || 'N/A' }}</p>\n\n    <!-- ✅ Pattern 2: Computed в component -->\n    <p>{{ displayName }}</p>\n\n    <!-- ✅ Pattern 3: Pipe для сложной логики -->\n    <p>{{ user | userDisplay }}</p>\n\n    <!-- ✅ Pattern 4: ngIf + as -->\n    <div *ngIf=\"user$ | async as user\">\n      {{ user.name }}\n    </div>\n\n    <!-- ✅ Pattern 5: Multiple checks -->\n    @if (user && user.address && user.address.city) {\n      <p>{{ user.address.city.name }}</p>\n    }\n  `\n})\nexport class PatternsComponent {\n  user$ = this.http.get<User>('/api/user').pipe(\n    catchError(() => of(null))\n  );\n\n  // ✅ Computed property\n  get displayName(): string {\n    return this.user?.name ?? 'Anonymous';\n  }\n}\n\n// Custom pipe для обработки ошибок\n@Pipe({ name: 'userDisplay', standalone: true })\nexport class UserDisplayPipe implements PipeTransform {\n  transform(user: User | null): string {\n    if (!user) return 'No user';\n    return `${user.name} (${user.email})`;\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте ?. для optional свойств\n{{ user?.name }}\n\n// ✅ Используйте ?? для default значений\n{{ user?.name ?? 'Guest' }}\n\n// ✅ Используйте *ngIf для существования данных\n<div *ngIf=\"data\">{{ data.value }}</div>\n\n// ✅ Проверяйте массивы перед итерацией\n@if (users && users.length > 0) {\n  <div *ngFor=\"let user of users\">{{ user.name }}</div>\n}\n\n// ✅ Обрабатывайте ошибки в Observable\ndata$ = http.get().pipe(\n  catchError(error => of(null))\n)\n\n// ❌ НЕ игнорируйте возможные null/undefined\n{{ user.name }}  // ❌ Может выбросить ошибку\n\n// ✅ Всегда используйте safe navigation\n{{ user?.name }}  // ✅ Безопасно\n\n// ✅ Используйте TypeScript strict mode\n\"strict\": true  // в tsconfig.json\n```",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 3,
      "chapter_title": "RxJS & Observables",
      "questions": [
        {
          "question_number": 21,
          "question_number_in_chapter": 1,
          "question_chapter": 3,
          "question_title": "Что такое Observable? В чём разница между Cold и Hot Observable?",
          "answer_markdown": "**Ответ:**\n\n**Observable** — это основа реактивного программирования в Angular. Представляет собой поток данных, который может эмитить значения во времени.\n\n**Основные концепции:**\n\n| Концепция | Описание |\n|-----------|----------|\n| **Observable** | Ленивая коллекция данных, эмитируемых во времени |\n| **Observer** | Объект с методами `next()`, `error()`, `complete()` |\n| **Subscription** | Связь между Observable и Observer, управляет отпиской |\n| **Operators** | Функции для трансформации потоков данных |\n| **Subject** | Observable + Observer (может и подписываться, и эмитить) |\n\n**Cold Observable (Холодный):**\n\n```typescript\nimport { Observable } from 'rxjs';\n\n// ✅ Cold Observable - создаёт новый источник для каждого подписчика\nconst cold$ = new Observable(observer => {\n  console.log('Producer started');\n\n  const interval = setInterval(() => {\n    observer.next(Math.random());\n  }, 1000);\n\n  return () => {\n    console.log('Cleanup');\n    clearInterval(interval);\n  };\n});\n\n// Каждый подписчик получит СВОЙ независимый поток\ncold$.subscribe(value => console.log('Sub1:', value));\n// Producer started\n// Sub1: 0.234...\n\nsetTimeout(() => {\n  cold$.subscribe(value => console.log('Sub2:', value));\n  // Producer started (ещё раз!)\n  // Sub2: 0.876... (другое значение)\n}, 2000);\n```\n\n**Hot Observable (Горячий):**\n\n```typescript\nimport { Subject } from 'rxjs';\n\n// ✅ Hot Observable - один источник для всех подписчиков\nconst hot$ = new Subject<number>();\n\n// Источник работает независимо от подписчиков\nsetInterval(() => {\n  hot$.next(Math.random());\n}, 1000);\n\n// Все подписчики получают ОДИНАКОВЫЕ значения\nhot$.subscribe(value => console.log('Sub1:', value));\n// Sub1: 0.234...\n\nsetTimeout(() => {\n  hot$.subscribe(value => console.log('Sub2:', value));\n  // Sub1: 0.567...\n  // Sub2: 0.567... (то же самое значение!)\n}, 2000);\n```\n\n**Сравнение Cold vs Hot:**\n\n| Характеристика | Cold Observable | Hot Observable |\n|----------------|-----------------|----------------|\n| **Источник** | Создаётся для каждого подписчика | Один на всех |\n| **Старт** | При подписке | Независимо от подписок |\n| **Данные** | Уникальные для каждого | Общие для всех |\n| **Примеры** | HTTP запросы, timer, interval | Subject, fromEvent, WebSocket |\n| **Поведение** | Unicast (1-к-1) | Multicast (1-ко-многим) |\n\n**Превращение Cold в Hot:**\n\n```typescript\nimport { interval, share, shareReplay } from 'rxjs';\n\n// ❌ Cold - каждый подписчик получит свой поток\nconst cold$ = interval(1000);\n\n// ✅ Hot - общий поток для всех\nconst hot$ = cold$.pipe(share());\n\n// ✅ Hot + replay последнего значения\nconst hotReplay$ = cold$.pipe(shareReplay(1));\n\n// ✅ Hot с Subject\nconst subject = new Subject<number>();\ncold$.subscribe(subject);\n// Теперь subject - это hot observable\n```\n\n**Практический пример в Angular:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class DataService {\n  // ❌ Cold - каждый компонент сделает свой HTTP запрос\n  getData() {\n    return this.http.get<Data>('/api/data');\n  }\n\n  // ✅ Hot - один запрос, все компоненты получат данные\n  private dataSubject = new BehaviorSubject<Data | null>(null);\n  data$ = this.dataSubject.asObservable();\n\n  loadData() {\n    this.http.get<Data>('/api/data').subscribe(\n      data => this.dataSubject.next(data)\n    );\n  }\n\n  // ✅ Или с shareReplay\n  cachedData$ = this.http.get<Data>('/api/data').pipe(\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n}\n\n@Component({\n  selector: 'app-data-display',\n  template: `\n    <!-- ✅ Несколько async pipe не создадут несколько запросов -->\n    <div>{{ data$ | async | json }}</div>\n    <div>{{ data$ | async | json }}</div>\n  `\n})\nexport class DataDisplayComponent {\n  // ✅ Используем shareReplay для кеширования\n  data$ = this.dataService.cachedData$;\n\n  constructor(private dataService: DataService) {}\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ HTTP запросы - оставляйте cold\nthis.http.get('/api/users');\n\n// ✅ Используйте shareReplay для кеширования\nusers$ = this.http.get('/api/users').pipe(\n  shareReplay(1)\n);\n\n// ✅ События - делайте hot с Subject\nclickSubject = new Subject<MouseEvent>();\n\n// ✅ WebSocket - уже hot\nwebSocket$ = webSocket('ws://example.com');\n\n// ❌ НЕ делайте hot без необходимости\nconst unnecessary$ = this.http.get('/api').pipe(share());\n\n// ✅ Понимайте, что используете\n// Cold: HTTP, timer, interval, of, from\n// Hot: Subject, fromEvent, webSocket\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 22,
          "question_number_in_chapter": 2,
          "question_chapter": 3,
          "question_title": "Какие типы Subject существуют в RxJS? Когда какой использовать?",
          "answer_markdown": "**Ответ:**\n\n**Subject** — это специальный тип Observable, который может одновременно быть Observer'ом (принимать значения) и Observable (эмитить значения).\n\n**Типы Subject:**\n\n| Тип | Начальное значение | Хранит значения | Replay | Use Case |\n|-----|-------------------|-----------------|--------|----------|\n| **Subject** | Нет | Нет | Нет | События, простая коммуникация |\n| **BehaviorSubject** | ✅ Требуется | Последнее (1) | Да (1) | Состояние, текущее значение |\n| **ReplaySubject** | Нет | N последних | Да (N) | История событий |\n| **AsyncSubject** | Нет | Только последнее | После complete | Promise-like поведение |\n\n**1. Subject (Базовый):**\n\n```typescript\nimport { Subject } from 'rxjs';\n\nconst subject = new Subject<string>();\n\n// Подписчики получают только НОВЫЕ значения\nsubject.subscribe(value => console.log('Sub1:', value));\n\nsubject.next('A');  // Sub1: A\n\nsubject.subscribe(value => console.log('Sub2:', value));\n\nsubject.next('B');  // Sub1: B, Sub2: B\nsubject.next('C');  // Sub1: C, Sub2: C\n\nsubject.complete();\n```\n\n**Use case - события клика:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class EventService {\n  private clickSubject = new Subject<string>();\n  click$ = this.clickSubject.asObservable();\n\n  emitClick(id: string) {\n    this.clickSubject.next(id);\n  }\n}\n\n@Component({\n  selector: 'app-button',\n  template: '<button (click)=\"onClick()\">Click</button>'\n})\nexport class ButtonComponent {\n  constructor(private eventService: EventService) {}\n\n  onClick() {\n    this.eventService.emitClick('button-1');\n  }\n}\n\n@Component({\n  selector: 'app-listener',\n  template: '<p>Last click: {{ lastClick }}</p>'\n})\nexport class ListenerComponent implements OnInit {\n  lastClick = '';\n\n  constructor(private eventService: EventService) {}\n\n  ngOnInit() {\n    // ⚠️ Не получит предыдущие клики!\n    this.eventService.click$.subscribe(\n      id => this.lastClick = id\n    );\n  }\n}\n```\n\n**2. BehaviorSubject (С начальным значением):**\n\n```typescript\nimport { BehaviorSubject } from 'rxjs';\n\n// ✅ ТРЕБУЕТ начальное значение\nconst behavior$ = new BehaviorSubject<number>(0);\n\nconsole.log('Initial:', behavior$.value);  // 0\n\nbehavior$.subscribe(value => console.log('Sub1:', value));\n// Sub1: 0 (получил текущее значение!)\n\nbehavior$.next(1);  // Sub1: 1\n\nbehavior$.subscribe(value => console.log('Sub2:', value));\n// Sub2: 1 (получил последнее значение!)\n\nbehavior$.next(2);  // Sub1: 2, Sub2: 2\n```\n\n**Use case - управление состоянием:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class AuthService {\n  // ✅ Начальное значение null (не авторизован)\n  private userSubject = new BehaviorSubject<User | null>(null);\n  user$ = this.userSubject.asObservable();\n\n  // ✅ Синхронный доступ к текущему значению\n  get currentUser(): User | null {\n    return this.userSubject.value;\n  }\n\n  login(credentials: Credentials) {\n    return this.http.post<User>('/api/login', credentials).pipe(\n      tap(user => this.userSubject.next(user))\n    );\n  }\n\n  logout() {\n    this.userSubject.next(null);\n  }\n}\n\n@Component({\n  selector: 'app-profile',\n  template: `\n    <!-- ✅ Сразу получит текущего пользователя -->\n    @if (user$ | async; as user) {\n      <p>Welcome, {{ user.name }}!</p>\n    } @else {\n      <p>Please log in</p>\n    }\n  `\n})\nexport class ProfileComponent {\n  user$ = this.authService.user$;\n\n  constructor(private authService: AuthService) {}\n}\n```\n\n**3. ReplaySubject (Хранит N значений):**\n\n```typescript\nimport { ReplaySubject } from 'rxjs';\n\n// ✅ Хранит последние 3 значения\nconst replay$ = new ReplaySubject<string>(3);\n\nreplay$.next('A');\nreplay$.next('B');\nreplay$.next('C');\nreplay$.next('D');\n\n// Новый подписчик получит последние 3 значения!\nreplay$.subscribe(value => console.log('Sub:', value));\n// Sub: B\n// Sub: C\n// Sub: D\n```\n\n**Use case - история событий:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class NotificationService {\n  // ✅ Хранит последние 5 уведомлений\n  private notificationSubject = new ReplaySubject<Notification>(5);\n  notifications$ = this.notificationSubject.asObservable();\n\n  addNotification(message: string) {\n    this.notificationSubject.next({\n      id: Date.now(),\n      message,\n      timestamp: new Date()\n    });\n  }\n}\n\n@Component({\n  selector: 'app-notifications',\n  template: `\n    <!-- ✅ Сразу покажет последние 5 уведомлений -->\n    <div *ngFor=\"let n of notifications$ | async\">\n      {{ n.message }} - {{ n.timestamp | date }}\n    </div>\n  `\n})\nexport class NotificationsComponent {\n  notifications$ = this.notificationService.notifications$;\n\n  constructor(private notificationService: NotificationService) {}\n}\n```\n\n**4. AsyncSubject (Только последнее значение после complete):**\n\n```typescript\nimport { AsyncSubject } from 'rxjs';\n\nconst async$ = new AsyncSubject<string>();\n\nasync$.subscribe(value => console.log('Sub1:', value));\n\nasync$.next('A');\nasync$.next('B');\nasync$.next('C');\n\n// ⚠️ Подписчики НЕ получат значения до complete!\n\nasync$.subscribe(value => console.log('Sub2:', value));\n\nasync$.complete();\n// Sub1: C (только последнее!)\n// Sub2: C (только последнее!)\n```\n\n**Use case - Promise-like поведение:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class ConfigService {\n  private configSubject = new AsyncSubject<Config>();\n  config$ = this.configSubject.asObservable();\n\n  loadConfig() {\n    this.http.get<Config>('/api/config').subscribe(\n      config => {\n        this.configSubject.next(config);\n        this.configSubject.complete();  // ✅ Теперь все получат значение\n      }\n    );\n  }\n}\n\n@Component({\n  selector: 'app-root'\n})\nexport class AppComponent implements OnInit {\n  constructor(private configService: ConfigService) {}\n\n  ngOnInit() {\n    // Загружаем конфиг один раз\n    this.configService.loadConfig();\n\n    // ✅ Получит значение только после complete\n    this.configService.config$.subscribe(\n      config => console.log('Config loaded:', config)\n    );\n  }\n}\n```\n\n**Сравнение и выбор:**\n\n```typescript\n// ✅ Subject - простые события\nclickSubject = new Subject<MouseEvent>();\n\n// ✅ BehaviorSubject - текущее состояние\nloadingSubject = new BehaviorSubject<boolean>(false);\nuserSubject = new BehaviorSubject<User | null>(null);\n\n// ✅ ReplaySubject - история/кеш\nsearchHistorySubject = new ReplaySubject<string>(10);\n\n// ✅ AsyncSubject - один результат после завершения\ninitializationSubject = new AsyncSubject<void>();\n\n// ❌ НЕ используйте Subject для состояния\nstateSubject = new Subject<State>();  // ❌ Новые подписчики не получат текущее состояние\n\n// ✅ Используйте BehaviorSubject\nstateSubject = new BehaviorSubject<State>(initialState);  // ✅\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Всегда предоставляйте asObservable()\nprivate userSubject = new BehaviorSubject<User | null>(null);\nuser$ = this.userSubject.asObservable();  // ✅ Read-only\n\n// ❌ НЕ экспортируйте Subject напрямую\npublic userSubject = new BehaviorSubject<User | null>(null);  // ❌ Могут вызвать next()\n\n// ✅ Используйте takeUntilDestroyed() для автоотписки\nprivate destroy$ = new Subject<void>();\n\nngOnDestroy() {\n  this.destroy$.next();\n  this.destroy$.complete();\n}\n\n// ✅ Complete Subject при уничтожении\nngOnDestroy() {\n  this.clickSubject.complete();\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 23,
          "question_number_in_chapter": 3,
          "question_chapter": 3,
          "question_title": "Какие основные RxJS операторы вы знаете? Разница между switchMap, mergeMap, concatMap, exhaustMap?",
          "answer_markdown": "**Ответ:**\n\n**RxJS операторы** — это функции для трансформации, фильтрации и комбинирования потоков данных.\n\n**Категории операторов:**\n\n| Категория | Операторы | Назначение |\n|-----------|-----------|------------|\n| **Трансформация** | map, pluck, scan | Изменение значений |\n| **Фильтрация** | filter, take, skip, debounceTime | Выбор значений |\n| **Комбинирование** | merge, concat, combineLatest, forkJoin | Объединение потоков |\n| **Flattening** | switchMap, mergeMap, concatMap, exhaustMap | Работа с вложенными Observable |\n| **Обработка ошибок** | catchError, retry, retryWhen | Работа с ошибками |\n| **Утилиты** | tap, delay, timeout | Побочные эффекты |\n\n**Основные операторы трансформации:**\n\n```typescript\nimport { map, pluck, scan } from 'rxjs/operators';\nimport { of } from 'rxjs';\n\n// ✅ map - трансформирует каждое значение\nof(1, 2, 3).pipe(\n  map(x => x * 2)\n).subscribe(console.log);  // 2, 4, 6\n\n// ✅ scan - аккумулятор (как reduce)\nof(1, 2, 3).pipe(\n  scan((acc, value) => acc + value, 0)\n).subscribe(console.log);  // 1, 3, 6\n```\n\n**Операторы фильтрации:**\n\n```typescript\nimport { filter, debounceTime, distinctUntilChanged, take } from 'rxjs/operators';\n\n// ✅ filter - фильтрует значения\nof(1, 2, 3, 4, 5).pipe(\n  filter(x => x % 2 === 0)\n).subscribe(console.log);  // 2, 4\n\n// ✅ debounceTime - ждёт паузу (поиск!)\nsearchInput$.pipe(\n  debounceTime(300),  // Ждём 300мс без новых значений\n  distinctUntilChanged()  // Игнорируем дубликаты\n).subscribe(query => this.search(query));\n\n// ✅ take - берёт N значений\ninterval(1000).pipe(\n  take(3)\n).subscribe(console.log);  // 0, 1, 2, complete\n```\n\n**ГЛАВНОЕ: Flattening операторы (switchMap, mergeMap, concatMap, exhaustMap):**\n\n**Проблема:**\n\n```typescript\n// ❌ Вложенные подписки - антипаттерн!\nthis.searchInput$.subscribe(query => {\n  this.http.get(`/api/search?q=${query}`).subscribe(results => {\n    this.results = results;  // ❌ Плохо!\n  });\n});\n```\n\n**Решение:**\n\n```typescript\n// ✅ Используем flattening операторы\nthis.searchInput$.pipe(\n  switchMap(query => this.http.get(`/api/search?q=${query}`))\n).subscribe(results => {\n  this.results = results;  // ✅ Хорошо!\n});\n```\n\n**1. switchMap - отменяет предыдущий запрос:**\n\n```typescript\n// ✅ switchMap - ЛУЧШИЙ выбор для поиска\n@Component({\n  selector: 'app-search',\n  template: `\n    <input [formControl]=\"searchControl\" placeholder=\"Search...\">\n    <div *ngFor=\"let result of results$ | async\">\n      {{ result.name }}\n    </div>\n  `\n})\nexport class SearchComponent {\n  searchControl = new FormControl('');\n\n  results$ = this.searchControl.valueChanges.pipe(\n    debounceTime(300),\n    distinctUntilChanged(),\n    switchMap(query =>\n      query ? this.http.get(`/api/search?q=${query}`) : of([])\n    )\n  );\n\n  constructor(private http: HttpClient) {}\n}\n\n// Поведение switchMap:\n// User types: \"a\" → HTTP request 1\n// User types: \"ab\" → Cancel request 1, HTTP request 2\n// User types: \"abc\" → Cancel request 2, HTTP request 3\n// ✅ Только последний запрос доходит до сервера\n```\n\n**2. mergeMap (flatMap) - выполняет все запросы параллельно:**\n\n```typescript\n// ✅ mergeMap - для параллельных запросов\n@Component({\n  selector: 'app-users'\n})\nexport class UsersComponent {\n  loadUserDetails(userIds: number[]) {\n    from(userIds).pipe(\n      mergeMap(id => this.http.get(`/api/users/${id}`)),\n      toArray()\n    ).subscribe(users => {\n      console.log('All users loaded:', users);\n    });\n  }\n\n  constructor(private http: HttpClient) {}\n}\n\n// Поведение mergeMap:\n// IDs: [1, 2, 3]\n// → HTTP request 1, 2, 3 одновременно\n// → Результаты приходят в порядке завершения (2, 1, 3)\n// ✅ Максимальная скорость, НО порядок не гарантирован\n```\n\n**3. concatMap - выполняет запросы последовательно:**\n\n```typescript\n// ✅ concatMap - для последовательных операций\n@Component({\n  selector: 'app-order'\n})\nexport class OrderComponent {\n  processOrders(orders: Order[]) {\n    from(orders).pipe(\n      concatMap(order =>\n        this.http.post('/api/orders', order).pipe(\n          tap(() => console.log(`Order ${order.id} processed`))\n        )\n      )\n    ).subscribe();\n  }\n\n  constructor(private http: HttpClient) {}\n}\n\n// Поведение concatMap:\n// Orders: [A, B, C]\n// → HTTP request A\n// → Wait for A to complete\n// → HTTP request B\n// → Wait for B to complete\n// → HTTP request C\n// ✅ Гарантирует порядок, НО медленнее\n```\n\n**4. exhaustMap - игнорирует новые запросы, пока предыдущий не завершён:**\n\n```typescript\n// ✅ exhaustMap - для защиты от двойного клика\n@Component({\n  selector: 'app-login',\n  template: `\n    <button (click)=\"login()\">Login</button>\n  `\n})\nexport class LoginComponent {\n  private loginClicks$ = new Subject<void>();\n\n  constructor(private authService: AuthService) {\n    this.loginClicks$.pipe(\n      exhaustMap(() => this.authService.login(credentials))\n    ).subscribe();\n  }\n\n  login() {\n    this.loginClicks$.next();\n  }\n}\n\n// Поведение exhaustMap:\n// User clicks: Click 1 → HTTP request 1\n// User clicks: Click 2 → Ignored! (request 1 ещё идёт)\n// User clicks: Click 3 → Ignored!\n// Request 1 complete\n// User clicks: Click 4 → HTTP request 2\n// ✅ Защита от спама кликами\n```\n\n**Сравнительная таблица:**\n\n| Оператор | Поведение | Use Case | Порядок |\n|----------|-----------|----------|---------|\n| **switchMap** | Отменяет предыдущий | Поиск, автокомплит | Только последний |\n| **mergeMap** | Все параллельно | Массовая загрузка | Не гарантирован |\n| **concatMap** | Последовательно | Критичный порядок | Гарантирован |\n| **exhaustMap** | Игнорирует новые | Защита от спама | Первый до конца |\n\n**Практический пример - роутинг:**\n\n```typescript\n@Component({\n  selector: 'app-user-detail'\n})\nexport class UserDetailComponent implements OnInit {\n  user$!: Observable<User>;\n\n  constructor(\n    private route: ActivatedRoute,\n    private userService: UserService\n  ) {}\n\n  ngOnInit() {\n    // ✅ switchMap - при изменении route отменяем старый запрос\n    this.user$ = this.route.params.pipe(\n      switchMap(params =>\n        this.userService.getUser(params['id'])\n      )\n    );\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Поиск/автокомплит\nsearchInput$.pipe(\n  debounceTime(300),\n  switchMap(query => this.search(query))\n)\n\n// ✅ Загрузка деталей по клику\nuserClicks$.pipe(\n  switchMap(id => this.loadUserDetails(id))\n)\n\n// ✅ Сохранение (защита от двойного клика)\nsaveClicks$.pipe(\n  exhaustMap(() => this.save())\n)\n\n// ✅ Загрузка массива данных параллельно\nuserIds$.pipe(\n  mergeMap(id => this.loadUser(id))\n)\n\n// ✅ Последовательная обработка\ntasks$.pipe(\n  concatMap(task => this.processTask(task))\n)\n\n// ❌ НЕ вкладывайте subscribe\nobs1.subscribe(val1 => {\n  obs2.subscribe(val2 => {  // ❌ Плохо!\n    // ...\n  });\n});\n\n// ✅ Используйте операторы\nobs1.pipe(\n  switchMap(val1 => obs2)\n).subscribe(val2 => {  // ✅ Хорошо!\n  // ...\n});\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 24,
          "question_number_in_chapter": 4,
          "question_chapter": 3,
          "question_title": "Как обрабатывать ошибки в RxJS? catchError, retry, retryWhen?",
          "answer_markdown": "**Ответ:**\n\n**Обработка ошибок** — критически важна для стабильности приложения. RxJS предоставляет мощные операторы для работы с ошибками.\n\n**Основные операторы:**\n\n| Оператор | Описание | Use Case |\n|----------|----------|----------|\n| **catchError** | Перехватывает ошибку и возвращает новый Observable | Fallback значения, альтернативные потоки |\n| **retry** | Повторяет Observable N раз при ошибке | Временные сетевые сбои |\n| **retryWhen** | Повторяет с пользовательской логикой | Экспоненциальная задержка |\n| **throwError** | Создаёт Observable, который сразу эмитит ошибку | Тестирование |\n| **finalize** | Выполняет код при завершении (ошибка или complete) | Cleanup |\n\n**1. catchError - перехват ошибок:**\n\n```typescript\nimport { catchError } from 'rxjs/operators';\nimport { of, throwError } from 'rxjs';\n\n// ✅ Pattern 1: Возврат fallback значения\ngetUserData(id: number) {\n  return this.http.get<User>(`/api/users/${id}`).pipe(\n    catchError(error => {\n      console.error('Failed to load user:', error);\n      return of(null);  // ✅ Возвращаем null вместо ошибки\n    })\n  );\n}\n\n// ✅ Pattern 2: Возврат альтернативного потока\ngetData() {\n  return this.http.get('/api/data').pipe(\n    catchError(() => this.http.get('/api/backup-data'))\n  );\n}\n\n// ✅ Pattern 3: Обработка и прокидывание дальше\nloadCriticalData() {\n  return this.http.get('/api/critical').pipe(\n    catchError(error => {\n      this.logger.error('Critical error:', error);\n      this.showErrorNotification();\n      return throwError(() => new Error('Failed to load critical data'));\n    })\n  );\n}\n```\n\n**Практический пример - компонент с обработкой ошибок:**\n\n```typescript\n@Component({\n  selector: 'app-user-profile',\n  template: `\n    @if (user$ | async; as user) {\n      <div class=\"profile\">{{ user.name }}</div>\n    } @else if (error$ | async; as error) {\n      <div class=\"error\">{{ error }}</div>\n    } @else {\n      <div class=\"loading\">Loading...</div>\n    }\n  `\n})\nexport class UserProfileComponent implements OnInit {\n  user$ = new Subject<User | null>();\n  error$ = new Subject<string | null>();\n\n  constructor(\n    private route: ActivatedRoute,\n    private userService: UserService\n  ) {}\n\n  ngOnInit() {\n    this.route.params.pipe(\n      switchMap(params =>\n        this.userService.getUser(params['id']).pipe(\n          tap(user => {\n            this.user$.next(user);\n            this.error$.next(null);\n          }),\n          catchError(error => {\n            this.error$.next('Failed to load user');\n            this.user$.next(null);\n            return of(null);  // ✅ Поток продолжается\n          })\n        )\n      ),\n      takeUntilDestroyed()\n    ).subscribe();\n  }\n}\n```\n\n**2. retry - автоматический повтор:**\n\n```typescript\nimport { retry } from 'rxjs/operators';\n\n// ✅ retry - повторяет N раз\ngetData() {\n  return this.http.get('/api/data').pipe(\n    retry(3),  // ✅ Повторит 3 раза при ошибке\n    catchError(error => {\n      console.error('Failed after 3 retries:', error);\n      return of(null);\n    })\n  );\n}\n\n// ✅ retry с конфигом (RxJS 7+)\ngetDataWithDelay() {\n  return this.http.get('/api/data').pipe(\n    retry({\n      count: 3,\n      delay: 1000  // ✅ Ждёт 1 секунду между попытками\n    }),\n    catchError(() => of(null))\n  );\n}\n```\n\n**3. retryWhen - кастомная логика повтора:**\n\n```typescript\nimport { retryWhen, delay, take, tap, concatMap } from 'rxjs/operators';\nimport { timer } from 'rxjs';\n\n// ✅ Экспоненциальная задержка (exponential backoff)\ngetDataWithBackoff() {\n  return this.http.get('/api/data').pipe(\n    retryWhen(errors =>\n      errors.pipe(\n        concatMap((error, index) => {\n          // Повторяем максимум 3 раза\n          if (index >= 3) {\n            return throwError(() => error);\n          }\n\n          // Экспоненциальная задержка: 1s, 2s, 4s\n          const delayMs = Math.pow(2, index) * 1000;\n          console.log(`Retry ${index + 1} after ${delayMs}ms`);\n\n          return timer(delayMs);\n        })\n      )\n    ),\n    catchError(error => {\n      console.error('Failed after retries:', error);\n      return of(null);\n    })\n  );\n}\n\n// ✅ Повтор только для определённых ошибок\ngetDataWithSelectiveRetry() {\n  return this.http.get('/api/data').pipe(\n    retryWhen(errors =>\n      errors.pipe(\n        concatMap((error, index) => {\n          // Повторяем только для 5xx ошибок\n          if (error.status >= 500 && error.status < 600 && index < 3) {\n            return timer(1000);\n          }\n\n          // Для остальных ошибок не повторяем\n          return throwError(() => error);\n        })\n      )\n    )\n  );\n}\n```\n\n**4. finalize - cleanup при завершении:**\n\n```typescript\nimport { finalize } from 'rxjs/operators';\n\n@Injectable({ providedIn: 'root' })\nexport class DataService {\n  private loadingSubject = new BehaviorSubject<boolean>(false);\n  loading$ = this.loadingSubject.asObservable();\n\n  getData() {\n    this.loadingSubject.next(true);\n\n    return this.http.get('/api/data').pipe(\n      // ✅ finalize вызывается при complete ИЛИ error\n      finalize(() => {\n        this.loadingSubject.next(false);\n        console.log('Request finished');\n      }),\n      catchError(error => {\n        console.error('Error:', error);\n        return of(null);\n      })\n    );\n  }\n}\n```\n\n**Комбинирование операторов:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class RobustDataService {\n  getData() {\n    return this.http.get<Data>('/api/data').pipe(\n      // 1. Повторяем 3 раза с задержкой\n      retry({\n        count: 3,\n        delay: 1000\n      }),\n\n      // 2. Логируем попытки\n      tap(data => console.log('Data loaded:', data)),\n\n      // 3. Обрабатываем ошибку\n      catchError(error => {\n        this.notificationService.showError('Failed to load data');\n        return of(null);\n      }),\n\n      // 4. Cleanup\n      finalize(() => {\n        console.log('Request complete');\n      })\n    );\n  }\n}\n```\n\n**Global Error Handler:**\n\n```typescript\n// error.interceptor.ts\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n  constructor(private errorHandler: GlobalErrorHandler) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return next.handle(req).pipe(\n      retry({\n        count: 2,\n        delay: (error, retryCount) => {\n          // Не повторяем для 4xx ошибок\n          if (error.status >= 400 && error.status < 500) {\n            return throwError(() => error);\n          }\n\n          // Экспоненциальная задержка для 5xx\n          return timer(Math.pow(2, retryCount - 1) * 1000);\n        }\n      }),\n      catchError((error: HttpErrorResponse) => {\n        this.errorHandler.handleError(error);\n        return throwError(() => error);\n      })\n    );\n  }\n}\n\n// global-error-handler.service.ts\n@Injectable({ providedIn: 'root' })\nexport class GlobalErrorHandler {\n  handleError(error: HttpErrorResponse) {\n    let errorMessage = 'Unknown error';\n\n    if (error.error instanceof ErrorEvent) {\n      // Client-side error\n      errorMessage = `Client Error: ${error.error.message}`;\n    } else {\n      // Server-side error\n      errorMessage = `Server Error ${error.status}: ${error.message}`;\n    }\n\n    console.error(errorMessage);\n    this.showNotification(errorMessage);\n  }\n\n  private showNotification(message: string) {\n    // Toast notification\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Всегда используйте catchError\nthis.http.get('/api/data').pipe(\n  catchError(error => {\n    console.error(error);\n    return of(null);\n  })\n)\n\n// ✅ retry для временных сбоев\nthis.http.get('/api/data').pipe(\n  retry(3),\n  catchError(() => of(null))\n)\n\n// ✅ finalize для cleanup\nthis.http.get('/api/data').pipe(\n  finalize(() => this.hideLoader())\n)\n\n// ❌ НЕ игнорируйте ошибки\nthis.http.get('/api/data').subscribe();  // ❌ Ошибка упадёт в консоль\n\n// ✅ Обрабатывайте ошибки\nthis.http.get('/api/data').pipe(\n  catchError(() => of(null))\n).subscribe();\n\n// ✅ Используйте HttpInterceptor для глобальной обработки\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS,\n    useClass: ErrorInterceptor,\n    multi: true\n  }\n]\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 25,
          "question_number_in_chapter": 5,
          "question_chapter": 3,
          "question_title": "Как правильно отписываться от Observable? Memory leaks и best practices?",
          "answer_markdown": "**Ответ:**\n\n**Утечки памяти** (memory leaks) возникают, когда подписки не отменяются при уничтожении компонента. RxJS предоставляет несколько паттернов для управления подписками.\n\n**Паттерны отписки:**\n\n| Паттерн | Сложность | Use Case |\n|---------|-----------|----------|\n| **async pipe** | Нет (авто) | Template subscriptions (ЛУЧШИЙ) |\n| **takeUntilDestroyed()** | Низкая | Angular 16+ (рекомендуется) |\n| **takeUntil(destroy$)** | Средняя | До Angular 16 |\n| **Subscription.unsubscribe()** | Средняя | Одна подписка |\n| **Subscription.add()** | Средняя | Несколько подписок |\n| **take(1)** | Нет | Одно значение |\n\n**1. async pipe - ЛУЧШИЙ способ:**\n\n```typescript\n// ✅ async pipe - автоматическая отписка\n@Component({\n  selector: 'app-users',\n  template: `\n    <!-- ✅ async pipe сам отпишется при ngOnDestroy -->\n    <div *ngFor=\"let user of users$ | async\">\n      {{ user.name }}\n    </div>\n\n    <!-- ✅ Можно использовать несколько раз -->\n    <p>Total: {{ (users$ | async)?.length }}</p>\n\n    <!-- ✅ Или сохранить в переменную -->\n    @if (users$ | async; as users) {\n      <div *ngFor=\"let user of users\">{{ user.name }}</div>\n      <p>Total: {{ users.length }}</p>\n    }\n  `\n})\nexport class UsersComponent {\n  // ✅ Просто возвращаем Observable\n  users$ = this.userService.getUsers();\n\n  constructor(private userService: UserService) {}\n\n  // ✅ Не нужен ngOnDestroy!\n}\n```\n\n**2. takeUntilDestroyed() - Angular 16+ (рекомендуется):**\n\n```typescript\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\n\n@Component({\n  selector: 'app-data'\n})\nexport class DataComponent implements OnInit {\n  data: Data[] = [];\n\n  // ✅ Можно вызывать в constructor или в полях класса\n  constructor(private dataService: DataService) {\n    // ✅ Автоматически отпишется при ngOnDestroy\n    this.dataService.getData().pipe(\n      takeUntilDestroyed()\n    ).subscribe(data => this.data = data);\n  }\n\n  ngOnInit() {\n    // ⚠️ В ngOnInit нужно передать DestroyRef\n    this.dataService.getOtherData().pipe(\n      takeUntilDestroyed()  // ✅ Работает, если вызван в injection context\n    ).subscribe(data => console.log(data));\n  }\n\n  // ✅ С DestroyRef (если не в injection context)\n  private destroyRef = inject(DestroyRef);\n\n  someMethod() {\n    this.dataService.getData().pipe(\n      takeUntilDestroyed(this.destroyRef)\n    ).subscribe();\n  }\n}\n```\n\n**3. takeUntil(destroy$) - до Angular 16:**\n\n```typescript\nimport { takeUntil } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\n\n@Component({\n  selector: 'app-data'\n})\nexport class DataComponent implements OnInit, OnDestroy {\n  // ✅ Subject для сигнала уничтожения\n  private destroy$ = new Subject<void>();\n\n  ngOnInit() {\n    // Подписка 1\n    this.dataService.getData().pipe(\n      takeUntil(this.destroy$)\n    ).subscribe(data => this.processData(data));\n\n    // Подписка 2\n    this.route.params.pipe(\n      takeUntil(this.destroy$)\n    ).subscribe(params => this.loadUser(params['id']));\n\n    // Подписка 3\n    this.searchControl.valueChanges.pipe(\n      debounceTime(300),\n      takeUntil(this.destroy$)\n    ).subscribe(query => this.search(query));\n  }\n\n  ngOnDestroy() {\n    // ✅ Отменяем ВСЕ подписки разом\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n```\n\n**4. Subscription.unsubscribe():**\n\n```typescript\n@Component({\n  selector: 'app-manual'\n})\nexport class ManualComponent implements OnInit, OnDestroy {\n  private subscription!: Subscription;\n\n  ngOnInit() {\n    // ✅ Одна подписка\n    this.subscription = this.dataService.getData().subscribe(\n      data => this.data = data\n    );\n  }\n\n  ngOnDestroy() {\n    // ✅ Отписываемся вручную\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ ЛУЧШЕЕ: async pipe\ntemplate: `<div>{{ data$ | async }}</div>`\n\n// ✅ ХОРОШО: takeUntilDestroyed() (Angular 16+)\nconstructor() {\n  this.data$.pipe(takeUntilDestroyed()).subscribe();\n}\n\n// ✅ ХОРОШО: takeUntil(destroy$) (до Angular 16)\nngOnInit() {\n  this.data$.pipe(takeUntil(this.destroy$)).subscribe();\n}\n\n// ❌ ПЛОХО: нет отписки\nngOnInit() {\n  interval(1000).subscribe();  // ❌ Memory leak!\n}\n\n// ✅ HTTP не требует отписки (но можно для отмены)\nthis.http.get('/api/data').subscribe();  // ✅ OK\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 26,
          "question_number_in_chapter": 6,
          "question_chapter": 3,
          "question_title": "В чём разница между combineLatest, forkJoin, merge, concat? Когда что использовать?",
          "answer_markdown": "**Ответ:**\n\n**Операторы комбинирования** позволяют объединять несколько Observable в один поток.\n\n**Сравнительная таблица:**\n\n| Оператор | Ждёт complete | Эмитит | Use Case |\n|----------|---------------|--------|----------|\n| **combineLatest** | Нет | При каждом изменении | Реактивные формы, зависимые данные |\n| **forkJoin** | ✅ Да | Один раз (последние значения) | Параллельные HTTP запросы |\n| **merge** | Нет | Все значения всех потоков | События, уведомления |\n| **concat** | ✅ Да (по очереди) | Все значения по порядку | Последовательная загрузка |\n\n**1. combineLatest - комбинирует последние значения:**\n\n```typescript\nimport { combineLatest } from 'rxjs';\n\n// ✅ Эмитит при каждом изменении ЛЮБОГО потока\nconst age$ = new BehaviorSubject(25);\nconst name$ = new BehaviorSubject('Alice');\n\ncombineLatest([age$, name$]).subscribe(([age, name]) => {\n  console.log(`${name} is ${age} years old`);\n});\n// Alice is 25 years old\n\nage$.next(26);\n// Alice is 26 years old\n\nname$.next('Bob');\n// Bob is 26 years old\n```\n\n**Use case - реактивные фильтры:**\n\n```typescript\n@Component({\n  selector: 'app-products',\n  template: `\n    <input [formControl]=\"searchControl\" placeholder=\"Search...\">\n    <select [formControl]=\"categoryControl\">\n      <option value=\"\">All</option>\n    </select>\n\n    <div *ngFor=\"let product of filteredProducts$ | async\">\n      {{ product.name }}\n    </div>\n  `\n})\nexport class ProductsComponent {\n  searchControl = new FormControl('');\n  categoryControl = new FormControl('');\n\n  // ✅ Обновляется при изменении ЛЮБОГО фильтра\n  filteredProducts$ = combineLatest([\n    this.searchControl.valueChanges.pipe(startWith('')),\n    this.categoryControl.valueChanges.pipe(startWith('')),\n    this.productService.products$\n  ]).pipe(\n    map(([search, category, products]) =>\n      products.filter(p =>\n        (!search || p.name.includes(search)) &&\n        (!category || p.category === category)\n      )\n    )\n  );\n\n  constructor(private productService: ProductService) {}\n}\n```\n\n**2. forkJoin - ждёт завершения всех потоков:**\n\n```typescript\nimport { forkJoin } from 'rxjs';\n\n// ✅ Эмитит ОДИН РАЗ, когда все потоки завершились\nforkJoin({\n  user: this.http.get('/api/user'),\n  posts: this.http.get('/api/posts'),\n  comments: this.http.get('/api/comments')\n}).subscribe(({ user, posts, comments }) => {\n  console.log('All loaded:', user, posts, comments);\n});\n```\n\n**Use case - параллельная загрузка:**\n\n```typescript\n@Component({\n  selector: 'app-dashboard'\n})\nexport class DashboardComponent implements OnInit {\n  data$!: Observable<DashboardData>;\n\n  ngOnInit() {\n    // ✅ Загружаем все данные параллельно\n    this.data$ = forkJoin({\n      user: this.userService.getUser(),\n      stats: this.statsService.getStats(),\n      notifications: this.notificationService.getNotifications(),\n      settings: this.settingsService.getSettings()\n    }).pipe(\n      map(({ user, stats, notifications, settings }) => ({\n        user,\n        stats,\n        notifications,\n        settings,\n        isReady: true\n      }))\n    );\n  }\n}\n```\n\n**3. merge - объединяет все значения:**\n\n```typescript\nimport { merge, fromEvent } from 'rxjs';\n\n// ✅ Эмитит каждое значение из ЛЮБОГО потока\nconst clicks$ = fromEvent(button1, 'click');\nconst hovers$ = fromEvent(button2, 'mouseenter');\n\nmerge(clicks$, hovers$).subscribe(event => {\n  console.log('Event occurred:', event.type);\n});\n```\n\n**4. concat - последовательное выполнение:**\n\n```typescript\nimport { concat, of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\n// ✅ Ждёт complete первого, потом второго, потом третьего\nconcat(\n  of('First').pipe(delay(1000)),\n  of('Second').pipe(delay(1000)),\n  of('Third').pipe(delay(1000))\n).subscribe(console.log);\n// (1s) First\n// (2s) Second\n// (3s) Third\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ combineLatest для зависимых данных\ncombineLatest([filter$, data$])\n\n// ✅ forkJoin для параллельных HTTP запросов\nforkJoin([req1$, req2$, req3$])\n\n// ✅ merge для независимых событий\nmerge(click$, hover$, focus$)\n\n// ✅ concat для последовательных операций\nconcat(save$, validate$, notify$)\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 27,
          "question_number_in_chapter": 7,
          "question_chapter": 3,
          "question_title": "Что такое shareReplay? Зачем нужен multicasting?",
          "answer_markdown": "**Ответ:**\n\n**shareReplay** — один из самых полезных операторов RxJS для оптимизации HTTP запросов и кеширования данных.\n\n**Проблема без shareReplay:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class DataService {\n  // ❌ ПРОБЛЕМА: каждый подписчик создаст новый HTTP запрос\n  getData() {\n    return this.http.get('/api/data');\n  }\n}\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- ❌ Создаст 3 HTTP запроса! -->\n    <div>{{ data$ | async | json }}</div>\n    <div>{{ data$ | async | json }}</div>\n    <div>{{ data$ | async | json }}</div>\n  `\n})\nexport class ExampleComponent {\n  data$ = this.dataService.getData();\n  constructor(private dataService: DataService) {}\n}\n```\n\n**Решение с shareReplay:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class DataService {\n  // ✅ РЕШЕНИЕ: один HTTP запрос, кешируем результат\n  private cachedData$ = this.http.get('/api/data').pipe(\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n\n  getData() {\n    return this.cachedData$;\n  }\n}\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- ✅ Только один HTTP запрос для всех подписчиков! -->\n    <div>{{ data$ | async | json }}</div>\n    <div>{{ data$ | async | json }}</div>\n    <div>{{ data$ | async | json }}</div>\n  `\n})\nexport class ExampleComponent {\n  data$ = this.dataService.getData();\n  constructor(private dataService: DataService) {}\n}\n```\n\n**Параметры shareReplay:**\n\n```typescript\nshareReplay({\n  bufferSize: 1,     // Сколько последних значений хранить\n  refCount: true,    // Отписываться ли при отсутствии подписчиков\n  windowTime: Infinity  // Время жизни кеша (по умолчанию бесконечно)\n})\n```\n\n**Варианты использования:**\n\n```typescript\n// ✅ Pattern 1: Кеширование с автоочисткой\ngetData() {\n  return this.http.get('/api/data').pipe(\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n}\n\n// ✅ Pattern 2: Кеширование навсегда (пока приложение не перезагружено)\ngetConfig() {\n  return this.http.get('/api/config').pipe(\n    shareReplay(1)  // Краткая форма: shareReplay({ bufferSize: 1, refCount: false })\n  );\n}\n\n// ✅ Pattern 3: Кеширование с TTL (time to live)\ngetDataWithTTL() {\n  return this.http.get('/api/data').pipe(\n    shareReplay({\n      bufferSize: 1,\n      refCount: true,\n      windowTime: 60000  // Кеш на 60 секунд\n    })\n  );\n}\n```\n\n**Сравнение multicasting операторов:**\n\n| Оператор | Поведение | Кеширование | Use Case |\n|----------|-----------|-------------|----------|\n| **share()** | Делает hot, НЕ кеширует | Нет | События |\n| **shareReplay(1)** | Делает hot, кеширует последнее | Да | HTTP запросы |\n| **publish()** | Делает hot вручную (нужен connect()) | Нет | Редко |\n| **publishReplay(1)** | То же что shareReplay, но вручную | Да | Редко |\n\n**Практический пример - сервис с кешированием:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private userCache$ = new Map<number, Observable<User>>();\n\n  getUser(id: number): Observable<User> {\n    // ✅ Проверяем кеш\n    if (!this.userCache$.has(id)) {\n      // ✅ Создаём и кешируем запрос\n      this.userCache$.set(\n        id,\n        this.http.get<User>(`/api/users/${id}`).pipe(\n          shareReplay({ bufferSize: 1, refCount: true })\n        )\n      );\n    }\n\n    return this.userCache$.get(id)!;\n  }\n\n  // ✅ Инвалидация кеша\n  invalidateUser(id: number) {\n    this.userCache$.delete(id);\n  }\n\n  clearCache() {\n    this.userCache$.clear();\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте shareReplay для HTTP запросов\nhttp.get('/api/data').pipe(\n  shareReplay({ bufferSize: 1, refCount: true })\n)\n\n// ✅ refCount: true для автоматической отписки\nshareReplay({ bufferSize: 1, refCount: true })\n\n// ✅ refCount: false для постоянного кеша\nshareReplay({ bufferSize: 1, refCount: false })\n\n// ❌ НЕ используйте shareReplay без параметров\nshareReplay()  // ❌ Deprecated в RxJS 7+\n\n// ✅ Используйте с параметрами\nshareReplay({ bufferSize: 1, refCount: true })\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 28,
          "question_number_in_chapter": 8,
          "question_chapter": 3,
          "question_title": "Что такое toSignal() и toObservable()? Как работать с RxJS в Signal-based компонентах?",
          "answer_markdown": "**Ответ:**\n\n**toSignal()** и **toObservable()** — это функции interop между RxJS Observable и Angular Signals (Angular 16+).\n\n**1. toSignal() - Observable → Signal:**\n\n```typescript\nimport { toSignal } from '@angular/core/rxjs-interop';\n\n@Component({\n  selector: 'app-users',\n  template: `\n    @if (users(); as users) {\n      @for (user of users; track user.id) {\n        <div>{{ user.name }}</div>\n      }\n    }\n  `\n})\nexport class UsersComponent {\n  // ✅ Преобразуем Observable в Signal\n  users = toSignal(this.userService.getUsers(), {\n    initialValue: []  // ✅ Начальное значение (обязательно, если Observable не синхронный)\n  });\n\n  constructor(private userService: UserService) {}\n}\n```\n\n**Параметры toSignal:**\n\n```typescript\ninterface ToSignalOptions<T> {\n  initialValue?: T;           // Начальное значение (опционально)\n  requireSync?: boolean;      // Требовать синхронное значение? (по умолчанию false)\n  manualCleanup?: boolean;    // Ручное управление подпиской? (по умолчанию false)\n  injector?: Injector;        // Injector для автоматической отписки\n}\n```\n\n**Примеры использования toSignal:**\n\n```typescript\n// ✅ Pattern 1: Базовое использование\nusers = toSignal(this.http.get<User[]>('/api/users'), {\n  initialValue: []\n});\n\n// ✅ Pattern 2: Без начального значения (Signal<User[] | undefined>)\nusers = toSignal(this.http.get<User[]>('/api/users'));\n// users() может быть undefined\n\n// ✅ Pattern 3: requireSync для BehaviorSubject\nprivate userSubject = new BehaviorSubject<User[]>([]);\nusers = toSignal(this.userSubject, { requireSync: true });\n// ✅ Не нужен initialValue, т.к. BehaviorSubject синхронный\n\n// ✅ Pattern 4: Route params\nuserId = toSignal(\n  this.route.params.pipe(map(params => params['id'])),\n  { initialValue: '' }\n);\n\n// ✅ Pattern 5: Form control value\nsearchQuery = toSignal(\n  this.searchControl.valueChanges.pipe(startWith('')),\n  { requireSync: true }\n);\n```\n\n**2. toObservable() - Signal → Observable:**\n\n```typescript\nimport { toObservable } from '@angular/core/rxjs-interop';\n\n@Component({\n  selector: 'app-search'\n})\nexport class SearchComponent implements OnInit {\n  searchQuery = signal('');\n\n  // ✅ Преобразуем Signal в Observable\n  searchQuery$ = toObservable(this.searchQuery);\n\n  ngOnInit() {\n    // ✅ Используем RxJS операторы\n    this.searchQuery$.pipe(\n      debounceTime(300),\n      distinctUntilChanged(),\n      switchMap(query => this.searchService.search(query))\n    ).subscribe(results => {\n      console.log('Results:', results);\n    });\n  }\n\n  constructor(private searchService: SearchService) {}\n}\n```\n\n**Практический пример - гибридный компонент:**\n\n```typescript\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <input [value]=\"searchQuery()\" \n           (input)=\"searchQuery.set($any($event.target).value)\">\n    \n    <select [value]=\"category()\" \n            (change)=\"category.set($any($event.target).value)\">\n      <option value=\"\">All</option>\n      <option value=\"electronics\">Electronics</option>\n    </select>\n\n    @if (filteredProducts(); as products) {\n      @for (product of products; track product.id) {\n        <div>{{ product.name }} - {{ product.price }}</div>\n      }\n    }\n  `\n})\nexport class ProductListComponent implements OnInit {\n  // ✅ Signals для пользовательского ввода\n  searchQuery = signal('');\n  category = signal('');\n\n  // ✅ Signal → Observable для использования RxJS операторов\n  searchQuery$ = toObservable(this.searchQuery);\n  category$ = toObservable(this.category);\n\n  // ✅ Комбинируем с RxJS\n  filteredProducts = toSignal(\n    combineLatest([\n      this.searchQuery$,\n      this.category$,\n      this.productService.products$\n    ]).pipe(\n      debounceTime(300),\n      map(([search, category, products]) =>\n        products.filter(p =>\n          (!search || p.name.toLowerCase().includes(search.toLowerCase())) &&\n          (!category || p.category === category)\n        )\n      )\n    ),\n    { initialValue: [] }\n  );\n\n  constructor(private productService: ProductService) {}\n}\n```\n\n**Computed с Observable данными:**\n\n```typescript\n@Component({\n  selector: 'app-dashboard'\n})\nexport class DashboardComponent {\n  // ✅ Observable → Signal\n  user = toSignal(this.userService.currentUser$);\n  posts = toSignal(this.postService.posts$, { initialValue: [] });\n\n  // ✅ Computed из Signals\n  userPostCount = computed(() => {\n    const user = this.user();\n    const posts = this.posts();\n    \n    if (!user) return 0;\n    \n    return posts.filter(p => p.userId === user.id).length;\n  });\n\n  // ✅ Computed → Observable (если нужно)\n  userPostCount$ = toObservable(this.userPostCount);\n\n  constructor(\n    private userService: UserService,\n    private postService: PostService\n  ) {}\n}\n```\n\n**Migration Strategy - RxJS → Signals:**\n\n```typescript\n// ❌ БЫЛО: только RxJS\n@Component({\n  selector: 'app-old',\n  template: `\n    <div *ngFor=\"let user of users$ | async\">{{ user.name }}</div>\n  `\n})\nexport class OldComponent {\n  users$ = this.userService.getUsers();\n  \n  constructor(private userService: UserService) {}\n}\n\n// ✅ СТАЛО: Signals с toSignal\n@Component({\n  selector: 'app-new',\n  template: `\n    @for (user of users(); track user.id) {\n      <div>{{ user.name }}</div>\n    }\n  `\n})\nexport class NewComponent {\n  users = toSignal(this.userService.getUsers(), { initialValue: [] });\n  \n  constructor(private userService: UserService) {}\n}\n\n// ✅ ИЛИ: полностью на Signals\n@Injectable({ providedIn: 'root' })\nexport class ModernUserService {\n  private usersSignal = signal<User[]>([]);\n  users = this.usersSignal.asReadonly();\n\n  loadUsers() {\n    this.http.get<User[]>('/api/users').subscribe(\n      users => this.usersSignal.set(users)\n    );\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ toSignal для данных из Observable\nusers = toSignal(http.get('/api/users'), { initialValue: [] });\n\n// ✅ toObservable для использования RxJS операторов\nquery$ = toObservable(querySignal).pipe(\n  debounceTime(300),\n  switchMap(q => this.search(q))\n);\n\n// ✅ Computed для производных данных\nfilteredUsers = computed(() => {\n  const query = this.searchQuery();\n  const users = this.users();\n  return users.filter(u => u.name.includes(query));\n});\n\n// ❌ НЕ смешивайте без необходимости\n// Если можете сделать на чистых Signals - делайте\n\n// ✅ Используйте toSignal/toObservable для interop\n// когда работаете с legacy RxJS кодом или нужны RxJS операторы\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 29,
          "question_number_in_chapter": 9,
          "question_chapter": 3,
          "question_title": "Как создавать custom RxJS операторы? Pipeable operators?",
          "answer_markdown": "**Ответ:**\n\n**Custom RxJS операторы** позволяют инкапсулировать повторяющуюся логику обработки потоков.\n\n**1. Простой custom operator:**\n\n```typescript\nimport { pipe } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\n// ✅ Custom operator - функция, возвращающая pipe\nexport function filterAndDouble() {\n  return pipe(\n    filter((value: number) => value % 2 === 0),\n    map((value: number) => value * 2)\n  );\n}\n\n// Использование\nof(1, 2, 3, 4, 5).pipe(\n  filterAndDouble()\n).subscribe(console.log);\n// 4, 8\n```\n\n**2. Custom operator с параметрами:**\n\n```typescript\nimport { MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { tap, finalize } from 'rxjs/operators';\n\n// ✅ Оператор для логирования с префиксом\nexport function logWithPrefix<T>(prefix: string): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.pipe(\n    tap({\n      next: value => console.log(`[${prefix}] Next:`, value),\n      error: error => console.error(`[${prefix}] Error:`, error),\n      complete: () => console.log(`[${prefix}] Complete`)\n    }),\n    finalize(() => console.log(`[${prefix}] Finalized`))\n  );\n}\n\n// Использование\nthis.http.get('/api/data').pipe(\n  logWithPrefix('UserService')\n).subscribe();\n// [UserService] Next: {...}\n// [UserService] Complete\n// [UserService] Finalized\n```\n\n**3. Custom operator для обработки ошибок:**\n\n```typescript\nimport { Observable, throwError, timer } from 'rxjs';\nimport { retryWhen, mergeMap } from 'rxjs/operators';\n\ninterface RetryConfig {\n  maxRetries: number;\n  delayMs: number;\n  exponentialBackoff?: boolean;\n}\n\n// ✅ Умный retry с экспоненциальной задержкой\nexport function smartRetry<T>(config: RetryConfig) {\n  const { maxRetries, delayMs, exponentialBackoff = false } = config;\n\n  return (source: Observable<T>) => source.pipe(\n    retryWhen(errors =>\n      errors.pipe(\n        mergeMap((error, index) => {\n          if (index >= maxRetries) {\n            return throwError(() => error);\n          }\n\n          const delay = exponentialBackoff\n            ? delayMs * Math.pow(2, index)\n            : delayMs;\n\n          console.log(`Retry ${index + 1}/${maxRetries} after ${delay}ms`);\n\n          return timer(delay);\n        })\n      )\n    )\n  );\n}\n\n// Использование\nthis.http.get('/api/data').pipe(\n  smartRetry({\n    maxRetries: 3,\n    delayMs: 1000,\n    exponentialBackoff: true\n  })\n).subscribe();\n```\n\n**4. Custom operator для кеширования:**\n\n```typescript\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { tap, shareReplay } from 'rxjs/operators';\n\n// ✅ Оператор для кеширования с инвалидацией\nexport function cacheWithInvalidation<T>(\n  invalidate$: Observable<void>\n) {\n  return (source: Observable<T>) => {\n    const cache$ = source.pipe(\n      shareReplay({ bufferSize: 1, refCount: true })\n    );\n\n    // Инвалидация кеша\n    invalidate$.subscribe(() => {\n      console.log('Cache invalidated');\n      // Новый запрос при следующей подписке\n    });\n\n    return cache$;\n  };\n}\n\n// Использование\n@Injectable({ providedIn: 'root' })\nexport class DataService {\n  private invalidate$ = new Subject<void>();\n\n  data$ = this.http.get('/api/data').pipe(\n    cacheWithInvalidation(this.invalidate$)\n  );\n\n  invalidateCache() {\n    this.invalidate$.next();\n  }\n}\n```\n\n**5. Custom operator для loading state:**\n\n```typescript\nimport { Observable } from 'rxjs';\nimport { tap, finalize } from 'rxjs/operators';\n\n// ✅ Автоматическое управление loading state\nexport function withLoading<T>(\n  loadingSubject: BehaviorSubject<boolean>\n) {\n  return (source: Observable<T>) => source.pipe(\n    tap(() => loadingSubject.next(true)),\n    finalize(() => loadingSubject.next(false))\n  );\n}\n\n// Использование\n@Component({\n  selector: 'app-users'\n})\nexport class UsersComponent {\n  private loadingSubject = new BehaviorSubject(false);\n  loading$ = this.loadingSubject.asObservable();\n\n  users$ = this.http.get<User[]>('/api/users').pipe(\n    withLoading(this.loadingSubject)\n  );\n}\n```\n\n**6. Advanced custom operator - debounceAfterFirst:**\n\n```typescript\nimport { Observable, merge, race, NEVER } from 'rxjs';\nimport { debounceTime, take, switchMap } from 'rxjs/operators';\n\n// ✅ Первое значение сразу, остальные с debounce\nexport function debounceAfterFirst<T>(dueTime: number) {\n  return (source: Observable<T>) =>\n    source.pipe(\n      switchMap((value, index) => {\n        // Первое значение сразу\n        if (index === 0) {\n          return new Observable(observer => {\n            observer.next(value);\n          });\n        }\n\n        // Остальные с debounce\n        return source.pipe(\n          debounceTime(dueTime),\n          take(1)\n        );\n      })\n    );\n}\n\n// Использование\nsearchControl.valueChanges.pipe(\n  debounceAfterFirst(300)\n).subscribe(query => console.log(query));\n// Первое значение: сразу\n// Остальные: через 300ms\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте TypeScript типы\nexport function myOperator<T>(): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.pipe(/* ... */);\n}\n\n// ✅ Добавляйте параметры для гибкости\nexport function myOperator<T>(config: Config): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.pipe(/* ... */);\n}\n\n// ✅ Комбинируйте существующие операторы\nexport function myOperator<T>() {\n  return pipe(\n    filter(/* ... */),\n    map(/* ... */),\n    tap(/* ... */)\n  );\n}\n\n// ✅ Документируйте behaviour\n/**\n * Filters even numbers and doubles them\n * @example\n * of(1,2,3,4).pipe(filterAndDouble())\n * // Output: 4, 8\n */\nexport function filterAndDouble() { /* ... */ }\n\n// ❌ НЕ изменяйте source напрямую\nexport function badOperator<T>() {\n  return (source: Observable<T>) => {\n    source.subscribe(/* ... */);  // ❌ Плохо!\n    return source;\n  };\n}\n\n// ✅ Возвращайте новый Observable\nexport function goodOperator<T>() {\n  return (source: Observable<T>) => source.pipe(/* ... */);\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 30,
          "question_number_in_chapter": 10,
          "question_chapter": 3,
          "question_title": "Best practices и common pitfalls в RxJS? Что нужно знать Senior разработчику?",
          "answer_markdown": "**Ответ:**\n\n**Best Practices:**\n\n**1. Используйте декларативный подход:**\n\n```typescript\n// ❌ Императивный подход\n@Component({\n  selector: 'app-bad'\n})\nexport class BadComponent implements OnInit {\n  users: User[] = [];\n  loading = false;\n\n  ngOnInit() {\n    this.loading = true;\n    this.userService.getUsers().subscribe(users => {\n      this.users = users;\n      this.loading = false;\n    });\n  }\n}\n\n// ✅ Декларативный подход\n@Component({\n  selector: 'app-good',\n  template: `\n    @if (state$ | async; as state) {\n      @if (state.loading) {\n        <div>Loading...</div>\n      } @else {\n        <div *ngFor=\"let user of state.users\">{{ user.name }}</div>\n      }\n    }\n  `\n})\nexport class GoodComponent {\n  state$ = this.userService.getUsers().pipe(\n    map(users => ({ users, loading: false })),\n    startWith({ users: [], loading: true })\n  );\n\n  constructor(private userService: UserService) {}\n}\n```\n\n**2. Избегайте вложенных subscribe:**\n\n```typescript\n// ❌ Вложенные subscribe\nthis.route.params.subscribe(params => {\n  this.userService.getUser(params['id']).subscribe(user => {\n    this.postService.getUserPosts(user.id).subscribe(posts => {\n      this.posts = posts;  // ❌ Ад подписок!\n    });\n  });\n});\n\n// ✅ Используйте операторы\nthis.route.params.pipe(\n  switchMap(params => this.userService.getUser(params['id'])),\n  switchMap(user => this.postService.getUserPosts(user.id))\n).subscribe(posts => this.posts = posts);\n```\n\n**3. Всегда отписывайтесь:**\n\n```typescript\n// ❌ Утечки памяти\ninterval(1000).subscribe(n => console.log(n));\n\n// ✅ Используйте async pipe\ntemplate: `{{ interval$ | async }}`\n\n// ✅ Или takeUntilDestroyed\ninterval(1000).pipe(\n  takeUntilDestroyed()\n).subscribe();\n```\n\n**4. Обрабатывайте ошибки:**\n\n```typescript\n// ❌ Без обработки ошибок\nthis.http.get('/api/data').subscribe();\n\n// ✅ С обработкой ошибок\nthis.http.get('/api/data').pipe(\n  catchError(error => {\n    console.error(error);\n    return of(null);\n  })\n).subscribe();\n```\n\n**5. Используйте shareReplay для HTTP запросов:**\n\n```typescript\n// ❌ Множественные запросы\ndata$ = this.http.get('/api/data');\n\n// ✅ Один запрос, кеширование\ndata$ = this.http.get('/api/data').pipe(\n  shareReplay({ bufferSize: 1, refCount: true })\n);\n```\n\n**Common Pitfalls (частые ошибки):**\n\n**1. Забывают про cold/hot Observable:**\n\n```typescript\n// ❌ Проблема\nconst data$ = this.http.get('/api/data');\ndata$.subscribe(d1 => console.log(d1));  // Запрос 1\ndata$.subscribe(d2 => console.log(d2));  // Запрос 2\n\n// ✅ Решение\nconst data$ = this.http.get('/api/data').pipe(shareReplay(1));\ndata$.subscribe(d1 => console.log(d1));  // Запрос 1\ndata$.subscribe(d2 => console.log(d2));  // Используется кеш\n```\n\n**2. Неправильный выбор flattening оператора:**\n\n```typescript\n// ❌ Используют mergeMap для поиска\nsearchInput$.pipe(\n  mergeMap(query => this.search(query))  // ❌ Порядок не гарантирован!\n)\n\n// ✅ Используют switchMap\nsearchInput$.pipe(\n  switchMap(query => this.search(query))  // ✅ Отменяет предыдущие\n)\n```\n\n**3. Игнорируют backpressure:**\n\n```typescript\n// ❌ Слишком частые события\nfromEvent(window, 'resize').subscribe(event => {\n  this.handleResize();  // ❌ Вызовется очень часто!\n});\n\n// ✅ Используют debounce/throttle\nfromEvent(window, 'resize').pipe(\n  debounceTime(300)\n).subscribe(() => this.handleResize());\n```\n\n**4. Забывают про complete:**\n\n```typescript\n// ❌ Subject не завершён\nngOnDestroy() {\n  this.destroy$.next();  // ❌ Забыли complete!\n}\n\n// ✅ Правильное завершение\nngOnDestroy() {\n  this.destroy$.next();\n  this.destroy$.complete();  // ✅\n}\n```\n\n**5. Используют BehaviorSubject неправильно:**\n\n```typescript\n// ❌ Экспортируют Subject\npublic user$ = new BehaviorSubject<User | null>(null);\n\n// ✅ Экспортируют Observable\nprivate userSubject = new BehaviorSubject<User | null>(null);\nuser$ = this.userSubject.asObservable();\n```\n\n**Senior-level знания:**\n\n```typescript\n// ✅ 1. Знание всех типов Subject\nSubject, BehaviorSubject, ReplaySubject, AsyncSubject\n\n// ✅ 2. Понимание marble diagrams\n// a--b--c--|\n// ---d-e---|\n// merge: a--bd-ec--|\n\n// ✅ 3. Custom operators\nexport function myOperator<T>() { /* ... */ }\n\n// ✅ 4. Scheduler'ы для тестирования\nTestScheduler, asyncScheduler\n\n// ✅ 5. Multicasting strategies\nshare, shareReplay, publish, multicast\n\n// ✅ 6. Error recovery patterns\ncatchError, retry, retryWhen\n\n// ✅ 7. Memory management\ntakeUntil, takeUntilDestroyed, finalize\n\n// ✅ 8. Performance optimization\ndebounceTime, throttleTime, auditTime, shareReplay\n```",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 4,
      "chapter_title": "Routing & Navigation",
      "questions": [
        {
          "question_number": 31,
          "question_number_in_chapter": 1,
          "question_chapter": 4,
          "question_title": "Как настроить Router в Angular? Routes, RouterModule, provideRouter?",
          "answer_markdown": "**Ответ:**\n\n**Angular Router** — мощная система маршрутизации для SPA (Single Page Applications).\n\n**Конфигурация (NgModule подход):**\n\n```typescript\n// app-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n  { path: 'users', component: UsersComponent },\n  { path: 'users/:id', component: UserDetailComponent },\n  { path: '**', component: NotFoundComponent }  // Wildcard route\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}\n```\n\n**Конфигурация (Standalone подход - Angular 14+):**\n\n```typescript\n// app.routes.ts\nimport { Routes } from '@angular/router';\n\nexport const routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n  { path: 'users', component: UsersComponent },\n  { path: 'users/:id', component: UserDetailComponent },\n  { path: '**', component: NotFoundComponent }\n];\n\n// main.ts\nimport { provideRouter } from '@angular/router';\nimport { routes } from './app/app.routes';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideRouter(routes)\n  ]\n});\n```\n\n**Route конфигурация:**\n\n```typescript\ninterface Route {\n  path?: string;                    // URL путь\n  component?: Type<any>;            // Компонент для отображения\n  redirectTo?: string;              // Перенаправление\n  pathMatch?: 'full' | 'prefix';   // Стратегия совпадения\n  children?: Routes;                // Дочерние роуты\n  loadChildren?: () => Promise;     // Lazy loading\n  canActivate?: any[];              // Guards для активации\n  canDeactivate?: any[];            // Guards для деактивации\n  resolve?: any;                    // Resolvers\n  data?: any;                       // Произвольные данные\n  title?: string;                   // Title страницы (Angular 14+)\n}\n```\n\n**Примеры конфигурации:**\n\n```typescript\nconst routes: Routes = [\n  // ✅ Простой роут\n  { path: 'home', component: HomeComponent },\n\n  // ✅ Роут с параметром\n  { path: 'users/:id', component: UserDetailComponent },\n\n  // ✅ Редирект\n  { path: '', redirectTo: '/home', pathMatch: 'full' },\n\n  // ✅ Дочерние роуты\n  {\n    path: 'admin',\n    component: AdminComponent,\n    children: [\n      { path: 'users', component: AdminUsersComponent },\n      { path: 'settings', component: AdminSettingsComponent }\n    ]\n  },\n\n  // ✅ Lazy loading\n  {\n    path: 'products',\n    loadChildren: () => import('./products/products.routes').then(m => m.routes)\n  },\n\n  // ✅ Guards и Resolvers\n  {\n    path: 'profile',\n    component: ProfileComponent,\n    canActivate: [AuthGuard],\n    resolve: { user: UserResolver }\n  },\n\n  // ✅ Данные роута\n  {\n    path: 'contact',\n    component: ContactComponent,\n    data: { title: 'Contact Us', animation: 'fade' }\n  },\n\n  // ✅ Title (Angular 14+)\n  {\n    path: 'about',\n    component: AboutComponent,\n    title: 'About Us'  // Автоматически устанавливает <title>\n  },\n\n  // ✅ Wildcard (должен быть последним!)\n  { path: '**', component: NotFoundComponent }\n];\n```\n\n**Router Outlet:**\n\n```typescript\n// app.component.ts\n@Component({\n  selector: 'app-root',\n  template: `\n    <nav>\n      <a routerLink=\"/\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{exact: true}\">Home</a>\n      <a routerLink=\"/about\" routerLinkActive=\"active\">About</a>\n      <a routerLink=\"/users\" routerLinkActive=\"active\">Users</a>\n    </nav>\n\n    <!-- ✅ Здесь отображаются компоненты роутов -->\n    <router-outlet></router-outlet>\n  `,\n  standalone: true,\n  imports: [RouterOutlet, RouterLink, RouterLinkActive]\n})\nexport class AppComponent {}\n```\n\n**Named Outlets (именованные outlets):**\n\n```typescript\nconst routes: Routes = [\n  {\n    path: 'home',\n    component: HomeComponent,\n    children: [\n      { path: '', component: MainContentComponent },\n      { path: '', component: SidebarComponent, outlet: 'sidebar' }\n    ]\n  }\n];\n\n// Template\n@Component({\n  template: `\n    <router-outlet></router-outlet>\n    <router-outlet name=\"sidebar\"></router-outlet>\n  `\n})\n```\n\n**provideRouter с опциями (Angular 14+):**\n\n```typescript\nimport { \n  provideRouter, \n  withDebugTracing,           // Debug логи\n  withHashLocation,           // HashLocationStrategy\n  withInMemoryScrolling,      // Управление скроллингом\n  withPreloading,             // Стратегия preloading\n  PreloadAllModules\n} from '@angular/router';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideRouter(\n      routes,\n      withDebugTracing(),                    // Логирование роутера\n      withHashLocation(),                    // Использовать # в URL\n      withInMemoryScrolling({                // Скроллинг\n        scrollPositionRestoration: 'enabled',\n        anchorScrolling: 'enabled'\n      }),\n      withPreloading(PreloadAllModules)      // Preload всех lazy модулей\n    )\n  ]\n});\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Wildcard роут всегда последний\nconst routes: Routes = [\n  { path: 'home', component: HomeComponent },\n  { path: '**', component: NotFoundComponent }  // ✅ Последний\n];\n\n// ✅ pathMatch: 'full' для редиректов пустого пути\n{ path: '', redirectTo: '/home', pathMatch: 'full' }\n\n// ✅ Используйте Standalone с provideRouter (Angular 14+)\nprovideRouter(routes)\n\n// ✅ Организуйте роуты по feature modules\nexport const routes: Routes = [\n  ...homeRoutes,\n  ...userRoutes,\n  ...adminRoutes\n];\n\n// ✅ Используйте title для SEO\n{ path: 'products', component: ProductsComponent, title: 'Products - MyApp' }\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 32,
          "question_number_in_chapter": 2,
          "question_chapter": 4,
          "question_title": "Как работать с Route параметрами? Params, QueryParams, Fragment?",
          "answer_markdown": "**Ответ:**\n\n**Angular Router** предоставляет несколько способов передачи данных через URL.\n\n**Типы параметров:**\n\n| Тип | Синтаксис | Пример | Use Case |\n|-----|-----------|--------|----------|\n| **Route Params** | `/users/:id` | `/users/123` | Идентификаторы |\n| **Query Params** | `?key=value` | `/search?q=angular` | Фильтры, поиск |\n| **Fragment** | `#section` | `/page#top` | Якоря на странице |\n\n**1. Route Parameters (обязательные параметры):**\n\n```typescript\n// Конфигурация\nconst routes: Routes = [\n  { path: 'users/:id', component: UserDetailComponent },\n  { path: 'posts/:postId/comments/:commentId', component: CommentComponent }\n];\n\n// Получение параметров (snapshot)\n@Component({\n  selector: 'app-user-detail'\n})\nexport class UserDetailComponent implements OnInit {\n  userId!: string;\n\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    // ✅ Snapshot (для статических роутов)\n    this.userId = this.route.snapshot.paramMap.get('id')!;\n    console.log('User ID:', this.userId);\n  }\n}\n\n// Получение параметров (Observable)\n@Component({\n  selector: 'app-user-detail'\n})\nexport class UserDetailComponent implements OnInit {\n  user$ = this.route.params.pipe(\n    switchMap(params => this.userService.getUser(params['id']))\n  );\n\n  constructor(\n    private route: ActivatedRoute,\n    private userService: UserService\n  ) {}\n}\n\n// ✅ Modern way с toSignal (Angular 16+)\n@Component({\n  selector: 'app-user-detail'\n})\nexport class UserDetailComponent {\n  userId = toSignal(\n    this.route.params.pipe(map(params => params['id'])),\n    { initialValue: '' }\n  );\n\n  user = toSignal(\n    toObservable(this.userId).pipe(\n      switchMap(id => this.userService.getUser(id))\n    )\n  );\n\n  constructor(\n    private route: ActivatedRoute,\n    private userService: UserService\n  ) {}\n}\n```\n\n**Навигация с параметрами:**\n\n```typescript\n// Template\n<a [routerLink]=\"['/users', userId]\">User {{ userId }}</a>\n\n// Component\nthis.router.navigate(['/users', userId]);\nthis.router.navigateByUrl(`/users/${userId}`);\n```\n\n**2. Query Parameters (опциональные параметры):**\n\n```typescript\n// Получение query params\n@Component({\n  selector: 'app-search'\n})\nexport class SearchComponent implements OnInit {\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    // ✅ Snapshot\n    const query = this.route.snapshot.queryParamMap.get('q');\n    const page = this.route.snapshot.queryParamMap.get('page');\n\n    // ✅ Observable\n    this.route.queryParams.pipe(\n      map(params => ({\n        query: params['q'],\n        page: params['page'] || 1,\n        category: params['category']\n      }))\n    ).subscribe(filters => {\n      this.search(filters);\n    });\n  }\n}\n\n// ✅ Reactive approach\n@Component({\n  selector: 'app-products'\n})\nexport class ProductsComponent {\n  filters = toSignal(\n    this.route.queryParams.pipe(\n      map(params => ({\n        search: params['search'] || '',\n        category: params['category'] || '',\n        minPrice: Number(params['minPrice']) || 0,\n        maxPrice: Number(params['maxPrice']) || 1000\n      }))\n    ),\n    { initialValue: { search: '', category: '', minPrice: 0, maxPrice: 1000 } }\n  );\n\n  products = toSignal(\n    toObservable(this.filters).pipe(\n      debounceTime(300),\n      switchMap(filters => this.productService.search(filters))\n    ),\n    { initialValue: [] }\n  );\n\n  constructor(\n    private route: ActivatedRoute,\n    private productService: ProductService\n  ) {}\n}\n```\n\n**Навигация с query params:**\n\n```typescript\n// Template\n<a [routerLink]=\"['/search']\" \n   [queryParams]=\"{q: 'angular', page: 1}\">\n  Search\n</a>\n\n// Component\nthis.router.navigate(['/search'], {\n  queryParams: { q: 'angular', page: 1 }\n});\n\n// ✅ Сохранение существующих query params\nthis.router.navigate(['/search'], {\n  queryParams: { page: 2 },\n  queryParamsHandling: 'merge'  // Merge с существующими\n});\n\n// ✅ Удаление query params\nthis.router.navigate(['/search'], {\n  queryParams: {}\n});\n```\n\n**3. Fragment (якорь на странице):**\n\n```typescript\n// Получение fragment\nthis.route.fragment.subscribe(fragment => {\n  if (fragment) {\n    const element = document.getElementById(fragment);\n    element?.scrollIntoView();\n  }\n});\n\n// Навигация с fragment\n<a [routerLink]=\"['/page']\" fragment=\"section-2\">Go to Section 2</a>\n\nthis.router.navigate(['/page'], { fragment: 'section-2' });\n```\n\n**Комбинирование всех типов параметров:**\n\n```typescript\n// URL: /products/123?sort=price&order=asc#reviews\n{\n  path: 'products/:id',\n  component: ProductDetailComponent\n}\n\n@Component({\n  selector: 'app-product-detail'\n})\nexport class ProductDetailComponent implements OnInit {\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    // ✅ Все параметры разом\n    combineLatest([\n      this.route.params,\n      this.route.queryParams,\n      this.route.fragment\n    ]).subscribe(([params, queryParams, fragment]) => {\n      const productId = params['id'];\n      const sort = queryParams['sort'];\n      const order = queryParams['order'];\n      const section = fragment;\n\n      this.loadProduct(productId, sort, order);\n      if (section) {\n        this.scrollToSection(section);\n      }\n    });\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте paramMap вместо params\nthis.route.snapshot.paramMap.get('id')  // ✅\nthis.route.snapshot.params['id']         // ⚠️ Старый способ\n\n// ✅ Используйте Observable для динамических роутов\nthis.route.params.pipe(\n  switchMap(params => this.loadData(params['id']))\n)\n\n// ✅ Используйте snapshot для статических роутов\nconst id = this.route.snapshot.paramMap.get('id');\n\n// ✅ queryParamsHandling для сохранения query params\nthis.router.navigate(['/page'], {\n  queryParamsHandling: 'preserve'  // Сохраняет все\n  // или 'merge' для объединения\n});\n\n// ✅ Типизация параметров\ninterface ProductParams {\n  id: string;\n  category?: string;\n}\n\nthis.route.params.pipe(\n  map(params => params as ProductParams)\n);\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 33,
          "question_number_in_chapter": 3,
          "question_chapter": 4,
          "question_title": "Что такое Route Guards? CanActivate, CanDeactivate, CanLoad, Resolve?",
          "answer_markdown": "**Ответ:**\n\n**Route Guards** — защита роутов, позволяющая контролировать доступ и поведение навигации.\n\n**Типы Guards:**\n\n| Guard | Назначение | Когда срабатывает |\n|-------|------------|-------------------|\n| **CanActivate** | Проверка доступа к роуту | Перед активацией роута |\n| **CanActivateChild** | Проверка доступа к дочерним роутам | Перед активацией child route |\n| **CanDeactivate** | Подтверждение ухода со страницы | Перед деактивацией роута |\n| **CanLoad** | Проверка доступа к lazy модулю | Перед загрузкой модуля |\n| **CanMatch** | Проверка совпадения роута | При выборе роута (Angular 14.1+) |\n| **Resolve** | Предзагрузка данных | Перед активацией роута |\n\n**1. CanActivate - проверка доступа:**\n\n```typescript\n// ✅ Functional Guard (Angular 15+, рекомендуется)\nexport const authGuard: CanActivateFn = (route, state) => {\n  const authService = inject(AuthService);\n  const router = inject(Router);\n\n  if (authService.isAuthenticated()) {\n    return true;\n  }\n\n  // Redirect на login\n  return router.createUrlTree(['/login'], {\n    queryParams: { returnUrl: state.url }\n  });\n};\n\n// Использование\nconst routes: Routes = [\n  {\n    path: 'profile',\n    component: ProfileComponent,\n    canActivate: [authGuard]\n  }\n];\n\n// ❌ Class-based Guard (старый способ)\n@Injectable({ providedIn: 'root' })\nexport class AuthGuard implements CanActivate {\n  constructor(\n    private authService: AuthService,\n    private router: Router\n  ) {}\n\n  canActivate(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): boolean | UrlTree {\n    if (this.authService.isAuthenticated()) {\n      return true;\n    }\n\n    return this.router.createUrlTree(['/login'], {\n      queryParams: { returnUrl: state.url }\n    });\n  }\n}\n```\n\n**CanActivate с Observable (async проверка):**\n\n```typescript\nexport const roleGuard: CanActivateFn = (route, state) => {\n  const authService = inject(AuthService);\n  const router = inject(Router);\n  const requiredRole = route.data['role'] as string;\n\n  return authService.currentUser$.pipe(\n    map(user => {\n      if (user && user.role === requiredRole) {\n        return true;\n      }\n      return router.createUrlTree(['/unauthorized']);\n    })\n  );\n};\n\n// Использование\n{\n  path: 'admin',\n  component: AdminComponent,\n  canActivate: [roleGuard],\n  data: { role: 'admin' }\n}\n```\n\n**2. CanDeactivate - подтверждение ухода:**\n\n```typescript\nexport interface CanComponentDeactivate {\n  canDeactivate: () => boolean | Observable<boolean>;\n}\n\nexport const unsavedChangesGuard: CanDeactivateFn<CanComponentDeactivate> = \n  (component) => {\n    return component.canDeactivate ? \n      component.canDeactivate() : \n      true;\n  };\n\n// Component с несохранёнными изменениями\n@Component({\n  selector: 'app-form'\n})\nexport class FormComponent implements CanComponentDeactivate {\n  hasUnsavedChanges = false;\n\n  canDeactivate(): boolean | Observable<boolean> {\n    if (this.hasUnsavedChanges) {\n      return confirm('У вас есть несохранённые изменения. Покинуть страницу?');\n    }\n    return true;\n  }\n\n  onSubmit() {\n    // Save data\n    this.hasUnsavedChanges = false;\n  }\n}\n\n// Route config\n{\n  path: 'edit/:id',\n  component: FormComponent,\n  canDeactivate: [unsavedChangesGuard]\n}\n```\n\n**3. CanLoad - защита lazy loading:**\n\n```typescript\nexport const canLoadGuard: CanLoadFn = (route, segments) => {\n  const authService = inject(AuthService);\n  const router = inject(Router);\n\n  if (authService.isAuthenticated()) {\n    return true;\n  }\n\n  // ✅ Не загружаем модуль, если не авторизован\n  return router.createUrlTree(['/login']);\n};\n\n// Route config\n{\n  path: 'admin',\n  loadChildren: () => import('./admin/admin.routes').then(m => m.routes),\n  canLoad: [canLoadGuard]  // ✅ Модуль не загрузится без авторизации\n}\n```\n\n**4. Resolve - предзагрузка данных:**\n\n```typescript\nexport const userResolver: ResolveFn<User> = (route, state) => {\n  const userService = inject(UserService);\n  const router = inject(Router);\n  const userId = route.paramMap.get('id')!;\n\n  return userService.getUser(userId).pipe(\n    catchError(() => {\n      router.navigate(['/not-found']);\n      return of(null);\n    })\n  );\n};\n\n// Route config\n{\n  path: 'users/:id',\n  component: UserDetailComponent,\n  resolve: { user: userResolver }  // ✅ Данные загрузятся ДО активации компонента\n}\n\n// Component\n@Component({\n  selector: 'app-user-detail'\n})\nexport class UserDetailComponent implements OnInit {\n  user!: User;\n\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    // ✅ Данные уже загружены Resolver'ом\n    this.user = this.route.snapshot.data['user'];\n  }\n}\n```\n\n**5. CanActivateChild - защита child routes:**\n\n```typescript\nexport const adminGuard: CanActivateChildFn = (route, state) => {\n  const authService = inject(AuthService);\n  return authService.hasAdminRole();\n};\n\n// Route config\n{\n  path: 'admin',\n  component: AdminComponent,\n  canActivateChild: [adminGuard],  // ✅ Применяется ко всем child routes\n  children: [\n    { path: 'users', component: AdminUsersComponent },\n    { path: 'settings', component: AdminSettingsComponent }\n  ]\n}\n```\n\n**Комбинирование Guards:**\n\n```typescript\n{\n  path: 'dashboard',\n  component: DashboardComponent,\n  canActivate: [authGuard, roleGuard],        // Все должны вернуть true\n  canDeactivate: [unsavedChangesGuard],\n  resolve: { data: dashboardResolver }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте Functional Guards (Angular 15+)\nexport const myGuard: CanActivateFn = () => { /* ... */ };\n\n// ✅ Возвращайте UrlTree для редиректов\nreturn router.createUrlTree(['/login']);\n\n// ✅ Используйте CanLoad для защиты lazy modules\ncanLoad: [authGuard]\n\n// ✅ Используйте Resolve для критичных данных\nresolve: { user: userResolver }\n\n// ❌ НЕ делайте тяжёлые операции в Guards\n// Guards должны быть быстрыми!\n\n// ✅ Обрабатывайте ошибки в Resolvers\nreturn data$.pipe(\n  catchError(() => {\n    router.navigate(['/error']);\n    return of(null);\n  })\n);\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 34,
          "question_number_in_chapter": 4,
          "question_chapter": 4,
          "question_title": "Что такое Lazy Loading? Как загружать модули и компоненты лениво?",
          "answer_markdown": "**Ответ:**\n\n**Lazy Loading** — отложенная загрузка модулей и компонентов только когда они нужны, что значительно ускоряет initial load time.\n\n**Lazy Loading Modules (NgModule):**\n\n```typescript\n// app-routing.module.ts\nconst routes: Routes = [\n  {\n    path: 'products',\n    loadChildren: () => import('./products/products.module').then(m => m.ProductsModule)\n  },\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),\n    canLoad: [AuthGuard]  // ✅ Не загружаем без авторизации\n  }\n];\n\n// products/products.module.ts\n@NgModule({\n  declarations: [ProductListComponent, ProductDetailComponent],\n  imports: [\n    CommonModule,\n    RouterModule.forChild([\n      { path: '', component: ProductListComponent },\n      { path: ':id', component: ProductDetailComponent }\n    ])\n  ]\n})\nexport class ProductsModule {}\n```\n\n**Lazy Loading Standalone Components (Angular 14+, рекомендуется):**\n\n```typescript\n// app.routes.ts\nexport const routes: Routes = [\n  {\n    path: 'products',\n    loadChildren: () => import('./products/products.routes').then(m => m.routes)\n  },\n  {\n    path: 'about',\n    loadComponent: () => import('./about/about.component').then(m => m.AboutComponent)\n  }\n];\n\n// products/products.routes.ts\nimport { Routes } from '@angular/router';\n\nexport const routes: Routes = [\n  {\n    path: '',\n    loadComponent: () => import('./product-list/product-list.component')\n      .then(m => m.ProductListComponent)\n  },\n  {\n    path: ':id',\n    loadComponent: () => import('./product-detail/product-detail.component')\n      .then(m => m.ProductDetailComponent)\n  }\n];\n```\n\n**Lazy Loading с Layout Component:**\n\n```typescript\nexport const routes: Routes = [\n  {\n    path: 'admin',\n    loadComponent: () => import('./admin/admin-layout.component')\n      .then(m => m.AdminLayoutComponent),\n    canActivate: [authGuard],\n    children: [\n      {\n        path: 'users',\n        loadComponent: () => import('./admin/users/users.component')\n          .then(m => m.UsersComponent)\n      },\n      {\n        path: 'settings',\n        loadComponent: () => import('./admin/settings/settings.component')\n          .then(m => m.SettingsComponent)\n      }\n    ]\n  }\n];\n\n// admin-layout.component.ts\n@Component({\n  selector: 'app-admin-layout',\n  template: `\n    <div class=\"admin-layout\">\n      <app-admin-sidebar></app-admin-sidebar>\n      <div class=\"content\">\n        <router-outlet></router-outlet>\n      </div>\n    </div>\n  `,\n  standalone: true,\n  imports: [RouterOutlet, AdminSidebarComponent]\n})\nexport class AdminLayoutComponent {}\n```\n\n**Lazy Loading с Providers:**\n\n```typescript\nexport const routes: Routes = [\n  {\n    path: 'shop',\n    loadChildren: () => import('./shop/shop.routes').then(m => m.routes),\n    // ✅ Providers только для этого роута и его детей\n    providers: [\n      ShopService,\n      provideHttpClient()\n    ]\n  }\n];\n```\n\n**Сравнение подходов:**\n\n| Подход | Что загружается | Размер бандла | Когда использовать |\n|--------|-----------------|---------------|-------------------|\n| **loadChildren** (routes) | Набор роутов | Средний | Feature routes |\n| **loadComponent** | Один компонент | Маленький | Простые страницы |\n| **loadChildren** (NgModule) | Весь модуль | Большой | Legacy код |\n\n**Preloading для улучшения UX:**\n\n```typescript\n// app.config.ts\nimport { PreloadAllModules } from '@angular/router';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideRouter(\n      routes,\n      withPreloading(PreloadAllModules)  // ✅ Preload всех lazy модулей\n    )\n  ]\n});\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте loadComponent для Standalone (Angular 14+)\n{\n  path: 'about',\n  loadComponent: () => import('./about.component').then(m => m.AboutComponent)\n}\n\n// ✅ Группируйте связанные роуты\n{\n  path: 'products',\n  loadChildren: () => import('./products/products.routes').then(m => m.routes)\n}\n\n// ✅ Используйте canLoad для защиты lazy модулей\n{\n  path: 'admin',\n  loadChildren: () => import('./admin/admin.routes'),\n  canLoad: [authGuard]\n}\n\n// ✅ Preload критичных модулей\nwithPreloading(PreloadAllModules)\n\n// ❌ НЕ lazy-load критичные модули (Home page)\n// ❌ НЕ создавайте слишком много мелких lazy chunks\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 35,
          "question_number_in_chapter": 5,
          "question_chapter": 4,
          "question_title": "Какие Router Events существуют? Как отслеживать навигацию?",
          "answer_markdown": "**Ответ:**\n\n**Router Events** позволяют отслеживать lifecycle навигации и реагировать на изменения роутов.\n\n**Основные Router Events:**\n\n| Event | Когда происходит | Use Case |\n|-------|------------------|----------|\n| **NavigationStart** | Начало навигации | Показать loader |\n| **RoutesRecognized** | Роуты распознаны | Логирование |\n| **RouteConfigLoadStart** | Начало загрузки lazy модуля | Loader для lazy |\n| **RouteConfigLoadEnd** | Конец загрузки lazy модуля | Скрыть loader |\n| **NavigationEnd** | Навигация завершена | Скрыть loader, analytics |\n| **NavigationCancel** | Навигация отменена (Guard) | Скрыть loader |\n| **NavigationError** | Ошибка навигации | Показать ошибку |\n| **Scroll** | Скролл события | Управление скроллом |\n\n**Базовое использование:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class RouterEventsService {\n  constructor(private router: Router) {\n    this.router.events.subscribe(event => {\n      console.log('Router Event:', event);\n    });\n  }\n}\n```\n\n**Фильтрация по типу события:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class LoadingService {\n  private loadingSubject = new BehaviorSubject<boolean>(false);\n  loading$ = this.loadingSubject.asObservable();\n\n  constructor(private router: Router) {\n    this.router.events.subscribe(event => {\n      if (event instanceof NavigationStart) {\n        this.loadingSubject.next(true);\n      }\n\n      if (\n        event instanceof NavigationEnd ||\n        event instanceof NavigationCancel ||\n        event instanceof NavigationError\n      ) {\n        this.loadingSubject.next(false);\n      }\n    });\n  }\n}\n\n// Использование в компоненте\n@Component({\n  selector: 'app-root',\n  template: `\n    @if (loading$ | async) {\n      <div class=\"loader\">Loading...</div>\n    }\n    <router-outlet></router-outlet>\n  `\n})\nexport class AppComponent {\n  loading$ = this.loadingService.loading$;\n\n  constructor(private loadingService: LoadingService) {}\n}\n```\n\n**RxJS операторы для Router Events:**\n\n```typescript\nimport { filter, map } from 'rxjs/operators';\n\n@Injectable({ providedIn: 'root' })\nexport class AnalyticsService {\n  constructor(private router: Router) {\n    // ✅ Только NavigationEnd события\n    this.router.events.pipe(\n      filter(event => event instanceof NavigationEnd),\n      map(event => event as NavigationEnd)\n    ).subscribe(event => {\n      console.log('Page view:', event.urlAfterRedirects);\n      this.trackPageView(event.urlAfterRedirects);\n    });\n  }\n\n  private trackPageView(url: string) {\n    // Google Analytics, etc.\n  }\n}\n```\n\n**Детальное отслеживание навигации:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class NavigationTrackerService {\n  constructor(private router: Router) {\n    this.router.events.subscribe(event => {\n      if (event instanceof NavigationStart) {\n        console.log('🚀 Navigation started to:', event.url);\n      }\n\n      if (event instanceof RoutesRecognized) {\n        console.log('✅ Routes recognized');\n      }\n\n      if (event instanceof RouteConfigLoadStart) {\n        console.log('📦 Loading lazy module...');\n      }\n\n      if (event instanceof RouteConfigLoadEnd) {\n        console.log('✅ Lazy module loaded');\n      }\n\n      if (event instanceof NavigationEnd) {\n        console.log('🎉 Navigation completed:', event.urlAfterRedirects);\n      }\n\n      if (event instanceof NavigationCancel) {\n        console.log('❌ Navigation cancelled:', event.reason);\n      }\n\n      if (event instanceof NavigationError) {\n        console.error('💥 Navigation error:', event.error);\n      }\n    });\n  }\n}\n```\n\n**Breadcrumbs с Router Events:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class BreadcrumbService {\n  private breadcrumbsSubject = new BehaviorSubject<Breadcrumb[]>([]);\n  breadcrumbs$ = this.breadcrumbsSubject.asObservable();\n\n  constructor(private router: Router, private activatedRoute: ActivatedRoute) {\n    this.router.events.pipe(\n      filter(event => event instanceof NavigationEnd)\n    ).subscribe(() => {\n      const breadcrumbs = this.createBreadcrumbs(this.activatedRoute.root);\n      this.breadcrumbsSubject.next(breadcrumbs);\n    });\n  }\n\n  private createBreadcrumbs(\n    route: ActivatedRoute,\n    url: string = '',\n    breadcrumbs: Breadcrumb[] = []\n  ): Breadcrumb[] {\n    const children: ActivatedRoute[] = route.children;\n\n    if (children.length === 0) {\n      return breadcrumbs;\n    }\n\n    for (const child of children) {\n      const routeURL: string = child.snapshot.url\n        .map(segment => segment.path)\n        .join('/');\n\n      if (routeURL !== '') {\n        url += `/${routeURL}`;\n      }\n\n      const label = child.snapshot.data['breadcrumb'];\n      if (label) {\n        breadcrumbs.push({ label, url });\n      }\n\n      return this.createBreadcrumbs(child, url, breadcrumbs);\n    }\n\n    return breadcrumbs;\n  }\n}\n\ninterface Breadcrumb {\n  label: string;\n  url: string;\n}\n\n// Route config\n{\n  path: 'products/:id',\n  component: ProductDetailComponent,\n  data: { breadcrumb: 'Product Detail' }\n}\n```\n\n**Progress Bar для навигации:**\n\n```typescript\n@Component({\n  selector: 'app-root',\n  template: `\n    @if (loading) {\n      <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n    }\n    <router-outlet></router-outlet>\n  `\n})\nexport class AppComponent implements OnInit {\n  loading = false;\n\n  constructor(private router: Router) {}\n\n  ngOnInit() {\n    this.router.events.subscribe(event => {\n      if (event instanceof NavigationStart) {\n        this.loading = true;\n      }\n\n      if (\n        event instanceof NavigationEnd ||\n        event instanceof NavigationCancel ||\n        event instanceof NavigationError\n      ) {\n        this.loading = false;\n      }\n    });\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте filter для конкретных событий\nrouter.events.pipe(\n  filter(event => event instanceof NavigationEnd)\n)\n\n// ✅ Отписывайтесь от событий (если подписка в компоненте)\nrouter.events.pipe(\n  takeUntilDestroyed()\n).subscribe();\n\n// ✅ Используйте для analytics, loading states, breadcrumbs\n// ❌ НЕ используйте для бизнес-логики\n\n// ✅ Обрабатывайте NavigationError\nif (event instanceof NavigationError) {\n  this.errorHandler.handleError(event.error);\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 36,
          "question_number_in_chapter": 6,
          "question_chapter": 4,
          "question_title": "Что такое Preloading Strategy? PreloadAllModules, custom strategies?",
          "answer_markdown": "**Ответ:**\n\n**Preloading Strategy** определяет, когда загружать lazy модули в фоне для улучшения UX.\n\n**Встроенные стратегии:**\n\n| Стратегия | Поведение | Use Case |\n|-----------|-----------|----------|\n| **NoPreloading** | Не загружает (по умолчанию) | Экономия трафика |\n| **PreloadAllModules** | Загружает все lazy модули | Быстрая навигация |\n\n**1. NoPreloading (по умолчанию):**\n\n```typescript\n// Модули загружаются только при переходе на роут\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideRouter(routes)  // ✅ NoPreloading по умолчанию\n  ]\n});\n```\n\n**2. PreloadAllModules:**\n\n```typescript\nimport { PreloadAllModules } from '@angular/router';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideRouter(\n      routes,\n      withPreloading(PreloadAllModules)  // ✅ Загружает все lazy модули\n    )\n  ]\n});\n```\n\n**3. Custom Preloading Strategy:**\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of, timer } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\n\n// ✅ Preload только роуты с data.preload = true\n@Injectable({ providedIn: 'root' })\nexport class SelectivePreloadingStrategy implements PreloadingStrategy {\n  preloadedModules: string[] = [];\n\n  preload(route: Route, load: () => Observable<any>): Observable<any> {\n    if (route.data && route.data['preload']) {\n      console.log('Preloading:', route.path);\n      this.preloadedModules.push(route.path || '');\n      return load();\n    }\n\n    return of(null);\n  }\n}\n\n// Route config\nexport const routes: Routes = [\n  {\n    path: 'products',\n    loadChildren: () => import('./products/products.routes'),\n    data: { preload: true }  // ✅ Будет preloaded\n  },\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.routes')\n    // ❌ Не будет preloaded\n  }\n];\n\n// main.ts\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideRouter(\n      routes,\n      withPreloading(SelectivePreloadingStrategy)\n    )\n  ]\n});\n```\n\n**Custom Strategy с задержкой:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class DelayedPreloadingStrategy implements PreloadingStrategy {\n  preload(route: Route, load: () => Observable<any>): Observable<any> {\n    const delay = route.data?.['preloadDelay'] || 0;\n\n    if (delay === 0) {\n      return of(null);\n    }\n\n    console.log(`Preloading ${route.path} after ${delay}ms`);\n\n    return timer(delay).pipe(\n      mergeMap(() => load())\n    );\n  }\n}\n\n// Route config\n{\n  path: 'products',\n  loadChildren: () => import('./products/products.routes'),\n  data: { preloadDelay: 2000 }  // ✅ Preload через 2 секунды\n}\n```\n\n**Network-aware Preloading:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class NetworkAwarePreloadingStrategy implements PreloadingStrategy {\n  preload(route: Route, load: () => Observable<any>): Observable<any> {\n    if (!route.data || !route.data['preload']) {\n      return of(null);\n    }\n\n    // ✅ Проверяем тип соединения (Network Information API)\n    const connection = (navigator as any).connection;\n\n    if (connection) {\n      // Preload только на быстром соединении\n      if (connection.effectiveType === '4g') {\n        console.log('Fast connection, preloading:', route.path);\n        return load();\n      }\n\n      // Не preload на медленном соединении\n      if (connection.saveData || connection.effectiveType === 'slow-2g') {\n        console.log('Slow connection, skipping preload:', route.path);\n        return of(null);\n      }\n    }\n\n    // По умолчанию preload\n    return load();\n  }\n}\n```\n\n**On-Demand Preloading (по клику):**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class OnDemandPreloadingService {\n  private preloadMap = new Map<string, () => Observable<any>>();\n\n  constructor(private router: Router) {\n    // Сохраняем функции загрузки модулей\n    this.router.config.forEach(route => {\n      if (route.loadChildren) {\n        this.preloadMap.set(route.path || '', route.loadChildren as any);\n      }\n    });\n  }\n\n  preload(path: string): void {\n    const load = this.preloadMap.get(path);\n    if (load) {\n      console.log('Preloading on-demand:', path);\n      load().subscribe();\n    }\n  }\n}\n\n// Использование\n@Component({\n  template: `\n    <button (mouseenter)=\"preloadProducts()\">\n      Products\n    </button>\n  `\n})\nexport class NavComponent {\n  constructor(private preloadService: OnDemandPreloadingService) {}\n\n  preloadProducts() {\n    // ✅ Preload при hover\n    this.preloadService.preload('products');\n  }\n}\n```\n\n**Monitoring Preloading:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class PreloadMonitorService {\n  private preloadedModules: string[] = [];\n\n  constructor(private router: Router) {\n    this.router.events.subscribe(event => {\n      if (event instanceof RouteConfigLoadStart) {\n        console.log('⏳ Loading module:', event.route.path);\n      }\n\n      if (event instanceof RouteConfigLoadEnd) {\n        console.log('✅ Module loaded:', event.route.path);\n        this.preloadedModules.push(event.route.path || '');\n      }\n    });\n  }\n\n  getPreloadedModules(): string[] {\n    return this.preloadedModules;\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ PreloadAllModules для небольших приложений\nwithPreloading(PreloadAllModules)\n\n// ✅ SelectivePreloading для больших приложений\ndata: { preload: true }\n\n// ✅ Network-aware для мобильных пользователей\n// Проверяйте connection.effectiveType\n\n// ✅ Preload критичных модулей\ndata: { preload: true, priority: 'high' }\n\n// ❌ НЕ preload редко используемых модулей\n// ❌ НЕ preload на медленных соединениях\n\n// ✅ Комбинируйте с lazy loading\n{\n  path: 'products',\n  loadChildren: () => import('./products'),\n  data: { preload: true }\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 37,
          "question_number_in_chapter": 7,
          "question_chapter": 4,
          "question_title": "Как делать Router Animations? Transitions между страницами?",
          "answer_markdown": "**Ответ:**\n\n**Router Animations** позволяют создавать плавные переходы между страницами для улучшения UX.\n\n**Базовая настройка:**\n\n```typescript\n// 1. Включаем animations\nimport { provideAnimations } from '@angular/platform-browser/animations';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideRouter(routes),\n    provideAnimations()  // ✅ Обязательно!\n  ]\n});\n\n// 2. Добавляем data в роуты\nexport const routes: Routes = [\n  { path: '', component: HomeComponent, data: { animation: 'HomePage' } },\n  { path: 'about', component: AboutComponent, data: { animation: 'AboutPage' } },\n  { path: 'contact', component: ContactComponent, data: { animation: 'ContactPage' } }\n];\n\n// 3. Создаём animations\nimport { \n  trigger, \n  transition, \n  style, \n  query, \n  group, \n  animate \n} from '@angular/animations';\n\nexport const slideInAnimation = trigger('routeAnimations', [\n  // ✅ Fade transition\n  transition('* <=> *', [\n    query(':enter, :leave', [\n      style({\n        position: 'absolute',\n        width: '100%',\n        opacity: 0\n      })\n    ], { optional: true }),\n    \n    group([\n      query(':leave', [\n        animate('300ms ease-out', style({ opacity: 0 }))\n      ], { optional: true }),\n      \n      query(':enter', [\n        animate('300ms ease-in', style({ opacity: 1 }))\n      ], { optional: true })\n    ])\n  ])\n]);\n\n// 4. Применяем в компоненте\n@Component({\n  selector: 'app-root',\n  template: `\n    <div [@routeAnimations]=\"getRouteAnimationData()\">\n      <router-outlet></router-outlet>\n    </div>\n  `,\n  animations: [slideInAnimation]\n})\nexport class AppComponent {\n  constructor(private contexts: ChildrenOutletContexts) {}\n\n  getRouteAnimationData() {\n    return this.contexts.getContext('primary')?.route?.snapshot?.data?.['animation'];\n  }\n}\n```\n\n**Slide Animation (влево/вправо):**\n\n```typescript\nexport const slideAnimation = trigger('routeAnimations', [\n  transition('HomePage => AboutPage', [\n    query(':enter, :leave', [\n      style({\n        position: 'absolute',\n        width: '100%'\n      })\n    ], { optional: true }),\n    \n    group([\n      query(':leave', [\n        animate('300ms ease-out', style({ transform: 'translateX(-100%)' }))\n      ], { optional: true }),\n      \n      query(':enter', [\n        style({ transform: 'translateX(100%)' }),\n        animate('300ms ease-in', style({ transform: 'translateX(0%)' }))\n      ], { optional: true })\n    ])\n  ]),\n\n  // Обратная анимация (справа налево)\n  transition('AboutPage => HomePage', [\n    query(':enter, :leave', [\n      style({\n        position: 'absolute',\n        width: '100%'\n      })\n    ], { optional: true }),\n    \n    group([\n      query(':leave', [\n        animate('300ms ease-out', style({ transform: 'translateX(100%)' }))\n      ], { optional: true }),\n      \n      query(':enter', [\n        style({ transform: 'translateX(-100%)' }),\n        animate('300ms ease-in', style({ transform: 'translateX(0%)' }))\n      ], { optional: true })\n    ])\n  ])\n]);\n```\n\n**Универсальная Slide Animation:**\n\n```typescript\nexport const routerTransition = trigger('routeAnimations', [\n  transition('* => *', [\n    query(':enter, :leave', [\n      style({\n        position: 'absolute',\n        width: '100%',\n        transform: 'translateX(0)',\n        opacity: 1\n      })\n    ], { optional: true }),\n\n    query(':enter', [\n      style({ \n        transform: 'translateX(100%)',\n        opacity: 0\n      })\n    ], { optional: true }),\n\n    group([\n      query(':leave', [\n        animate('400ms cubic-bezier(0.35, 0, 0.25, 1)', \n          style({ \n            transform: 'translateX(-100%)',\n            opacity: 0\n          })\n        )\n      ], { optional: true }),\n\n      query(':enter', [\n        animate('400ms cubic-bezier(0.35, 0, 0.25, 1)', \n          style({ \n            transform: 'translateX(0)',\n            opacity: 1\n          })\n        )\n      ], { optional: true })\n    ])\n  ])\n]);\n```\n\n**Zoom Animation:**\n\n```typescript\nexport const zoomAnimation = trigger('routeAnimations', [\n  transition('* <=> *', [\n    query(':enter, :leave', [\n      style({\n        position: 'absolute',\n        width: '100%'\n      })\n    ], { optional: true }),\n\n    group([\n      query(':leave', [\n        animate('300ms', style({ \n          transform: 'scale(0.8)',\n          opacity: 0\n        }))\n      ], { optional: true }),\n\n      query(':enter', [\n        style({ \n          transform: 'scale(1.2)',\n          opacity: 0\n        }),\n        animate('300ms', style({ \n          transform: 'scale(1)',\n          opacity: 1\n        }))\n      ], { optional: true })\n    ])\n  ])\n]);\n```\n\n**Комплексная анимация с разными направлениями:**\n\n```typescript\nexport const complexAnimation = trigger('routeAnimations', [\n  // Вперёд (HomePage → AboutPage → ContactPage)\n  transition('HomePage => AboutPage', slideLeft),\n  transition('AboutPage => ContactPage', slideLeft),\n\n  // Назад\n  transition('ContactPage => AboutPage', slideRight),\n  transition('AboutPage => HomePage', slideRight),\n\n  // По умолчанию - fade\n  transition('* <=> *', fade)\n]);\n\n// Helper functions\nconst slideLeft = [\n  query(':enter, :leave', [\n    style({ position: 'absolute', width: '100%' })\n  ], { optional: true }),\n  \n  group([\n    query(':leave', [\n      animate('300ms ease-out', style({ transform: 'translateX(-100%)' }))\n    ], { optional: true }),\n    \n    query(':enter', [\n      style({ transform: 'translateX(100%)' }),\n      animate('300ms ease-in', style({ transform: 'translateX(0%)' }))\n    ], { optional: true })\n  ])\n];\n\nconst slideRight = [\n  query(':enter, :leave', [\n    style({ position: 'absolute', width: '100%' })\n  ], { optional: true }),\n  \n  group([\n    query(':leave', [\n      animate('300ms ease-out', style({ transform: 'translateX(100%)' }))\n    ], { optional: true }),\n    \n    query(':enter', [\n      style({ transform: 'translateX(-100%)' }),\n      animate('300ms ease-in', style({ transform: 'translateX(0%)' }))\n    ], { optional: true })\n  ])\n];\n\nconst fade = [\n  query(':enter, :leave', [\n    style({ position: 'absolute', width: '100%', opacity: 1 })\n  ], { optional: true }),\n  \n  group([\n    query(':leave', [\n      animate('200ms', style({ opacity: 0 }))\n    ], { optional: true }),\n    \n    query(':enter', [\n      style({ opacity: 0 }),\n      animate('200ms', style({ opacity: 1 }))\n    ], { optional: true })\n  ])\n];\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте { optional: true } для query\nquery(':enter, :leave', [...], { optional: true })\n\n// ✅ Добавляйте data.animation в роуты\n{ path: 'home', component: HomeComponent, data: { animation: 'HomePage' } }\n\n// ✅ Используйте cubic-bezier для плавности\nanimate('300ms cubic-bezier(0.35, 0, 0.25, 1)', ...)\n\n// ✅ Группируйте анимации с group()\ngroup([query(':leave', ...), query(':enter', ...)])\n\n// ❌ НЕ делайте слишком долгие анимации (>500ms)\n// ❌ НЕ забывайте provideAnimations()\n\n// ✅ Тестируйте на медленных устройствах\n// ✅ Используйте prefers-reduced-motion для accessibility\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 38,
          "question_number_in_chapter": 8,
          "question_chapter": 4,
          "question_title": "Programmatic Navigation - как навигироваться программно? Best practices?",
          "answer_markdown": "**Ответ:**\n\n**Programmatic Navigation** — навигация через Router API вместо RouterLink.\n\n**Основные методы:**\n\n| Метод | Синтаксис | Use Case |\n|-------|-----------|----------|\n| **navigate()** | `navigate(['/path'])` | Относительная/абсолютная навигация |\n| **navigateByUrl()** | `navigateByUrl('/path')` | Абсолютная навигация |\n| **createUrlTree()** | `createUrlTree(['/path'])` | Создание UrlTree для Guards |\n\n**1. navigate() - основной метод:**\n\n```typescript\n@Component({\n  selector: 'app-example'\n})\nexport class ExampleComponent {\n  constructor(private router: Router) {}\n\n  // ✅ Абсолютная навигация\n  goToUsers() {\n    this.router.navigate(['/users']);\n  }\n\n  // ✅ Навигация с параметрами\n  goToUser(id: number) {\n    this.router.navigate(['/users', id]);\n    // Результат: /users/123\n  }\n\n  // ✅ Навигация с query params\n  searchProducts(query: string) {\n    this.router.navigate(['/products'], {\n      queryParams: { search: query, page: 1 }\n    });\n    // Результат: /products?search=angular&page=1\n  }\n\n  // ✅ Навигация с fragment\n  goToSection() {\n    this.router.navigate(['/docs'], { \n      fragment: 'installation' \n    });\n    // Результат: /docs#installation\n  }\n}\n```\n\n**2. Относительная навигация:**\n\n```typescript\n@Component({\n  selector: 'app-user-detail'\n})\nexport class UserDetailComponent {\n  constructor(\n    private router: Router,\n    private route: ActivatedRoute\n  ) {}\n\n  // ✅ Относительно текущего роута\n  goToEdit() {\n    // Текущий URL: /users/123\n    this.router.navigate(['edit'], { relativeTo: this.route });\n    // Результат: /users/123/edit\n  }\n\n  // ✅ Навигация на уровень выше\n  goToList() {\n    // Текущий URL: /users/123\n    this.router.navigate(['..'], { relativeTo: this.route });\n    // Результат: /users\n  }\n\n  // ✅ Навигация к сиблингу\n  goToSettings() {\n    // Текущий URL: /users/123/profile\n    this.router.navigate(['../settings'], { relativeTo: this.route });\n    // Результат: /users/123/settings\n  }\n}\n```\n\n**3. navigateByUrl() - абсолютная навигация:**\n\n```typescript\n// ✅ Простая навигация\nthis.router.navigateByUrl('/users');\n\n// ✅ С query params и fragment\nthis.router.navigateByUrl('/products?category=books#featured');\n\n// ⚠️ НЕ поддерживает массив сегментов\nthis.router.navigateByUrl(['/users', id]);  // ❌ Ошибка!\n\n// ✅ Используйте navigate() для параметров\nthis.router.navigate(['/users', id]);  // ✅ Правильно\n```\n\n**4. Navigation с опциями:**\n\n```typescript\n// ✅ Сохранение query params\nthis.router.navigate(['/page'], {\n  queryParamsHandling: 'preserve'  // Сохраняет существующие\n  // или 'merge' для объединения\n});\n\n// ✅ Замена истории (без добавления в history)\nthis.router.navigate(['/page'], {\n  replaceUrl: true  // Заменяет текущий URL в истории\n});\n\n// ✅ Скролл к якорю\nthis.router.navigate(['/page'], {\n  fragment: 'section-2',\n  scrollOffset: [0, 100]  // Offset 100px от верха\n});\n\n// ✅ State данные (доступны в history.state)\nthis.router.navigate(['/page'], {\n  state: { \n    fromDashboard: true,\n    userId: 123\n  }\n});\n\n// Получение state\nconst navigation = this.router.getCurrentNavigation();\nconst state = navigation?.extras.state;\nconsole.log(state?.fromDashboard);  // true\n```\n\n**5. Навигация с Guards проверкой:**\n\n```typescript\n// ✅ Навигация с проверкой успеха\nthis.router.navigate(['/admin']).then(success => {\n  if (success) {\n    console.log('Navigation successful');\n  } else {\n    console.log('Navigation blocked by guard');\n  }\n});\n\n// ✅ Обработка ошибок навигации\nthis.router.navigate(['/page']).catch(error => {\n  console.error('Navigation error:', error);\n  this.showErrorNotification();\n});\n```\n\n**6. createUrlTree() - для Guards:**\n\n```typescript\nexport const authGuard: CanActivateFn = (route, state) => {\n  const authService = inject(AuthService);\n  const router = inject(Router);\n\n  if (authService.isAuthenticated()) {\n    return true;\n  }\n\n  // ✅ Используем createUrlTree для редиректа\n  return router.createUrlTree(['/login'], {\n    queryParams: { returnUrl: state.url }\n  });\n};\n```\n\n**7. Навигация после успешной операции:**\n\n```typescript\n@Component({\n  selector: 'app-user-form'\n})\nexport class UserFormComponent {\n  constructor(\n    private userService: UserService,\n    private router: Router\n  ) {}\n\n  // ✅ Навигация после сохранения\n  saveUser(user: User) {\n    this.userService.saveUser(user).subscribe({\n      next: (savedUser) => {\n        this.router.navigate(['/users', savedUser.id]);\n      },\n      error: (error) => {\n        console.error('Save failed:', error);\n      }\n    });\n  }\n\n  // ✅ Навигация с подтверждением\n  async deleteUser(id: number) {\n    const confirmed = await this.confirmDialog.open();\n    \n    if (confirmed) {\n      this.userService.deleteUser(id).subscribe(() => {\n        this.router.navigate(['/users']);\n      });\n    }\n  }\n}\n```\n\n**8. Условная навигация:**\n\n```typescript\n@Component({\n  selector: 'app-wizard'\n})\nexport class WizardComponent {\n  currentStep = 1;\n\n  nextStep() {\n    if (this.currentStep === 1 && this.validateStep1()) {\n      this.router.navigate(['/wizard/step2']);\n    } else if (this.currentStep === 2 && this.validateStep2()) {\n      this.router.navigate(['/wizard/step3']);\n    } else if (this.currentStep === 3) {\n      this.router.navigate(['/wizard/complete']);\n    }\n  }\n\n  previousStep() {\n    if (this.currentStep > 1) {\n      this.router.navigate([`/wizard/step${this.currentStep - 1}`]);\n    }\n  }\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте navigate() с массивом для параметров\nrouter.navigate(['/users', userId, 'posts', postId])\n\n// ✅ navigateByUrl() для простых абсолютных путей\nrouter.navigateByUrl('/home')\n\n// ✅ Обрабатывайте Promise результат\nrouter.navigate(['/page']).then(success => { /* ... */ })\n\n// ✅ Используйте relativeTo для относительной навигации\nrouter.navigate(['edit'], { relativeTo: route })\n\n// ✅ queryParamsHandling для сохранения query params\nrouter.navigate(['/page'], { queryParamsHandling: 'merge' })\n\n// ✅ replaceUrl для замены истории (back button)\nrouter.navigate(['/page'], { replaceUrl: true })\n\n// ❌ НЕ используйте window.location для навигации\nwindow.location.href = '/page';  // ❌ Перезагружает приложение!\n\n// ❌ НЕ вызывайте navigate() в constructor\nconstructor(private router: Router) {\n  this.router.navigate(['/home']);  // ❌ Может не сработать\n}\n\n// ✅ Вызывайте в ngOnInit или event handlers\nngOnInit() {\n  this.router.navigate(['/home']);  // ✅\n}\n```",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 5,
      "chapter_title": "Forms & Validation",
      "questions": [
        {
          "question_number": 39,
          "question_number_in_chapter": 1,
          "question_chapter": 5,
          "question_title": "В чём разница между Template-Driven и Reactive Forms? Когда что использовать?",
          "answer_markdown": "**Ответ:**\n\n**Angular Forms** предоставляет два подхода к работе с формами: Template-Driven и Reactive.\n\n**Сравнительная таблица:**\n\n| Характеристика | Template-Driven | Reactive |\n|----------------|-----------------|----------|\n| **Где логика** | В template | В component class |\n| **Синхронность** | Асинхронная | Синхронная |\n| **Тестируемость** | Сложнее | Легче |\n| **Валидация** | В template (directives) | В component (Validators) |\n| **Сложность** | Простые формы | Сложные формы |\n| **Модули** | FormsModule | ReactiveFormsModule |\n| **Динамичность** | Ограниченная | Полная |\n\n**1. Template-Driven Forms:**\n\n```typescript\n// app.component.ts\nimport { Component } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-login',\n  standalone: true,\n  imports: [FormsModule],\n  template: `\n    <form #loginForm=\"ngForm\" (ngSubmit)=\"onSubmit(loginForm)\">\n      <!-- ✅ ngModel для two-way binding -->\n      <input \n        type=\"email\" \n        name=\"email\"\n        [(ngModel)]=\"user.email\"\n        required\n        email\n        #emailInput=\"ngModel\">\n      \n      <!-- ✅ Показываем ошибки -->\n      @if (emailInput.invalid && emailInput.touched) {\n        <div class=\"error\">\n          @if (emailInput.errors?.['required']) {\n            Email is required\n          }\n          @if (emailInput.errors?.['email']) {\n            Invalid email format\n          }\n        </div>\n      }\n\n      <input \n        type=\"password\" \n        name=\"password\"\n        [(ngModel)]=\"user.password\"\n        required\n        minlength=\"6\">\n\n      <button \n        type=\"submit\" \n        [disabled]=\"loginForm.invalid\">\n        Login\n      </button>\n    </form>\n\n    <!-- Debug -->\n    <pre>{{ loginForm.value | json }}</pre>\n  `\n})\nexport class LoginComponent {\n  user = {\n    email: '',\n    password: ''\n  };\n\n  onSubmit(form: any) {\n    if (form.valid) {\n      console.log('Form submitted:', this.user);\n    }\n  }\n}\n```\n\n**2. Reactive Forms:**\n\n```typescript\n// app.component.ts\nimport { Component } from '@angular/core';\nimport { \n  FormBuilder, \n  FormGroup, \n  Validators,\n  ReactiveFormsModule \n} from '@angular/forms';\n\n@Component({\n  selector: 'app-login',\n  standalone: true,\n  imports: [ReactiveFormsModule],\n  template: `\n    <form [formGroup]=\"loginForm\" (ngSubmit)=\"onSubmit()\">\n      <!-- ✅ formControlName для привязки -->\n      <input \n        type=\"email\" \n        formControlName=\"email\">\n      \n      <!-- ✅ Показываем ошибки -->\n      @if (email.invalid && email.touched) {\n        <div class=\"error\">\n          @if (email.errors?.['required']) {\n            Email is required\n          }\n          @if (email.errors?.['email']) {\n            Invalid email format\n          }\n        </div>\n      }\n\n      <input \n        type=\"password\" \n        formControlName=\"password\">\n\n      @if (password.invalid && password.touched) {\n        <div class=\"error\">\n          @if (password.errors?.['required']) {\n            Password is required\n          }\n          @if (password.errors?.['minlength']) {\n            Password must be at least 6 characters\n          }\n        </div>\n      }\n\n      <button \n        type=\"submit\" \n        [disabled]=\"loginForm.invalid\">\n        Login\n      </button>\n    </form>\n\n    <!-- Debug -->\n    <pre>{{ loginForm.value | json }}</pre>\n  `\n})\nexport class LoginComponent {\n  loginForm: FormGroup;\n\n  constructor(private fb: FormBuilder) {\n    // ✅ Создаём форму в component class\n    this.loginForm = this.fb.group({\n      email: ['', [Validators.required, Validators.email]],\n      password: ['', [Validators.required, Validators.minlength(6)]]\n    });\n  }\n\n  // ✅ Getters для удобного доступа\n  get email() {\n    return this.loginForm.get('email')!;\n  }\n\n  get password() {\n    return this.loginForm.get('password')!;\n  }\n\n  onSubmit() {\n    if (this.loginForm.valid) {\n      console.log('Form submitted:', this.loginForm.value);\n    }\n  }\n}\n```\n\n**Когда использовать Template-Driven:**\n\n✅ Простые формы (login, регистрация)  \n✅ Быстрое прототипирование  \n✅ Минимум логики валидации  \n✅ Знакомый синтаксис для Angular.js разработчиков  \n\n**Когда использовать Reactive:**\n\n✅ Сложные формы с динамическими полями  \n✅ Cross-field валидация  \n✅ Unit тестирование форм  \n✅ Async валидация  \n✅ Программное управление формой  \n\n**Сравнение кода для сложной формы:**\n\n```typescript\n// ❌ Template-Driven становится громоздким\n<form #userForm=\"ngForm\">\n  <input name=\"firstName\" ngModel required>\n  <input name=\"lastName\" ngModel required>\n  <input name=\"email\" ngModel required email>\n  <div ngModelGroup=\"address\">\n    <input name=\"street\" ngModel required>\n    <input name=\"city\" ngModel required>\n    <input name=\"zipCode\" ngModel required pattern=\"[0-9]{5}\">\n  </div>\n</form>\n\n// ✅ Reactive более читаем и тестируем\nthis.userForm = this.fb.group({\n  firstName: ['', Validators.required],\n  lastName: ['', Validators.required],\n  email: ['', [Validators.required, Validators.email]],\n  address: this.fb.group({\n    street: ['', Validators.required],\n    city: ['', Validators.required],\n    zipCode: ['', [Validators.required, Validators.pattern(/[0-9]{5}/)]]\n  })\n});\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Reactive Forms для production приложений\n// ✅ Template-Driven для простых форм и прототипов\n// ✅ НЕ смешивайте оба подхода в одной форме\n// ❌ НЕ используйте Template-Driven для сложных форм\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 40,
          "question_number_in_chapter": 2,
          "question_chapter": 5,
          "question_title": "Как работают FormControl, FormGroup, FormArray? Validators?",
          "answer_markdown": "**Ответ:**\n\n**Reactive Forms building blocks** — основные классы для построения форм.\n\n**1. FormControl - одно поле:**\n\n```typescript\nimport { FormControl, Validators } from '@angular/forms';\n\n// ✅ Простой FormControl\nconst email = new FormControl('');\n\n// ✅ С начальным значением\nconst name = new FormControl('John');\n\n// ✅ С валидаторами\nconst password = new FormControl('', [\n  Validators.required,\n  Validators.minLength(8)\n]);\n\n// ✅ С опциями (Angular 14+)\nconst username = new FormControl('', {\n  validators: [Validators.required],\n  asyncValidators: [usernameValidator],\n  updateOn: 'blur'  // Обновлять только при blur\n});\n\n// ✅ Typed FormControl (Angular 14+)\nconst age = new FormControl<number | null>(null, Validators.required);\n\n// Использование\nemail.setValue('test@example.com');\nconsole.log(email.value);  // test@example.com\n\nemail.reset();  // Сбрасывает в null\n\n// Статусы\nconsole.log(email.valid);      // boolean\nconsole.log(email.invalid);    // boolean\nconsole.log(email.touched);    // boolean\nconsole.log(email.dirty);      // boolean\nconsole.log(email.errors);     // { required: true } | null\n```\n\n**2. FormGroup - группа полей:**\n\n```typescript\nimport { FormGroup, FormControl } from '@angular/forms';\n\n// ✅ Создание FormGroup\nconst loginForm = new FormGroup({\n  email: new FormControl('', Validators.email),\n  password: new FormControl('', Validators.minLength(6))\n});\n\n// ✅ С FormBuilder (рекомендуется)\nconstructor(private fb: FormBuilder) {\n  this.loginForm = this.fb.group({\n    email: ['', Validators.email],\n    password: ['', Validators.minLength(6)]\n  });\n}\n\n// ✅ Nested FormGroup\nconst userForm = this.fb.group({\n  name: ['', Validators.required],\n  email: ['', [Validators.required, Validators.email]],\n  address: this.fb.group({\n    street: [''],\n    city: [''],\n    zipCode: ['', Validators.pattern(/^\\d{5}$/)]\n  })\n});\n\n// Доступ к значениям\nconsole.log(userForm.value);\n// { name: '', email: '', address: { street: '', city: '', zipCode: '' } }\n\nconsole.log(userForm.get('address')?.value);\n// { street: '', city: '', zipCode: '' }\n\nconsole.log(userForm.get('address.city')?.value);\n// ''\n\n// Установка значений\nuserForm.setValue({\n  name: 'John',\n  email: 'john@example.com',\n  address: {\n    street: '123 Main St',\n    city: 'NY',\n    zipCode: '10001'\n  }\n});\n\n// ✅ patchValue - частичное обновление\nuserForm.patchValue({\n  name: 'Jane',\n  address: { city: 'LA' }  // ✅ Только city, остальное не трогаем\n});\n```\n\n**3. FormArray - динамический массив полей:**\n\n```typescript\nimport { FormArray } from '@angular/forms';\n\n// ✅ Создание FormArray\nconst hobbies = new FormArray([\n  new FormControl('Reading'),\n  new FormControl('Gaming')\n]);\n\n// ✅ С FormBuilder\nconst userForm = this.fb.group({\n  name: [''],\n  hobbies: this.fb.array([\n    this.fb.control('Reading'),\n    this.fb.control('Gaming')\n  ])\n});\n\n// Доступ к FormArray\nget hobbies() {\n  return this.userForm.get('hobbies') as FormArray;\n}\n\n// ✅ Добавление элемента\naddHobby() {\n  this.hobbies.push(this.fb.control(''));\n}\n\n// ✅ Удаление элемента\nremoveHobby(index: number) {\n  this.hobbies.removeAt(index);\n}\n\n// ✅ Очистка\nclearHobbies() {\n  this.hobbies.clear();\n}\n\n// Template\n@Component({\n  template: `\n    <form [formGroup]=\"userForm\">\n      <input formControlName=\"name\">\n      \n      <div formArrayName=\"hobbies\">\n        @for (hobby of hobbies.controls; track $index) {\n          <div>\n            <input [formControlName]=\"$index\">\n            <button (click)=\"removeHobby($index)\">Remove</button>\n          </div>\n        }\n      </div>\n      \n      <button (click)=\"addHobby()\">Add Hobby</button>\n    </form>\n  `\n})\n```\n\n**Практический пример - Dynamic Form:**\n\n```typescript\n@Component({\n  selector: 'app-contacts'\n})\nexport class ContactsComponent {\n  contactForm = this.fb.group({\n    contacts: this.fb.array([])\n  });\n\n  constructor(private fb: FormBuilder) {\n    this.addContact();  // Добавляем первый контакт\n  }\n\n  get contacts() {\n    return this.contactForm.get('contacts') as FormArray;\n  }\n\n  createContact(): FormGroup {\n    return this.fb.group({\n      name: ['', Validators.required],\n      email: ['', [Validators.required, Validators.email]],\n      phone: ['', Validators.pattern(/^\\d{10}$/)]\n    });\n  }\n\n  addContact() {\n    this.contacts.push(this.createContact());\n  }\n\n  removeContact(index: number) {\n    this.contacts.removeAt(index);\n  }\n\n  onSubmit() {\n    if (this.contactForm.valid) {\n      console.log(this.contactForm.value);\n      // { contacts: [ { name: '', email: '', phone: '' }, ... ] }\n    }\n  }\n}\n\n// Template\n@Component({\n  template: `\n    <form [formGroup]=\"contactForm\" (ngSubmit)=\"onSubmit()\">\n      <div formArrayName=\"contacts\">\n        @for (contact of contacts.controls; track $index; let i = $index) {\n          <div [formGroupName]=\"i\">\n            <input formControlName=\"name\" placeholder=\"Name\">\n            <input formControlName=\"email\" placeholder=\"Email\">\n            <input formControlName=\"phone\" placeholder=\"Phone\">\n            <button type=\"button\" (click)=\"removeContact(i)\">Remove</button>\n          </div>\n        }\n      </div>\n      \n      <button type=\"button\" (click)=\"addContact()\">Add Contact</button>\n      <button type=\"submit\" [disabled]=\"contactForm.invalid\">Submit</button>\n    </form>\n  `\n})\n```\n\n**Built-in Validators:**\n\n```typescript\nimport { Validators } from '@angular/forms';\n\n// ✅ Базовые валидаторы\nValidators.required              // Обязательное поле\nValidators.requiredTrue          // Должно быть true (checkbox)\nValidators.email                 // Email формат\nValidators.min(5)                // Минимальное значение\nValidators.max(100)              // Максимальное значение\nValidators.minLength(3)          // Минимальная длина\nValidators.maxLength(20)         // Максимальная длина\nValidators.pattern(/^[a-z]+$/)   // Регулярное выражение\n\n// ✅ Комбинирование валидаторов\nconst control = new FormControl('', [\n  Validators.required,\n  Validators.minLength(8),\n  Validators.maxLength(20)\n]);\n\n// ✅ Compose для объединения\nconst passwordValidators = Validators.compose([\n  Validators.required,\n  Validators.minLength(8)\n]);\n\n// ✅ ComposeAsync для async валидаторов\nconst usernameValidators = Validators.composeAsync([\n  usernameExistsValidator,\n  usernameFormatValidator\n]);\n```\n\n**Проверка ошибок:**\n\n```typescript\n// ✅ В template\n@if (email.errors?.['required'] && email.touched) {\n  <span>Email is required</span>\n}\n\n@if (email.errors?.['email']) {\n  <span>Invalid email format</span>\n}\n\n// ✅ В component\nif (this.email.hasError('required')) {\n  console.log('Email is required');\n}\n\nif (this.email.hasError('email')) {\n  console.log('Invalid email format');\n}\n\n// ✅ Получить параметры ошибки\nconst minLengthError = this.password.getError('minlength');\nconsole.log(`Required length: ${minLengthError.requiredLength}`);\nconsole.log(`Actual length: ${minLengthError.actualLength}`);\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте FormBuilder\nconst form = this.fb.group({ /* ... */ });\n\n// ✅ Создавайте getters для FormControl\nget email() {\n  return this.loginForm.get('email')!;\n}\n\n// ✅ Используйте patchValue для частичного обновления\nform.patchValue({ name: 'John' });\n\n// ✅ Typed Forms (Angular 14+)\nconst form = this.fb.group<{name: string, age: number}>({ /* ... */ });\n\n// ❌ НЕ обращайтесь к controls напрямую в template\n{{ form.controls.email.value }}  // ❌\n\n// ✅ Используйте getters\n{{ email.value }}  // ✅\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 41,
          "question_number_in_chapter": 3,
          "question_chapter": 5,
          "question_title": "Как создавать Custom Validators? Sync и Async валидаторы?",
          "answer_markdown": "**Ответ:**\n\n**Custom Validators** позволяют создавать собственную логику валидации для форм.\n\n**1. Sync Custom Validator (функция):**\n\n```typescript\nimport { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\n\n// ✅ Custom Validator как функция\nexport function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? { forbiddenName: { value: control.value } } : null;\n  };\n}\n\n// Использование\nconst nameControl = new FormControl('', [\n  Validators.required,\n  forbiddenNameValidator(/admin/i)  // ✅ Запрещаем \"admin\"\n]);\n\n// Проверка ошибки\nif (nameControl.hasError('forbiddenName')) {\n  const error = nameControl.getError('forbiddenName');\n  console.log('Forbidden name:', error.value);\n}\n```\n\n**2. Примеры Custom Validators:**\n\n```typescript\n// ✅ Password strength validator\nexport function passwordStrengthValidator(): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const value = control.value;\n\n    if (!value) {\n      return null;  // ✅ Пустое значение - не наша ответственность (используйте Validators.required)\n    }\n\n    const hasUpperCase = /[A-Z]/.test(value);\n    const hasLowerCase = /[a-z]/.test(value);\n    const hasNumber = /[0-9]/.test(value);\n    const hasSpecialChar = /[!@#$%^&*]/.test(value);\n\n    const passwordValid = hasUpperCase && hasLowerCase && hasNumber && hasSpecialChar;\n\n    return !passwordValid ? {\n      passwordStrength: {\n        hasUpperCase,\n        hasLowerCase,\n        hasNumber,\n        hasSpecialChar\n      }\n    } : null;\n  };\n}\n\n// ✅ Age range validator\nexport function ageRangeValidator(min: number, max: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const age = control.value;\n\n    if (age === null || age === undefined || age === '') {\n      return null;\n    }\n\n    if (age < min || age > max) {\n      return {\n        ageRange: {\n          min,\n          max,\n          actual: age\n        }\n      };\n    }\n\n    return null;\n  };\n}\n\n// ✅ URL validator\nexport function urlValidator(): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    if (!control.value) {\n      return null;\n    }\n\n    try {\n      new URL(control.value);\n      return null;\n    } catch {\n      return { invalidUrl: true };\n    }\n  };\n}\n\n// Использование\nthis.userForm = this.fb.group({\n  password: ['', [\n    Validators.required,\n    Validators.minLength(8),\n    passwordStrengthValidator()\n  ]],\n  age: ['', [\n    Validators.required,\n    ageRangeValidator(18, 100)\n  ]],\n  website: ['', urlValidator()]\n});\n```\n\n**3. Cross-field Validator (валидация нескольких полей):**\n\n```typescript\n// ✅ Password match validator\nexport const passwordMatchValidator: ValidatorFn = (\n  control: AbstractControl\n): ValidationErrors | null => {\n  const password = control.get('password');\n  const confirmPassword = control.get('confirmPassword');\n\n  if (!password || !confirmPassword) {\n    return null;\n  }\n\n  return password.value === confirmPassword.value ? null : { passwordMismatch: true };\n};\n\n// Использование\nthis.signupForm = this.fb.group({\n  password: ['', [Validators.required, Validators.minLength(8)]],\n  confirmPassword: ['', Validators.required]\n}, { validators: passwordMatchValidator });  // ✅ Validator на уровне FormGroup\n\n// Template\n@if (signupForm.errors?.['passwordMismatch'] && signupForm.touched) {\n  <div class=\"error\">Passwords do not match</div>\n}\n\n// ✅ Date range validator\nexport const dateRangeValidator: ValidatorFn = (\n  control: AbstractControl\n): ValidationErrors | null => {\n  const startDate = control.get('startDate')?.value;\n  const endDate = control.get('endDate')?.value;\n\n  if (!startDate || !endDate) {\n    return null;\n  }\n\n  return new Date(startDate) < new Date(endDate) ? null : { invalidDateRange: true };\n};\n```\n\n**4. Async Validator (проверка на сервере):**\n\n```typescript\nimport { AsyncValidatorFn } from '@angular/forms';\nimport { map, catchError } from 'rxjs/operators';\nimport { of } from 'rxjs';\n\n// ✅ Username availability validator\nexport function usernameAvailableValidator(\n  userService: UserService\n): AsyncValidatorFn {\n  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n    if (!control.value) {\n      return of(null);\n    }\n\n    return userService.checkUsernameAvailability(control.value).pipe(\n      map(isAvailable => isAvailable ? null : { usernameTaken: true }),\n      catchError(() => of(null))  // ✅ При ошибке сети - не блокируем форму\n    );\n  };\n}\n\n// Использование\nconstructor(\n  private fb: FormBuilder,\n  private userService: UserService\n) {\n  this.signupForm = this.fb.group({\n    username: [\n      '',\n      [Validators.required, Validators.minLength(3)],\n      [usernameAvailableValidator(this.userService)]  // ✅ Async validator\n    ]\n  });\n}\n\n// Template (с loading indicator)\n<input formControlName=\"username\">\n\n@if (username.pending) {\n  <span class=\"spinner\">Checking...</span>\n}\n\n@if (username.errors?.['usernameTaken'] && username.touched) {\n  <span class=\"error\">Username is already taken</span>\n}\n```\n\n**5. Async Validator с debounce:**\n\n```typescript\nexport function emailExistsValidator(\n  userService: UserService\n): AsyncValidatorFn {\n  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n    if (!control.value) {\n      return of(null);\n    }\n\n    // ✅ Debounce для уменьшения запросов\n    return timer(500).pipe(  // Ждём 500ms\n      switchMap(() =>\n        userService.checkEmailExists(control.value).pipe(\n          map(exists => exists ? { emailExists: true } : null),\n          catchError(() => of(null))\n        )\n      )\n    );\n  };\n}\n```\n\n**6. Validator как Directive (для Template-Driven Forms):**\n\n```typescript\nimport { Directive } from '@angular/core';\nimport { NG_VALIDATORS, Validator, AbstractControl, ValidationErrors } from '@angular/forms';\n\n@Directive({\n  selector: '[appForbiddenName][ngModel]',\n  providers: [\n    {\n      provide: NG_VALIDATORS,\n      useExisting: ForbiddenNameDirective,\n      multi: true\n    }\n  ]\n})\nexport class ForbiddenNameDirective implements Validator {\n  validate(control: AbstractControl): ValidationErrors | null {\n    const forbidden = /admin/i.test(control.value);\n    return forbidden ? { forbiddenName: true } : null;\n  }\n}\n\n// Template\n<input \n  name=\"username\" \n  ngModel \n  appForbiddenName\n  #username=\"ngModel\">\n\n@if (username.errors?.['forbiddenName']) {\n  <span>Admin name is forbidden</span>\n}\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Возвращайте null если нет ошибки\nreturn null;  // ✅\nreturn undefined;  // ❌\n\n// ✅ Возвращайте объект с информацией об ошибке\nreturn { \n  passwordStrength: {\n    hasUpperCase: false,\n    hasLowerCase: true,\n    hasNumber: true\n  }\n};\n\n// ✅ Проверяйте пустые значения\nif (!control.value) {\n  return null;  // Используйте Validators.required для обязательных полей\n}\n\n// ✅ Обрабатывайте ошибки в async validators\n.pipe(\n  catchError(() => of(null))  // Не блокируем форму при ошибке сети\n)\n\n// ✅ Используйте debounce для async validators\ntimer(500).pipe(switchMap(() => ...))\n\n// ✅ Cross-field validators на уровне FormGroup\nthis.fb.group({ /* ... */ }, { validators: passwordMatchValidator })\n\n// ❌ НЕ делайте тяжёлые операции в sync validators\n// ❌ НЕ забывайте про catchError в async validators\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 42,
          "question_number_in_chapter": 4,
          "question_chapter": 5,
          "question_title": "Как работать с FormBuilder? Typed Forms (Angular 14+)?",
          "answer_markdown": "**Ответ:**\n\n**FormBuilder** — сервис для упрощения создания форм. **Typed Forms** (Angular 14+) добавляют type-safety.\n\n**1. FormBuilder basics:**\n\n```typescript\nimport { FormBuilder, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-user-form'\n})\nexport class UserFormComponent {\n  // ✅ Inject FormBuilder\n  constructor(private fb: FormBuilder) {}\n\n  // ❌ Без FormBuilder - громоздко\n  userFormOld = new FormGroup({\n    name: new FormControl('', Validators.required),\n    email: new FormControl('', [Validators.required, Validators.email]),\n    age: new FormControl(null, [Validators.required, Validators.min(18)])\n  });\n\n  // ✅ С FormBuilder - компактно\n  userForm = this.fb.group({\n    name: ['', Validators.required],\n    email: ['', [Validators.required, Validators.email]],\n    age: [null as number | null, [Validators.required, Validators.min(18)]]\n  });\n\n  // ✅ С явным типом начального значения\n  userForm2 = this.fb.group({\n    name: this.fb.control('', { nonNullable: true }),  // string, не может быть null\n    email: this.fb.control<string | null>(null),       // string | null\n    age: this.fb.control<number | null>(null)          // number | null\n  });\n}\n```\n\n**2. Typed Forms (Angular 14+):**\n\n```typescript\nimport { FormBuilder, FormControl, FormGroup } from '@angular/forms';\n\ninterface UserForm {\n  name: string;\n  email: string;\n  age: number | null;\n  address: {\n    street: string;\n    city: string;\n  };\n}\n\n@Component({\n  selector: 'app-typed-form'\n})\nexport class TypedFormComponent {\n  // ✅ Typed FormGroup\n  userForm = this.fb.group<UserForm>({\n    name: this.fb.control('', { nonNullable: true }),\n    email: this.fb.control('', { nonNullable: true }),\n    age: this.fb.control<number | null>(null),\n    address: this.fb.group({\n      street: this.fb.control('', { nonNullable: true }),\n      city: this.fb.control('', { nonNullable: true })\n    })\n  });\n\n  constructor(private fb: FormBuilder) {}\n\n  onSubmit() {\n    if (this.userForm.valid) {\n      const userData = this.userForm.value;\n      // ✅ TypeScript знает структуру userData\n      console.log(userData.name);      // ✅ Type-safe\n      console.log(userData.address.city);  // ✅ Type-safe\n    }\n  }\n\n  // ✅ getRawValue() для получения значений disabled полей\n  getAllValues() {\n    const allData = this.userForm.getRawValue();\n    // Включает disabled поля\n  }\n}\n```\n\n**3. FormBuilder с nonNullable:**\n\n```typescript\n// ✅ NonNullableFormBuilder (Angular 14+)\nimport { NonNullableFormBuilder } from '@angular/forms';\n\n@Component({\n  selector: 'app-non-nullable-form'\n})\nexport class NonNullableFormComponent {\n  // ✅ Все controls non-nullable по умолчанию\n  constructor(private fb: NonNullableFormBuilder) {}\n\n  userForm = this.fb.group({\n    name: [''],        // string, не может быть null\n    email: [''],       // string, не может быть null\n    age: [0]           // number, не может быть null\n  });\n\n  // При reset() вернётся к начальным значениям, а не null\n  resetForm() {\n    this.userForm.reset();\n    // name: '', email: '', age: 0 (не null!)\n  }\n}\n```\n\n**4. Nested FormGroups:**\n\n```typescript\ninterface RegistrationForm {\n  personalInfo: {\n    firstName: string;\n    lastName: string;\n    dateOfBirth: string;\n  };\n  contactInfo: {\n    email: string;\n    phone: string;\n    address: {\n      street: string;\n      city: string;\n      zipCode: string;\n    };\n  };\n  preferences: {\n    newsletter: boolean;\n    notifications: boolean;\n  };\n}\n\n@Component({\n  selector: 'app-registration'\n})\nexport class RegistrationComponent {\n  registrationForm = this.fb.group<RegistrationForm>({\n    personalInfo: this.fb.group({\n      firstName: this.fb.control('', { nonNullable: true }),\n      lastName: this.fb.control('', { nonNullable: true }),\n      dateOfBirth: this.fb.control('', { nonNullable: true })\n    }),\n    contactInfo: this.fb.group({\n      email: this.fb.control('', { nonNullable: true }),\n      phone: this.fb.control('', { nonNullable: true }),\n      address: this.fb.group({\n        street: this.fb.control('', { nonNullable: true }),\n        city: this.fb.control('', { nonNullable: true }),\n        zipCode: this.fb.control('', { nonNullable: true })\n      })\n    }),\n    preferences: this.fb.group({\n      newsletter: this.fb.control(false, { nonNullable: true }),\n      notifications: this.fb.control(true, { nonNullable: true })\n    })\n  });\n\n  constructor(private fb: FormBuilder) {}\n\n  // ✅ Type-safe доступ\n  get email() {\n    return this.registrationForm.get('contactInfo.email')!;\n  }\n\n  get address() {\n    return this.registrationForm.get('contactInfo.address') as FormGroup;\n  }\n}\n\n// Template\n<form [formGroup]=\"registrationForm\">\n  <div formGroupName=\"personalInfo\">\n    <input formControlName=\"firstName\">\n    <input formControlName=\"lastName\">\n  </div>\n\n  <div formGroupName=\"contactInfo\">\n    <input formControlName=\"email\">\n    \n    <div formGroupName=\"address\">\n      <input formControlName=\"street\">\n      <input formControlName=\"city\">\n      <input formControlName=\"zipCode\">\n    </div>\n  </div>\n\n  <div formGroupName=\"preferences\">\n    <input type=\"checkbox\" formControlName=\"newsletter\">\n    <input type=\"checkbox\" formControlName=\"notifications\">\n  </div>\n</form>\n```\n\n**5. FormBuilder с FormArray:**\n\n```typescript\ninterface DynamicForm {\n  items: Array<{\n    name: string;\n    quantity: number;\n    price: number;\n  }>;\n  total: number;\n}\n\n@Component({\n  selector: 'app-dynamic-form'\n})\nexport class DynamicFormComponent {\n  orderForm = this.fb.group({\n    items: this.fb.array<FormGroup>([]),\n    total: this.fb.control(0, { nonNullable: true })\n  });\n\n  constructor(private fb: NonNullableFormBuilder) {\n    this.addItem();  // Добавляем первый item\n  }\n\n  get items() {\n    return this.orderForm.get('items') as FormArray;\n  }\n\n  createItem() {\n    return this.fb.group({\n      name: ['', Validators.required],\n      quantity: [1, [Validators.required, Validators.min(1)]],\n      price: [0, [Validators.required, Validators.min(0)]]\n    });\n  }\n\n  addItem() {\n    this.items.push(this.createItem());\n  }\n\n  removeItem(index: number) {\n    this.items.removeAt(index);\n    this.updateTotal();\n  }\n\n  updateTotal() {\n    const total = this.items.controls.reduce((sum, item) => {\n      const quantity = item.get('quantity')?.value || 0;\n      const price = item.get('price')?.value || 0;\n      return sum + (quantity * price);\n    }, 0);\n\n    this.orderForm.patchValue({ total });\n  }\n}\n```\n\n**6. FormBuilder с UpdateOn:**\n\n```typescript\n// ✅ updateOn опция\nthis.loginForm = this.fb.group({\n  email: ['', {\n    validators: [Validators.required, Validators.email],\n    updateOn: 'blur'  // ✅ Обновлять только при blur\n  }],\n  password: ['', {\n    validators: [Validators.required],\n    updateOn: 'submit'  // ✅ Обновлять только при submit\n  }]\n});\n\n// Или на уровне FormGroup\nthis.loginForm = this.fb.group({\n  email: ['', Validators.email],\n  password: ['', Validators.required]\n}, { updateOn: 'blur' });  // ✅ Для всех controls\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте NonNullableFormBuilder\nconstructor(private fb: NonNullableFormBuilder) {}\n\n// ✅ Типизируйте формы (Angular 14+)\nuserForm = this.fb.group<UserForm>({ /* ... */ });\n\n// ✅ Создавайте getters для доступа к controls\nget email() {\n  return this.form.get('email')!;\n}\n\n// ✅ Используйте пустые массивы для FormArray\nitems: this.fb.array([])\n\n// ✅ updateOn: 'blur' для улучшения UX\n{ updateOn: 'blur' }\n\n// ❌ НЕ используйте any для типов\nform: any  // ❌\n\n// ✅ Используйте typed forms\nform: FormGroup<UserForm>  // ✅\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 43,
          "question_number_in_chapter": 5,
          "question_chapter": 5,
          "question_title": "Как делать Dynamic Forms? Добавление/удаление полей в runtime?",
          "answer_markdown": "**Ответ:**\n\n**Dynamic Forms** позволяют создавать формы с изменяемой структурой во время выполнения.\n\n**1. Базовый Dynamic Form с FormArray:**\n\n```typescript\n@Component({\n  selector: 'app-dynamic-form',\n  template: `\n    <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">\n      <div formArrayName=\"skills\">\n        @for (skill of skills.controls; track $index; let i = $index) {\n          <div [formGroupName]=\"i\">\n            <input formControlName=\"name\" placeholder=\"Skill name\">\n            <input formControlName=\"level\" type=\"number\" placeholder=\"Level (1-10)\">\n            <button type=\"button\" (click)=\"removeSkill(i)\">Remove</button>\n          </div>\n        }\n      </div>\n\n      <button type=\"button\" (click)=\"addSkill()\">Add Skill</button>\n      <button type=\"submit\" [disabled]=\"form.invalid\">Submit</button>\n\n      <pre>{{ form.value | json }}</pre>\n    </form>\n  `\n})\nexport class DynamicFormComponent {\n  form = this.fb.group({\n    skills: this.fb.array<FormGroup>([])\n  });\n\n  constructor(private fb: NonNullableFormBuilder) {\n    this.addSkill();  // Добавляем первое поле\n  }\n\n  get skills() {\n    return this.form.get('skills') as FormArray;\n  }\n\n  createSkill(): FormGroup {\n    return this.fb.group({\n      name: ['', Validators.required],\n      level: [1, [Validators.required, Validators.min(1), Validators.max(10)]]\n    });\n  }\n\n  addSkill() {\n    this.skills.push(this.createSkill());\n  }\n\n  removeSkill(index: number) {\n    this.skills.removeAt(index);\n  }\n\n  onSubmit() {\n    if (this.form.valid) {\n      console.log('Skills:', this.form.value.skills);\n    }\n  }\n}\n```\n\n**2. Dynamic Form на основе конфигурации:**\n\n```typescript\ninterface FormField {\n  type: 'text' | 'number' | 'email' | 'checkbox' | 'select';\n  name: string;\n  label: string;\n  value?: any;\n  validators?: any[];\n  options?: string[];  // Для select\n}\n\n@Component({\n  selector: 'app-config-form',\n  template: `\n    <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">\n      @for (field of fields; track field.name) {\n        <div>\n          <label>{{ field.label }}</label>\n\n          @switch (field.type) {\n            @case ('text') {\n              <input type=\"text\" [formControlName]=\"field.name\">\n            }\n            @case ('email') {\n              <input type=\"email\" [formControlName]=\"field.name\">\n            }\n            @case ('number') {\n              <input type=\"number\" [formControlName]=\"field.name\">\n            }\n            @case ('checkbox') {\n              <input type=\"checkbox\" [formControlName]=\"field.name\">\n            }\n            @case ('select') {\n              <select [formControlName]=\"field.name\">\n                @for (option of field.options; track option) {\n                  <option [value]=\"option\">{{ option }}</option>\n                }\n              </select>\n            }\n          }\n\n          @if (form.get(field.name)?.errors && form.get(field.name)?.touched) {\n            <div class=\"error\">Field is invalid</div>\n          }\n        </div>\n      }\n\n      <button type=\"submit\" [disabled]=\"form.invalid\">Submit</button>\n    </form>\n  `\n})\nexport class ConfigFormComponent implements OnInit {\n  form!: FormGroup;\n  fields: FormField[] = [];\n\n  constructor(private fb: FormBuilder) {}\n\n  ngOnInit() {\n    // ✅ Загружаем конфигурацию формы\n    this.fields = this.getFormConfig();\n    this.form = this.createFormFromConfig(this.fields);\n  }\n\n  getFormConfig(): FormField[] {\n    return [\n      {\n        type: 'text',\n        name: 'firstName',\n        label: 'First Name',\n        value: '',\n        validators: [Validators.required]\n      },\n      {\n        type: 'email',\n        name: 'email',\n        label: 'Email',\n        value: '',\n        validators: [Validators.required, Validators.email]\n      },\n      {\n        type: 'number',\n        name: 'age',\n        label: 'Age',\n        value: null,\n        validators: [Validators.min(18)]\n      },\n      {\n        type: 'select',\n        name: 'country',\n        label: 'Country',\n        value: 'USA',\n        options: ['USA', 'UK', 'Canada'],\n        validators: [Validators.required]\n      },\n      {\n        type: 'checkbox',\n        name: 'agree',\n        label: 'I agree to terms',\n        value: false,\n        validators: [Validators.requiredTrue]\n      }\n    ];\n  }\n\n  createFormFromConfig(fields: FormField[]): FormGroup {\n    const group: any = {};\n\n    fields.forEach(field => {\n      group[field.name] = [field.value || '', field.validators || []];\n    });\n\n    return this.fb.group(group);\n  }\n\n  onSubmit() {\n    if (this.form.valid) {\n      console.log('Form submitted:', this.form.value);\n    }\n  }\n}\n```\n\n**3. Условные поля (показывать/скрывать):**\n\n```typescript\n@Component({\n  selector: 'app-conditional-form',\n  template: `\n    <form [formGroup]=\"form\">\n      <select formControlName=\"userType\">\n        <option value=\"\">Select type</option>\n        <option value=\"individual\">Individual</option>\n        <option value=\"company\">Company</option>\n      </select>\n\n      @if (userType.value === 'individual') {\n        <div>\n          <input formControlName=\"firstName\" placeholder=\"First Name\">\n          <input formControlName=\"lastName\" placeholder=\"Last Name\">\n        </div>\n      }\n\n      @if (userType.value === 'company') {\n        <div>\n          <input formControlName=\"companyName\" placeholder=\"Company Name\">\n          <input formControlName=\"taxId\" placeholder=\"Tax ID\">\n        </div>\n      }\n    </form>\n  `\n})\nexport class ConditionalFormComponent {\n  form = this.fb.group({\n    userType: [''],\n    // Individual fields\n    firstName: [''],\n    lastName: [''],\n    // Company fields\n    companyName: [''],\n    taxId: ['']\n  });\n\n  constructor(private fb: FormBuilder) {\n    // ✅ Динамическая валидация при изменении типа\n    this.userType.valueChanges.subscribe(type => {\n      if (type === 'individual') {\n        this.firstName.setValidators(Validators.required);\n        this.lastName.setValidators(Validators.required);\n        this.companyName.clearValidators();\n        this.taxId.clearValidators();\n      } else if (type === 'company') {\n        this.firstName.clearValidators();\n        this.lastName.clearValidators();\n        this.companyName.setValidators(Validators.required);\n        this.taxId.setValidators(Validators.required);\n      }\n\n      // ✅ Обновляем validity\n      this.firstName.updateValueAndValidity();\n      this.lastName.updateValueAndValidity();\n      this.companyName.updateValueAndValidity();\n      this.taxId.updateValueAndValidity();\n    });\n  }\n\n  get userType() {\n    return this.form.get('userType')!;\n  }\n\n  get firstName() {\n    return this.form.get('firstName')!;\n  }\n\n  get lastName() {\n    return this.form.get('lastName')!;\n  }\n\n  get companyName() {\n    return this.form.get('companyName')!;\n  }\n\n  get taxId() {\n    return this.form.get('taxId')!;\n  }\n}\n```\n\n**4. Добавление/удаление вложенных FormGroups:**\n\n```typescript\ninterface ContactForm {\n  name: string;\n  phones: Array<{\n    type: string;\n    number: string;\n  }>;\n  emails: Array<{\n    type: string;\n    address: string;\n  }>;\n}\n\n@Component({\n  selector: 'app-contact-form'\n})\nexport class ContactFormComponent {\n  form = this.fb.group({\n    name: ['', Validators.required],\n    phones: this.fb.array<FormGroup>([]),\n    emails: this.fb.array<FormGroup>([])\n  });\n\n  constructor(private fb: FormBuilder) {\n    this.addPhone();\n    this.addEmail();\n  }\n\n  get phones() {\n    return this.form.get('phones') as FormArray;\n  }\n\n  get emails() {\n    return this.form.get('emails') as FormArray;\n  }\n\n  createPhone(): FormGroup {\n    return this.fb.group({\n      type: ['mobile', Validators.required],\n      number: ['', [Validators.required, Validators.pattern(/^\\d{10}$/)]]\n    });\n  }\n\n  createEmail(): FormGroup {\n    return this.fb.group({\n      type: ['personal', Validators.required],\n      address: ['', [Validators.required, Validators.email]]\n    });\n  }\n\n  addPhone() {\n    this.phones.push(this.createPhone());\n  }\n\n  removePhone(index: number) {\n    this.phones.removeAt(index);\n  }\n\n  addEmail() {\n    this.emails.push(this.createEmail());\n  }\n\n  removeEmail(index: number) {\n    this.emails.removeAt(index);\n  }\n}\n\n// Template\n<form [formGroup]=\"form\">\n  <input formControlName=\"name\">\n\n  <div formArrayName=\"phones\">\n    <h3>Phone Numbers</h3>\n    @for (phone of phones.controls; track $index; let i = $index) {\n      <div [formGroupName]=\"i\">\n        <select formControlName=\"type\">\n          <option value=\"mobile\">Mobile</option>\n          <option value=\"home\">Home</option>\n          <option value=\"work\">Work</option>\n        </select>\n        <input formControlName=\"number\" placeholder=\"Phone\">\n        <button type=\"button\" (click)=\"removePhone(i)\">Remove</button>\n      </div>\n    }\n    <button type=\"button\" (click)=\"addPhone()\">Add Phone</button>\n  </div>\n\n  <div formArrayName=\"emails\">\n    <h3>Email Addresses</h3>\n    @for (email of emails.controls; track $index; let i = $index) {\n      <div [formGroupName]=\"i\">\n        <select formControlName=\"type\">\n          <option value=\"personal\">Personal</option>\n          <option value=\"work\">Work</option>\n        </select>\n        <input formControlName=\"address\" placeholder=\"Email\">\n        <button type=\"button\" (click)=\"removeEmail(i)\">Remove</button>\n      </div>\n    }\n    <button type=\"button\" (click)=\"addEmail()\">Add Email</button>\n  </div>\n</form>\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте FormArray для динамических списков\nitems: this.fb.array([])\n\n// ✅ Создавайте factory методы для FormGroups\ncreateItem(): FormGroup { /* ... */ }\n\n// ✅ Динамически обновляйте validators\ncontrol.setValidators([Validators.required]);\ncontrol.updateValueAndValidity();\n\n// ✅ Очищайте validators когда поле скрыто\ncontrol.clearValidators();\ncontrol.updateValueAndValidity();\n\n// ✅ Используйте trackBy для производительности\n@for (item of items.controls; track $index) { }\n\n// ❌ НЕ забывайте updateValueAndValidity после изменения validators\ncontrol.setValidators([...]);\n// control.updateValueAndValidity();  // ❌ Забыли!\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 44,
          "question_number_in_chapter": 6,
          "question_chapter": 5,
          "question_title": "Reactive Forms с Signals (Angular 16+)? Signal-based валидация?",
          "answer_markdown": "**Ответ:**\n\n**Reactive Forms + Signals** позволяют создавать более реактивные и производительные формы.\n\n**1. toSignal с FormControl:**\n\n```typescript\nimport { toSignal } from '@angular/core/rxjs-interop';\n\n@Component({\n  selector: 'app-search',\n  template: `\n    <input [formControl]=\"searchControl\" placeholder=\"Search...\">\n\n    @if (searchQuery(); as query) {\n      <p>Searching for: {{ query }}</p>\n    }\n\n    @if (isSearching()) {\n      <p>Loading...</p>\n    }\n\n    @if (results(); as results) {\n      <div *ngFor=\"let result of results\">{{ result.name }}</div>\n    }\n  `\n})\nexport class SearchComponent {\n  searchControl = new FormControl('');\n\n  // ✅ Преобразуем valueChanges в Signal\n  searchQuery = toSignal(\n    this.searchControl.valueChanges.pipe(startWith('')),\n    { initialValue: '' }\n  );\n\n  // ✅ Observable → Signal для результатов поиска\n  results = toSignal(\n    this.searchControl.valueChanges.pipe(\n      debounceTime(300),\n      distinctUntilChanged(),\n      switchMap(query => this.searchService.search(query)),\n      startWith([])\n    ),\n    { initialValue: [] }\n  );\n\n  // ✅ Computed для loading state\n  isSearching = computed(() => {\n    const query = this.searchQuery();\n    return query.length > 0 && this.results().length === 0;\n  });\n\n  constructor(private searchService: SearchService) {}\n}\n```\n\n**2. FormControl с Signal inputs:**\n\n```typescript\n@Component({\n  selector: 'app-user-form',\n  template: `\n    <form [formGroup]=\"form\">\n      <input formControlName=\"firstName\">\n      <input formControlName=\"lastName\">\n    </form>\n\n    <!-- ✅ Computed полное имя -->\n    <p>Full name: {{ fullName() }}</p>\n\n    <!-- ✅ Computed валидация -->\n    @if (isFormValid()) {\n      <button (click)=\"submit()\">Submit</button>\n    } @else {\n      <p class=\"error\">Form is invalid</p>\n    }\n  `\n})\nexport class UserFormComponent {\n  form = this.fb.group({\n    firstName: ['', Validators.required],\n    lastName: ['', Validators.required]\n  });\n\n  // ✅ Signals для значений полей\n  firstName = toSignal(\n    this.form.get('firstName')!.valueChanges.pipe(startWith('')),\n    { initialValue: '' }\n  );\n\n  lastName = toSignal(\n    this.form.get('lastName')!.valueChanges.pipe(startWith('')),\n    { initialValue: '' }\n  );\n\n  // ✅ Computed для полного имени\n  fullName = computed(() => {\n    const first = this.firstName();\n    const last = this.lastName();\n    return `${first} ${last}`.trim();\n  });\n\n  // ✅ Signal для валидности формы\n  isFormValid = toSignal(\n    this.form.statusChanges.pipe(\n      map(status => status === 'VALID'),\n      startWith(this.form.valid)\n    ),\n    { initialValue: false }\n  );\n\n  constructor(private fb: FormBuilder) {}\n\n  submit() {\n    console.log('Submitting:', this.form.value);\n  }\n}\n```\n\n**3. Signal-based Custom Validator:**\n\n```typescript\n// ✅ Validator с Signal зависимостью\nexport function signalDependentValidator(\n  minSignal: Signal<number>\n): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const value = control.value;\n    const min = minSignal();\n\n    if (value === null || value === undefined || value === '') {\n      return null;\n    }\n\n    return value >= min ? null : { min: { min, actual: value } };\n  };\n}\n\n// Использование\n@Component({\n  selector: 'app-dynamic-validation'\n})\nexport class DynamicValidationComponent {\n  minAge = signal(18);  // ✅ Signal для динамического минимума\n\n  form = this.fb.group({\n    age: [null as number | null]\n  });\n\n  constructor(private fb: FormBuilder) {\n    // ✅ Обновляем validators при изменении Signal\n    effect(() => {\n      const min = this.minAge();\n      this.ageControl.setValidators([\n        Validators.required,\n        Validators.min(min)\n      ]);\n      this.ageControl.updateValueAndValidity();\n    });\n  }\n\n  get ageControl() {\n    return this.form.get('age')!;\n  }\n\n  // UI для изменения минимума\n  increaseMinAge() {\n    this.minAge.update(v => v + 1);\n  }\n\n  decreaseMinAge() {\n    this.minAge.update(v => Math.max(1, v - 1));\n  }\n}\n```\n\n**4. Reactive Form State Management с Signals:**\n\n```typescript\ninterface FormState {\n  loading: boolean;\n  submitted: boolean;\n  errors: string[];\n}\n\n@Component({\n  selector: 'app-form-state'\n})\nexport class FormStateComponent {\n  form = this.fb.group({\n    email: ['', [Validators.required, Validators.email]],\n    password: ['', [Validators.required, Validators.minLength(8)]]\n  });\n\n  // ✅ Signal state\n  private formStateSignal = signal<FormState>({\n    loading: false,\n    submitted: false,\n    errors: []\n  });\n\n  formState = this.formStateSignal.asReadonly();\n\n  // ✅ Computed для UI\n  isSubmitDisabled = computed(() => \n    this.form.invalid || this.formState().loading\n  );\n\n  showErrors = computed(() => \n    this.formState().submitted && this.form.invalid\n  );\n\n  constructor(private fb: FormBuilder) {}\n\n  async submit() {\n    // ✅ Обновляем state\n    this.formStateSignal.update(state => ({\n      ...state,\n      loading: true,\n      submitted: true\n    }));\n\n    try {\n      await this.authService.login(this.form.value);\n      \n      this.formStateSignal.update(state => ({\n        ...state,\n        loading: false,\n        errors: []\n      }));\n    } catch (error) {\n      this.formStateSignal.update(state => ({\n        ...state,\n        loading: false,\n        errors: ['Login failed']\n      }));\n    }\n  }\n}\n\n// Template\n<form [formGroup]=\"form\" (ngSubmit)=\"submit()\">\n  <input formControlName=\"email\">\n  <input formControlName=\"password\" type=\"password\">\n\n  @if (showErrors()) {\n    <div class=\"errors\">\n      @for (error of formState().errors; track error) {\n        <p>{{ error }}</p>\n      }\n    </div>\n  }\n\n  <button \n    type=\"submit\" \n    [disabled]=\"isSubmitDisabled()\">\n    @if (formState().loading) {\n      Loading...\n    } @else {\n      Login\n    }\n  </button>\n</form>\n```\n\n**5. Signal-based Field Dependencies:**\n\n```typescript\n@Component({\n  selector: 'app-dependent-fields'\n})\nexport class DependentFieldsComponent {\n  form = this.fb.group({\n    hasPromoCode: [false],\n    promoCode: ['']\n  });\n\n  // ✅ Signal для checkbox состояния\n  hasPromoCode = toSignal(\n    this.form.get('hasPromoCode')!.valueChanges.pipe(startWith(false)),\n    { initialValue: false }\n  );\n\n  constructor(private fb: FormBuilder) {\n    // ✅ Effect для динамической валидации\n    effect(() => {\n      const enabled = this.hasPromoCode();\n      const promoCodeControl = this.form.get('promoCode')!;\n\n      if (enabled) {\n        promoCodeControl.setValidators([\n          Validators.required,\n          Validators.minLength(6)\n        ]);\n        promoCodeControl.enable();\n      } else {\n        promoCodeControl.clearValidators();\n        promoCodeControl.disable();\n      }\n\n      promoCodeControl.updateValueAndValidity();\n    });\n  }\n}\n\n// Template\n<form [formGroup]=\"form\">\n  <label>\n    <input type=\"checkbox\" formControlName=\"hasPromoCode\">\n    I have a promo code\n  </label>\n\n  @if (hasPromoCode()) {\n    <input formControlName=\"promoCode\" placeholder=\"Enter promo code\">\n  }\n</form>\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Используйте toSignal для valueChanges\ntoSignal(control.valueChanges.pipe(startWith('')))\n\n// ✅ Используйте computed для производных данных\ncomputed(() => this.firstName() + ' ' + this.lastName())\n\n// ✅ effect() для side-effects (валидация, API calls)\neffect(() => {\n  const value = this.signal();\n  this.updateValidators(value);\n});\n\n// ✅ Signal state для UI состояния\nformState = signal({ loading: false, errors: [] });\n\n// ❌ НЕ используйте Signal для самих FormControl\n// FormControl уже реактивный через valueChanges\n\n// ✅ Комбинируйте Signals с Reactive Forms для лучшего DX\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 45,
          "question_number_in_chapter": 7,
          "question_chapter": 5,
          "question_title": "Form Best Practices? Accessibility, UX, Performance?",
          "answer_markdown": "**Ответ:**\n\n**Best Practices** для создания качественных форм в Angular.\n\n**1. Accessibility (A11y):**\n\n```typescript\n// ✅ Правильная разметка для accessibility\n<form [formGroup]=\"form\">\n  <!-- ✅ Label связан с input через for/id -->\n  <label for=\"email\">Email</label>\n  <input \n    id=\"email\" \n    type=\"email\" \n    formControlName=\"email\"\n    aria-describedby=\"email-error\"\n    [attr.aria-invalid]=\"email.invalid && email.touched\">\n  \n  <!-- ✅ Error с aria-live -->\n  <div \n    id=\"email-error\" \n    role=\"alert\" \n    aria-live=\"polite\"\n    @if (email.invalid && email.touched) {\n      <span>{{ getEmailError() }}</span>\n    }\n  </div>\n\n  <!-- ✅ Required indicator -->\n  <label for=\"password\">\n    Password <span aria-label=\"required\">*</span>\n  </label>\n  <input \n    id=\"password\" \n    type=\"password\" \n    formControlName=\"password\"\n    aria-required=\"true\">\n\n  <!-- ✅ Button с описательным текстом -->\n  <button \n    type=\"submit\" \n    [disabled]=\"form.invalid\"\n    [attr.aria-disabled]=\"form.invalid\">\n    Submit\n  </button>\n</form>\n\n// ✅ Fieldset для группировки\n<fieldset [formGroup]=\"form\">\n  <legend>Personal Information</legend>\n  <!-- fields -->\n</fieldset>\n```\n\n**2. UX Best Practices:**\n\n```typescript\n@Component({\n  selector: 'app-ux-form',\n  template: `\n    <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">\n      <!-- ✅ Показываем ошибки только после touch -->\n      <div>\n        <input formControlName=\"email\">\n        @if (email.invalid && (email.dirty || email.touched)) {\n          <span class=\"error\">{{ getEmailError() }}</span>\n        }\n      </div>\n\n      <!-- ✅ Inline валидация с debounce -->\n      <div>\n        <input formControlName=\"username\">\n        @if (username.pending) {\n          <span class=\"checking\">Checking availability...</span>\n        }\n        @if (username.hasError('usernameTaken') && username.touched) {\n          <span class=\"error\">Username is taken</span>\n        }\n        @if (username.valid && username.dirty) {\n          <span class=\"success\">✓ Available</span>\n        }\n      </div>\n\n      <!-- ✅ Password strength indicator -->\n      <div>\n        <input type=\"password\" formControlName=\"password\">\n        <div class=\"strength-meter\">\n          <div \n            class=\"strength-bar\" \n            [style.width.%]=\"passwordStrength() * 100\"\n            [class.weak]=\"passwordStrength() < 0.3\"\n            [class.medium]=\"passwordStrength() >= 0.3 && passwordStrength() < 0.7\"\n            [class.strong]=\"passwordStrength() >= 0.7\">\n          </div>\n        </div>\n      </div>\n\n      <!-- ✅ Показываем что форма submitting -->\n      <button \n        type=\"submit\" \n        [disabled]=\"form.invalid || submitting()\">\n        @if (submitting()) {\n          <span class=\"spinner\"></span>\n          Submitting...\n        } @else {\n          Submit\n        }\n      </button>\n\n      <!-- ✅ Показываем общие ошибки формы -->\n      @if (formError()) {\n        <div class=\"form-error\" role=\"alert\">\n          {{ formError() }}\n        </div>\n      }\n    </form>\n  `\n})\nexport class UXFormComponent {\n  form = this.fb.group({\n    email: ['', [Validators.required, Validators.email]],\n    username: ['', [Validators.required], [usernameValidator]],\n    password: ['', [Validators.required, Validators.minLength(8)]]\n  });\n\n  submitting = signal(false);\n  formError = signal<string | null>(null);\n\n  get email() {\n    return this.form.get('email')!;\n  }\n\n  get username() {\n    return this.form.get('username')!;\n  }\n\n  get password() {\n    return this.form.get('password')!;\n  }\n\n  // ✅ Вычисляем силу пароля\n  passwordStrength = computed(() => {\n    const password = this.password.value;\n    if (!password) return 0;\n\n    let strength = 0;\n    if (password.length >= 8) strength += 0.25;\n    if (/[a-z]/.test(password)) strength += 0.25;\n    if (/[A-Z]/.test(password)) strength += 0.25;\n    if (/[0-9]/.test(password)) strength += 0.25;\n\n    return strength;\n  });\n\n  getEmailError(): string {\n    if (this.email.hasError('required')) {\n      return 'Email is required';\n    }\n    if (this.email.hasError('email')) {\n      return 'Invalid email format';\n    }\n    return '';\n  }\n\n  async onSubmit() {\n    if (this.form.invalid) {\n      this.form.markAllAsTouched();\n      return;\n    }\n\n    this.submitting.set(true);\n    this.formError.set(null);\n\n    try {\n      await this.apiService.submit(this.form.value);\n      this.router.navigate(['/success']);\n    } catch (error) {\n      this.formError.set('Submission failed. Please try again.');\n    } finally {\n      this.submitting.set(false);\n    }\n  }\n\n  constructor(\n    private fb: FormBuilder,\n    private apiService: ApiService,\n    private router: Router\n  ) {}\n}\n```\n\n**3. Performance Best Practices:**\n\n```typescript\n// ✅ updateOn: 'blur' для уменьшения проверок\nthis.form = this.fb.group({\n  email: ['', {\n    validators: [Validators.email],\n    updateOn: 'blur'  // ✅ Валидируем только при blur\n  }]\n});\n\n// ✅ Debounce для async validators\nexport function asyncValidator(): AsyncValidatorFn {\n  return (control: AbstractControl) => {\n    return timer(500).pipe(  // ✅ Debounce 500ms\n      switchMap(() => checkValue(control.value))\n    );\n  };\n}\n\n// ✅ OnPush для форм с большим количеством полей\n@Component({\n  selector: 'app-large-form',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class LargeFormComponent {\n  // Form с OnPush работает благодаря async pipe\n  form = this.fb.group({ /* много полей */ });\n}\n\n// ✅ trackBy для FormArray\n@Component({\n  template: `\n    <div formArrayName=\"items\">\n      @for (item of items.controls; track trackByFn($index, item)) {\n        <div [formGroupName]=\"$index\">\n          <!-- fields -->\n        </div>\n      }\n    </div>\n  `\n})\nexport class ListFormComponent {\n  trackByFn(index: number, item: AbstractControl) {\n    // ✅ Track по уникальному ID\n    return item.get('id')?.value || index;\n  }\n}\n```\n\n**4. Validation Messages Best Practices:**\n\n```typescript\n// ✅ Централизованные сообщения об ошибках\nconst ERROR_MESSAGES: Record<string, (error: any) => string> = {\n  required: () => 'This field is required',\n  email: () => 'Invalid email address',\n  minlength: (error) => `Minimum length is ${error.requiredLength}`,\n  maxlength: (error) => `Maximum length is ${error.requiredLength}`,\n  min: (error) => `Minimum value is ${error.min}`,\n  max: (error) => `Maximum value is ${error.max}`,\n  pattern: () => 'Invalid format'\n};\n\n@Component({\n  selector: 'app-form-errors',\n  template: `\n    <input [formControl]=\"control\">\n    @if (control.invalid && control.touched) {\n      <div class=\"error\">{{ getErrorMessage() }}</div>\n    }\n  `\n})\nexport class FormErrorsComponent {\n  @Input() control!: FormControl;\n\n  getErrorMessage(): string {\n    const errors = this.control.errors;\n    if (!errors) return '';\n\n    const errorKey = Object.keys(errors)[0];\n    const errorFn = ERROR_MESSAGES[errorKey];\n\n    return errorFn ? errorFn(errors[errorKey]) : 'Invalid input';\n  }\n}\n```\n\n**5. Form State Management:**\n\n```typescript\n// ✅ Centralized form state\ninterface FormState {\n  loading: boolean;\n  error: string | null;\n  submitted: boolean;\n  pristine: boolean;\n}\n\n@Injectable()\nexport class FormStateService {\n  private stateSignal = signal<FormState>({\n    loading: false,\n    error: null,\n    submitted: false,\n    pristine: true\n  });\n\n  state = this.stateSignal.asReadonly();\n\n  setLoading(loading: boolean) {\n    this.stateSignal.update(s => ({ ...s, loading }));\n  }\n\n  setError(error: string | null) {\n    this.stateSignal.update(s => ({ ...s, error }));\n  }\n\n  setSubmitted(submitted: boolean) {\n    this.stateSignal.update(s => ({ ...s, submitted }));\n  }\n\n  reset() {\n    this.stateSignal.set({\n      loading: false,\n      error: null,\n      submitted: false,\n      pristine: true\n    });\n  }\n}\n```\n\n**Best Practices Summary:**\n\n```typescript\n// ✅ Accessibility\n// - Используйте label, aria-*, role\n// - aria-live для динамических ошибок\n// - aria-required, aria-invalid\n\n// ✅ UX\n// - Показывайте ошибки после touch/blur\n// - Inline валидация для critical fields\n// - Loading states для async операций\n// - Success indicators\n// - Confirm перед потерей данных\n\n// ✅ Performance\n// - updateOn: 'blur' где возможно\n// - Debounce для async validators\n// - OnPush change detection\n// - trackBy для FormArray\n\n// ✅ Code Quality\n// - Typed Forms (Angular 14+)\n// - Централизованные error messages\n// - Reusable validators\n// - Form state management\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 46,
          "question_number_in_chapter": 8,
          "question_chapter": 5,
          "question_title": "Forms Testing? Unit tests для форм и валидаторов?",
          "answer_markdown": "**Ответ:**\n\n**Testing Forms** — критически важно для обеспечения корректной работы форм и валидации.\n\n**1. Testing FormControl:**\n\n```typescript\nimport { FormControl, Validators } from '@angular/forms';\n\ndescribe('FormControl', () => {\n  it('should create empty control', () => {\n    const control = new FormControl('');\n    expect(control.value).toBe('');\n    expect(control.valid).toBe(true);\n  });\n\n  it('should validate required field', () => {\n    const control = new FormControl('', Validators.required);\n    \n    expect(control.valid).toBe(false);\n    expect(control.hasError('required')).toBe(true);\n\n    control.setValue('test');\n    \n    expect(control.valid).toBe(true);\n    expect(control.hasError('required')).toBe(false);\n  });\n\n  it('should validate email format', () => {\n    const control = new FormControl('', Validators.email);\n\n    control.setValue('invalid-email');\n    expect(control.hasError('email')).toBe(true);\n\n    control.setValue('valid@email.com');\n    expect(control.hasError('email')).toBe(false);\n  });\n});\n```\n\n**2. Testing FormGroup:**\n\n```typescript\nimport { FormBuilder, Validators } from '@angular/forms';\n\ndescribe('LoginForm', () => {\n  let fb: FormBuilder;\n  let form: FormGroup;\n\n  beforeEach(() => {\n    fb = new FormBuilder();\n    form = fb.group({\n      email: ['', [Validators.required, Validators.email]],\n      password: ['', [Validators.required, Validators.minLength(8)]]\n    });\n  });\n\n  it('should create form with default values', () => {\n    expect(form.value).toEqual({\n      email: '',\n      password: ''\n    });\n  });\n\n  it('should be invalid when empty', () => {\n    expect(form.valid).toBe(false);\n  });\n\n  it('should validate email and password', () => {\n    form.patchValue({\n      email: 'test@example.com',\n      password: 'password123'\n    });\n\n    expect(form.valid).toBe(true);\n    expect(form.get('email')?.valid).toBe(true);\n    expect(form.get('password')?.valid).toBe(true);\n  });\n\n  it('should fail with invalid email', () => {\n    form.patchValue({\n      email: 'invalid-email',\n      password: 'password123'\n    });\n\n    expect(form.valid).toBe(false);\n    expect(form.get('email')?.hasError('email')).toBe(true);\n  });\n\n  it('should fail with short password', () => {\n    form.patchValue({\n      email: 'test@example.com',\n      password: 'short'\n    });\n\n    expect(form.valid).toBe(false);\n    expect(form.get('password')?.hasError('minlength')).toBe(true);\n  });\n});\n```\n\n**3. Testing Custom Validators:**\n\n```typescript\n// passwordStrengthValidator.ts\nexport function passwordStrengthValidator(): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const value = control.value;\n\n    if (!value) return null;\n\n    const hasUpperCase = /[A-Z]/.test(value);\n    const hasLowerCase = /[a-z]/.test(value);\n    const hasNumber = /[0-9]/.test(value);\n\n    const valid = hasUpperCase && hasLowerCase && hasNumber;\n\n    return valid ? null : {\n      passwordStrength: {\n        hasUpperCase,\n        hasLowerCase,\n        hasNumber\n      }\n    };\n  };\n}\n\n// passwordStrengthValidator.spec.ts\ndescribe('passwordStrengthValidator', () => {\n  let control: FormControl;\n\n  beforeEach(() => {\n    control = new FormControl('', passwordStrengthValidator());\n  });\n\n  it('should return null for empty value', () => {\n    control.setValue('');\n    expect(control.errors).toBeNull();\n  });\n\n  it('should fail without uppercase', () => {\n    control.setValue('password123');\n    expect(control.hasError('passwordStrength')).toBe(true);\n    expect(control.getError('passwordStrength').hasUpperCase).toBe(false);\n  });\n\n  it('should fail without lowercase', () => {\n    control.setValue('PASSWORD123');\n    expect(control.hasError('passwordStrength')).toBe(true);\n    expect(control.getError('passwordStrength').hasLowerCase).toBe(false);\n  });\n\n  it('should fail without number', () => {\n    control.setValue('Password');\n    expect(control.hasError('passwordStrength')).toBe(true);\n    expect(control.getError('passwordStrength').hasNumber).toBe(false);\n  });\n\n  it('should pass with all requirements', () => {\n    control.setValue('Password123');\n    expect(control.valid).toBe(true);\n    expect(control.errors).toBeNull();\n  });\n});\n```\n\n**4. Testing Async Validators:**\n\n```typescript\n// usernameValidator.ts\nexport function usernameAvailableValidator(\n  userService: UserService\n): AsyncValidatorFn {\n  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n    if (!control.value) {\n      return of(null);\n    }\n\n    return userService.checkUsername(control.value).pipe(\n      map(available => available ? null : { usernameTaken: true }),\n      catchError(() => of(null))\n    );\n  };\n}\n\n// usernameValidator.spec.ts\nimport { TestBed } from '@angular/core/testing';\nimport { of, throwError } from 'rxjs';\n\ndescribe('usernameAvailableValidator', () => {\n  let userService: jasmine.SpyObj<UserService>;\n  let control: FormControl;\n\n  beforeEach(() => {\n    const spy = jasmine.createSpyObj('UserService', ['checkUsername']);\n    \n    TestBed.configureTestingModule({\n      providers: [{ provide: UserService, useValue: spy }]\n    });\n\n    userService = TestBed.inject(UserService) as jasmine.SpyObj<UserService>;\n    control = new FormControl('', null, usernameAvailableValidator(userService));\n  });\n\n  it('should return null for empty value', (done) => {\n    control.setValue('');\n    \n    control.statusChanges.pipe(take(1)).subscribe(() => {\n      expect(control.errors).toBeNull();\n      done();\n    });\n  });\n\n  it('should return null when username is available', (done) => {\n    userService.checkUsername.and.returnValue(of(true));\n    control.setValue('available');\n\n    control.statusChanges.pipe(take(1)).subscribe(() => {\n      expect(control.valid).toBe(true);\n      expect(control.errors).toBeNull();\n      done();\n    });\n  });\n\n  it('should return error when username is taken', (done) => {\n    userService.checkUsername.and.returnValue(of(false));\n    control.setValue('taken');\n\n    control.statusChanges.pipe(take(1)).subscribe(() => {\n      expect(control.invalid).toBe(true);\n      expect(control.hasError('usernameTaken')).toBe(true);\n      done();\n    });\n  });\n\n  it('should return null on network error', (done) => {\n    userService.checkUsername.and.returnValue(throwError(() => new Error('Network error')));\n    control.setValue('username');\n\n    control.statusChanges.pipe(take(1)).subscribe(() => {\n      expect(control.errors).toBeNull();\n      done();\n    });\n  });\n});\n```\n\n**5. Testing Form Component:**\n\n```typescript\n// login.component.spec.ts\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { LoginComponent } from './login.component';\n\ndescribe('LoginComponent', () => {\n  let component: LoginComponent;\n  let fixture: ComponentFixture<LoginComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [ReactiveFormsModule, LoginComponent]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(LoginComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should have invalid form on init', () => {\n    expect(component.loginForm.valid).toBe(false);\n  });\n\n  it('should validate email field', () => {\n    const email = component.loginForm.get('email')!;\n\n    email.setValue('invalid-email');\n    expect(email.hasError('email')).toBe(true);\n\n    email.setValue('valid@email.com');\n    expect(email.hasError('email')).toBe(false);\n  });\n\n  it('should call onSubmit when form is valid', () => {\n    spyOn(component, 'onSubmit');\n\n    component.loginForm.patchValue({\n      email: 'test@example.com',\n      password: 'password123'\n    });\n\n    const form = fixture.nativeElement.querySelector('form');\n    form.dispatchEvent(new Event('submit'));\n\n    expect(component.onSubmit).toHaveBeenCalled();\n  });\n\n  it('should disable submit button when form is invalid', () => {\n    const button = fixture.nativeElement.querySelector('button[type=\"submit\"]');\n    expect(button.disabled).toBe(true);\n\n    component.loginForm.patchValue({\n      email: 'test@example.com',\n      password: 'password123'\n    });\n    fixture.detectChanges();\n\n    expect(button.disabled).toBe(false);\n  });\n\n  it('should show error messages', () => {\n    const email = component.loginForm.get('email')!;\n    email.setValue('invalid');\n    email.markAsTouched();\n    fixture.detectChanges();\n\n    const errorElement = fixture.nativeElement.querySelector('.error');\n    expect(errorElement).toBeTruthy();\n    expect(errorElement.textContent).toContain('Invalid email');\n  });\n});\n```\n\n**6. Testing FormArray:**\n\n```typescript\ndescribe('ContactsForm with FormArray', () => {\n  let component: ContactsComponent;\n  let fixture: ComponentFixture<ContactsComponent>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [ReactiveFormsModule, ContactsComponent]\n    });\n\n    fixture = TestBed.createComponent(ContactsComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should add contact to FormArray', () => {\n    expect(component.contacts.length).toBe(1);  // Initial contact\n\n    component.addContact();\n    \n    expect(component.contacts.length).toBe(2);\n  });\n\n  it('should remove contact from FormArray', () => {\n    component.addContact();\n    component.addContact();\n    expect(component.contacts.length).toBe(3);\n\n    component.removeContact(1);\n    \n    expect(component.contacts.length).toBe(2);\n  });\n\n  it('should validate contacts', () => {\n    const contact = component.contacts.at(0);\n    \n    contact.patchValue({\n      name: '',\n      email: 'invalid-email'\n    });\n\n    expect(contact.invalid).toBe(true);\n    expect(contact.get('name')?.hasError('required')).toBe(true);\n    expect(contact.get('email')?.hasError('email')).toBe(true);\n  });\n});\n```\n\n**Best Practices:**\n\n```typescript\n// ✅ Тестируйте validators отдельно от компонентов\ndescribe('passwordStrengthValidator', () => { /* ... */ });\n\n// ✅ Используйте async/done для async validators\nit('should validate async', (done) => {\n  control.statusChanges.subscribe(() => {\n    expect(control.valid).toBe(true);\n    done();\n  });\n});\n\n// ✅ Проверяйте disabled состояние UI\nconst button = fixture.nativeElement.querySelector('button');\nexpect(button.disabled).toBe(true);\n\n// ✅ Тестируйте error messages\nconst error = fixture.nativeElement.querySelector('.error');\nexpect(error.textContent).toContain('Email is required');\n\n// ✅ Тестируйте FormArray operations\ncomponent.addItem();\nexpect(component.items.length).toBe(2);\n```",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 6,
      "chapter_title": "State Management",
      "questions": [
        {
          "question_number": 47,
          "question_number_in_chapter": 1,
          "question_chapter": 6,
          "question_title": "Какие подходы к State Management в Angular? Services vs NgRx vs Signals?",
          "answer_markdown": "**Services с BehaviorSubject** - самый простой подход для небольших приложений.  \n**NgRx** - Redux-подобный для больших приложений с предсказуемым state flow.  \n**Signals (Angular 16+)** - новый реактивный подход, рекомендуется для новых проектов.\n\n```typescript\n// Services подход\n@Injectable({ providedIn: 'root' })\nexport class StateService {\n  private state = new BehaviorSubject({ count: 0 });\n  state$ = this.state.asObservable();\n  \n  increment() {\n    this.state.next({ count: this.state.value.count + 1 });\n  }\n}\n\n// Signals подход (рекомендуется)\n@Injectable({ providedIn: 'root' })\nexport class SignalStateService {\n  private countSignal = signal(0);\n  count = this.countSignal.asReadonly();\n  \n  increment() {\n    this.countSignal.update(v => v + 1);\n  }\n}\n```",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 48,
          "question_number_in_chapter": 2,
          "question_chapter": 6,
          "question_title": "Services-based State vs NgRx vs Signals - когда что использовать? Сравнение подходов, плюсы/минусы.",
          "answer_markdown": "**Ответ:**\n\nAngular предлагает три основных подхода к управлению состоянием: **Services-based**, **NgRx** и **Signals** (Angular 16+). Выбор подхода зависит от размера приложения, сложности состояния и требований команды.\n\n**1. Services-based State Management**\n\nПростейший подход с использованием injectable services и RxJS:\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\n@Injectable({ provided In: 'root' })\nexport class UserStateService {\n  private userSubject = new BehaviorSubject<User | null>(null);\n  user$: Observable<User | null> = this.userSubject.asObservable();\n\n  setUser(user: User): void {\n    this.userSubject.next(user);\n  }\n\n  clearUser(): void {\n    this.userSubject.next(null);\n  }\n}\n```\n\n**2. NgRx Store (Redux pattern)**\n\nЦентрализованное хранилище с предсказуемым flow:\n\n```typescript\n// Actions\nexport const loadUsers = createAction('[Users] Load');\nexport const loadUsersSuccess = createAction('[Users] Load Success', props<{ users: User[] }>());\n\n// Reducer\nexport const usersReducer = createReducer(\n  initialState,\n  on(loadUsersSuccess, (state, { users }) => ({ ...state, users }))\n);\n\n// Selector\nexport const selectUsers = createSelector(\n  (state: AppState) => state.users,\n  (users) => users\n);\n\n// Component\nusers$ = this.store.select(selectUsers);\n```\n\n**3. Angular Signals (Angular 16+)**\n\nРеактивность нового поколения без RxJS:\n\n```typescript\nimport { Injectable, signal, computed } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class UserSignalService {\n  user = signal<User | null>(null);\n  isLoggedIn = computed(() => this.user() !== null);\n\n  setUser(user: User): void {\n    this.user.set(user);\n  }\n}\n\n// Component\nuserService = inject(UserSignalService);\nuserName = computed(() => this.userService.user()?.name ?? 'Guest');\n```\n\n**Сравнительная таблица:**\n\n| Критерий | Services | NgRx | Signals |\n|----------|----------|------|---------|\n| **Сложность** | Простая | Высокая | Средняя |\n| **Boilerplate** | Минимальный | Большой | Малый |\n| **Debugging** | Сложно | Легко (DevTools) | Средне |\n| **Performance** | Хорошая | Отличная | Отличная |\n| **Learning Curve** | Низкая | Высокая | Средняя |\n| **Time Travel** | ❌ Нет | ✅ Да | ❌ Нет |\n| **TypeScript Support** | Хорошая | Отличная | Отличная |\n| **Тестируемость** | Средняя | Отличная | Хорошая |\n| **Подходит для** | Малые/средние | Enterprise | Средние/большие |\n| **Асинхронность** | RxJS | Effects (RxJS) | toSignal/toObservable |\n| **Change Detection** | Standard | OnPush | Zoneless ready |\n\n**Когда использовать каждый подход:**\n\n**Services-based:**\n- ✅ Простые приложения (<10 компонентов)\n- ✅ Локальное состояние компонента\n- ✅ Быстрые прототипы\n- ✅ Команда без опыта NgRx\n- ❌ Сложные state transitions\n- ❌ Необходимость отладки временной шкалы\n\n**NgRx:**\n- ✅ Enterprise приложения\n- ✅ Сложная бизнес-логика\n- ✅ Множество асинхронных операций\n- ✅ Необходимость audit trail\n- ✅ Команда знакома с Redux\n- ❌ Малые проекты (overkill)\n- ❌ Ограниченное время на разработку\n\n**Signals:**\n- ✅ Angular 16+ проекты\n- ✅ Средние и большие приложения\n- ✅ Высокая производительность критична\n- ✅ Zoneless mode (будущее Angular)\n- ✅ Упрощение Change Detection\n- ❌ Требуется обратная совместимость с Angular <16\n\n**Best Practices:**\n\n- ✅ Комбинируйте подходы (Signals для UI state, NgRx для бизнес-логики)\n- ✅ Используйте ComponentStore для локального состояния\n- ✅ Предпочитайте immutability во всех подходах\n- ✅ Документируйте решения архитектуры\n- ❌ Не смешивайте Services и NgRx для одного и того же состояния\n- ❌ Не используйте NgRx без необходимости\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 49,
          "question_number_in_chapter": 3,
          "question_chapter": 6,
          "question_title": "Как реализовать Reactive State с RxJS? BehaviorSubject, scan(), shareReplay(). Паттерн Facade.",
          "answer_markdown": "**Ответ:**\n\nReactive State Management с RxJS предоставляет мощный способ управления состоянием через потоки данных.\n\n**1. BehaviorSubject - основа реактивного состояния**\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\ninterface TodoState {\n  todos: Todo[];\n  loading: boolean;\n  error: string | null;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class TodoStateService {\n  private readonly initialState: TodoState = {\n    todos: [],\n    loading: false,\n    error: null\n  };\n\n  // Private Subject - единственный источник изменений\n  private state$ = new BehaviorSubject<TodoState>(this.initialState);\n\n  // Public Observable - read-only для компонентов\n  readonly todos$ = this.state$.pipe(\n    map(state => state.todos),\n    distinctUntilChanged()\n  );\n\n  readonly loading$ = this.state$.pipe(\n    map(state => state.loading),\n    distinctUntilChanged()\n  );\n\n  // Метод для обновления состояния\n  private updateState(partial: Partial<TodoState>): void {\n    this.state$.next({ ...this.state$.value, ...partial });\n  }\n\n  addTodo(todo: Todo): void {\n    this.updateState({\n      todos: [...this.state$.value.todos, todo]\n    });\n  }\n\n  removeTodo(id: string): void {\n    this.updateState({\n      todos: this.state$.value.todos.filter(t => t.id !== id)\n    });\n  }\n}\n```\n\n**2. scan() - аккумуляция состояния (Event Sourcing pattern)**\n\n```typescript\nimport { Subject } from 'rxjs';\nimport { scan, startWith, shareReplay } from 'rxjs/operators';\n\n// Actions\ntype TodoAction =\n  | { type: 'ADD'; todo: Todo }\n  | { type: 'REMOVE'; id: string }\n  | { type: 'TOGGLE'; id: string };\n\n@Injectable({ providedIn: 'root' })\nexport class EventSourcedTodoService {\n  // Action stream\n  private actions$ = new Subject<TodoAction>();\n\n  // State stream - создаётся из действий\n  state$ = this.actions$.pipe(\n    startWith({ todos: [] }),\n    scan((state, action) => {\n      switch (action.type) {\n        case 'ADD':\n          return {\n            ...state,\n            todos: [...state.todos, action.todo]\n          };\n        case 'REMOVE':\n          return {\n            ...state,\n            todos: state.todos.filter(t => t.id !== action.id)\n          };\n        case 'TOGGLE':\n          return {\n            ...state,\n            todos: state.todos.map(t =>\n              t.id === action.id ? { ...t, completed: !t.completed } : t\n            )\n          };\n        default:\n          return state;\n      }\n    }),\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n\n  // Public API\n  addTodo(todo: Todo): void {\n    this.actions$.next({ type: 'ADD', todo });\n  }\n\n  removeTodo(id: string): void {\n    this.actions$.next({ type: 'REMOVE', id });\n  }\n\n  toggleTodo(id: string): void {\n    this.actions$.next({ type: 'TOGGLE', id });\n  }\n}\n```\n\n**3. shareReplay() - кэширование и мультикаст**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  // ❌ БЕЗ shareReplay - каждая подписка создаёт новый HTTP запрос\n  users$Bad = this.http.get<User[]>('/api/users');\n\n  // ✅ С shareReplay - один запрос, результат кэшируется\n  users$ = this.http.get<User[]>('/api/users').pipe(\n    shareReplay({ bufferSize: 1, refCount: true })\n    //            ↑ кэшировать 1 значение\n    //                              ↑ auto-unsubscribe когда нет подписчиков\n  );\n\n  // Продвинутый пример с обновлением\n  private refresh$ = new Subject<void>();\n\n  usersWithRefresh$ = this.refresh$.pipe(\n    startWith(undefined), // initial load\n    switchMap(() => this.http.get<User[]>('/api/users')),\n    shareReplay({ bufferSize: 1, refCount: false }) // keep last даже без подписчиков\n  );\n\n  refresh(): void {\n    this.refresh$.next();\n  }\n}\n```\n\n**4. Facade Pattern - высокоуровневый API**\n\nFacade скрывает сложность state management и предоставляет простой интерфейс:\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class ProductsFacade {\n  // Private state\n  private productsSubject$ = new BehaviorSubject<Product[]>([]);\n  private loadingSubject$ = new BehaviorSubject<boolean>(false);\n  private errorSubject$ = new BehaviorSubject<string | null>(null);\n\n  // Public observables\n  products$ = this.productsSubject$.asObservable();\n  loading$ = this.loadingSubject$.asObservable();\n  error$ = this.errorSubject$.asObservable();\n\n  // Derived state\n  productsCount$ = this.products$.pipe(\n    map(products => products.length)\n  );\n\n  hasProducts$ = this.productsCount$.pipe(\n    map(count => count > 0)\n  );\n\n  constructor(private http: HttpClient) {}\n\n  // Public API - простые методы\n  loadProducts(): void {\n    this.loadingSubject$.next(true);\n    this.errorSubject$.next(null);\n\n    this.http.get<Product[]>('/api/products')\n      .pipe(\n        tap(products => {\n          this.productsSubject$.next(products);\n          this.loadingSubject$.next(false);\n        }),\n        catchError(error => {\n          this.errorSubject$.next(error.message);\n          this.loadingSubject$.next(false);\n          return of([]);\n        })\n      )\n      .subscribe();\n  }\n\n  addProduct(product: Product): void {\n    const current = this.productsSubject$.value;\n    this.productsSubject$.next([...current, product]);\n  }\n\n  updateProduct(id: string, updates: Partial<Product>): void {\n    const current = this.productsSubject$.value;\n    this.productsSubject$.next(\n      current.map(p => p.id === id ? { ...p, ...updates } : p)\n    );\n  }\n}\n\n// Component - простое использование\n@Component({\n  template: `\n    <div *ngIf=\"loading$ | async\">Loading...</div>\n    <div *ngIf=\"error$ | async as error\">{{ error }}</div>\n\n    <div *ngFor=\"let product of products$ | async\">\n      {{ product.name }}\n    </div>\n\n    <p>Total: {{ productsCount$ | async }}</p>\n  `\n})\nexport class ProductsComponent {\n  products$ = this.facade.products$;\n  loading$ = this.facade.loading$;\n  error$ = this.facade.error$;\n  productsCount$ = this.facade.productsCount$;\n\n  constructor(private facade: ProductsFacade) {\n    this.facade.loadProducts();\n  }\n}\n```\n\n**Best Practices:**\n\n- ✅ Используйте `private` Subject, `public` Observable\n- ✅ `distinctUntilChanged()` для избежания лишних эмиссий\n- ✅ `shareReplay({ bufferSize: 1, refCount: true })` для HTTP запросов\n- ✅ Facade pattern для упрощения API\n- ✅ `takeUntilDestroyed()` (Angular 16+) для auto-unsubscribe\n- ❌ Не подписывайтесь вручную - используйте `async` pipe\n- ❌ Не мутируйте состояние напрямую - всегда создавайте новые объекты\n- ❌ Избегайте nested subscriptions - используйте higher-order operators (switchMap, mergeMap)\n\n**Senior-level insights:**\n\n- Reactive State хорошо работает с OnPush Change Detection\n- Комбинируйте с Angular Signals через `toSignal()` (Angular 16+)\n- Для сложных сценариев рассмотрите NgRx ComponentStore\n- Мониторьте performance с RxJS Spy в development\n# Angular - Новые вопросы 48-54, 56-62, 64-70\n\n# Angular State Management - Senior Level Questions (Q50-51)",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 50,
          "question_number_in_chapter": 4,
          "question_chapter": 6,
          "question_title": "NgRx Store - Полная архитектура (Actions, Reducers, Selectors, Effects). Когда оправдано? Redux DevTools Integration",
          "answer_markdown": "### **Ответ:**\n\n#### 1. Архитектурный обзор NgRx\n\nNgRx реализует паттерн Redux в Angular для централизованного управления состоянием приложения. Это критически важно для масштабных приложений с комплексной логикой взаимодействия между компонентами.\n\n**Основные слои архитектуры:**\n\n```typescript\n// 1. STATE INTERFACE - определение формы хранилища\nexport interface AppState {\n  products: ProductsState;\n  cart: CartState;\n  user: UserState;\n  loading: LoadingState;\n  errors: ErrorState;\n}\n\nexport interface ProductsState {\n  items: Product[];\n  selectedProduct: Product | null;\n  filters: ProductFilters;\n  totalCount: number;\n  currentPage: number;\n  pageSize: number;\n}\n\nexport interface Product {\n  id: string;\n  name: string;\n  price: number;\n  category: string;\n  inStock: boolean;\n  reviews: Review[];\n}\n\nexport interface CartState {\n  items: CartItem[];\n  subtotal: number;\n  tax: number;\n  shipping: number;\n  total: number;\n  lastUpdated: timestamp;\n}\n```\n\n#### 2. Actions - синхронизация событий\n\nActions представляют намерения изменить состояние. Это объекты с `type` и опциональным `payload`.\n\n```typescript\n// products.actions.ts\nimport { createAction, props } from '@ngrx/store';\nimport { Product, ProductFilters } from './models';\n\n// Базовые действия загрузки\nexport const loadProducts = createAction(\n  '[Products Page] Load Products',\n  props<{ filters: ProductFilters; page: number }>()\n);\n\nexport const loadProductsSuccess = createAction(\n  '[Products API] Load Products Success',\n  props<{ products: Product[]; totalCount: number }>()\n);\n\nexport const loadProductsFailure = createAction(\n  '[Products API] Load Products Failure',\n  props<{ error: string }>()\n);\n\n// Actions для отдельного продукта\nexport const selectProduct = createAction(\n  '[Products Page] Select Product',\n  props<{ id: string }>()\n);\n\nexport const loadProductDetail = createAction(\n  '[Product Detail Page] Load Product Detail',\n  props<{ id: string }>()\n);\n\nexport const loadProductDetailSuccess = createAction(\n  '[Product Detail API] Load Product Detail Success',\n  props<{ product: Product }>()\n);\n\nexport const loadProductDetailFailure = createAction(\n  '[Product Detail API] Load Product Detail Failure',\n  props<{ error: string }>()\n);\n\n// Actions для корзины\nexport const addToCart = createAction(\n  '[Product Detail] Add to Cart',\n  props<{ product: Product; quantity: number }>()\n);\n\nexport const removeFromCart = createAction(\n  '[Cart] Remove Item',\n  props<{ productId: string }>()\n);\n\nexport const updateCartItemQuantity = createAction(\n  '[Cart] Update Item Quantity',\n  props<{ productId: string; quantity: number }>()\n);\n\n// Actions для очистки\nexport const clearProductsError = createAction(\n  '[Products Page] Clear Error'\n);\n\nexport const resetProducts = createAction(\n  '[Products] Reset State'\n);\n```\n\n#### 3. Reducers - чистые функции трансформации состояния\n\n```typescript\n// products.reducer.ts\nimport { createReducer, on, Action } from '@ngrx/store';\nimport * as ProductsActions from './products.actions';\nimport { ProductsState, Product } from './models';\n\nconst initialState: ProductsState = {\n  items: [],\n  selectedProduct: null,\n  filters: { category: null, priceRange: [0, 1000] },\n  totalCount: 0,\n  currentPage: 1,\n  pageSize: 20,\n};\n\nconst productsReducer = createReducer(\n  initialState,\n\n  // Загрузка списка продуктов\n  on(ProductsActions.loadProducts, (state) => ({\n    ...state,\n    currentPage: state.currentPage,\n  })),\n\n  on(ProductsActions.loadProductsSuccess, (state, { products, totalCount }) => ({\n    ...state,\n    items: products,\n    totalCount,\n    error: null,\n  })),\n\n  on(ProductsActions.loadProductsFailure, (state, { error }) => ({\n    ...state,\n    error,\n    items: [],\n  })),\n\n  // Выбор отдельного продукта\n  on(ProductsActions.selectProduct, (state, { id }) => ({\n    ...state,\n    selectedProduct: state.items.find(p => p.id === id) || null,\n  })),\n\n  on(ProductsActions.loadProductDetailSuccess, (state, { product }) => ({\n    ...state,\n    selectedProduct: product,\n    // Обновляем элемент в списке если он там есть\n    items: state.items.map(p => p.id === product.id ? product : p),\n  })),\n\n  // Очистка ошибки\n  on(ProductsActions.clearProductsError, (state) => ({\n    ...state,\n    error: null,\n  })),\n\n  // Сброс состояния\n  on(ProductsActions.resetProducts, () => initialState),\n);\n\nexport function reducer(state: ProductsState | undefined, action: Action) {\n  return productsReducer(state, action);\n}\n```\n\n#### 4. Selectors - оптимизированная выборка из состояния\n\nSelectors создают мемоизированные селекторы для избежания ненужных пересчётов и re-render'ов.\n\n```typescript\n// products.selectors.ts\nimport { createFeatureSelector, createSelector } from '@ngrx/store';\nimport { ProductsState, Product } from './models';\n\n// Feature selector\nconst selectProductsFeature = createFeatureSelector<ProductsState>('products');\n\n// Базовые селекторы\nexport const selectAllProducts = createSelector(\n  selectProductsFeature,\n  (state: ProductsState) => state.items\n);\n\nexport const selectSelectedProduct = createSelector(\n  selectProductsFeature,\n  (state: ProductsState) => state.selectedProduct\n);\n\nexport const selectProductsError = createSelector(\n  selectProductsFeature,\n  (state: ProductsState) => state.error\n);\n\nexport const selectCurrentPage = createSelector(\n  selectProductsFeature,\n  (state: ProductsState) => state.currentPage\n);\n\nexport const selectPageSize = createSelector(\n  selectProductsFeature,\n  (state: ProductsState) => state.pageSize\n);\n\n// Комбинированные селекторы (дорогие вычисления)\nexport const selectProductsByCategory = createSelector(\n  selectAllProducts,\n  selectProductsFeature,\n  (products: Product[], state: ProductsState) =>\n    products.filter(p => p.category === state.filters.category)\n);\n\nexport const selectPaginatedProducts = createSelector(\n  selectAllProducts,\n  selectCurrentPage,\n  selectPageSize,\n  (products: Product[], page: number, pageSize: number) => {\n    const startIndex = (page - 1) * pageSize;\n    return products.slice(startIndex, startIndex + pageSize);\n  }\n);\n\nexport const selectProductById = (id: string) => createSelector(\n  selectAllProducts,\n  (products: Product[]) => products.find(p => p.id === id)\n);\n\n// Селекторы для производительности\nexport const selectProductsLoading = createSelector(\n  selectProductsFeature,\n  (state: ProductsState) => state.loading\n);\n\nexport const selectProductsMetadata = createSelector(\n  selectProductsFeature,\n  selectCurrentPage,\n  selectPageSize,\n  (state: ProductsState, page: number, pageSize: number) => ({\n    currentPage: page,\n    pageSize,\n    totalCount: state.totalCount,\n    totalPages: Math.ceil(state.totalCount / pageSize),\n  })\n);\n\n// Селектор с мемоизацией для отфильтрованных данных\nexport const selectFilteredAndSortedProducts = createSelector(\n  selectAllProducts,\n  selectProductsFeature,\n  (products: Product[], state: ProductsState) => {\n    let filtered = products;\n\n    if (state.filters.category) {\n      filtered = filtered.filter(p => p.category === state.filters.category);\n    }\n\n    if (state.filters.priceRange) {\n      const [minPrice, maxPrice] = state.filters.priceRange;\n      filtered = filtered.filter(p => p.price >= minPrice && p.price <= maxPrice);\n    }\n\n    return filtered.sort((a, b) => a.price - b.price);\n  }\n);\n```\n\n#### 5. Effects - обработка побочных эффектов (Side Effects)\n\nEffects - это эпический паттерн, обрабатывающий асинхронные операции, API вызовы, навигацию.\n\n```typescript\n// products.effects.ts\nimport { Injectable } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { Store } from '@ngrx/store';\nimport { of } from 'rxjs';\nimport {\n  switchMap,\n  map,\n  catchError,\n  withLatestFrom,\n  filter,\n  debounceTime,\n  distinctUntilChanged,\n  tap,\n} from 'rxjs/operators';\nimport { ProductService } from '../services/product.service';\nimport * as ProductsActions from './products.actions';\nimport * as ProductsSelectors from './products.selectors';\n\n@Injectable()\nexport class ProductsEffects {\n\n  // Effect для загрузки списка продуктов\n  loadProducts$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(ProductsActions.loadProducts),\n      debounceTime(300), // Дебаунс для избежания множественных запросов\n      distinctUntilChanged((prev, curr) =>\n        JSON.stringify(prev) === JSON.stringify(curr)\n      ),\n      withLatestFrom(\n        this.store.select(ProductsSelectors.selectCurrentPage),\n        this.store.select(ProductsSelectors.selectPageSize)\n      ),\n      switchMap(([action, page, pageSize]) =>\n        this.productService.getProducts(action.filters, page, pageSize).pipe(\n          map(({ products, totalCount }) =>\n            ProductsActions.loadProductsSuccess({\n              products,\n              totalCount,\n            })\n          ),\n          catchError((error) =>\n            of(ProductsActions.loadProductsFailure({\n              error: error.message,\n            }))\n          )\n        )\n      )\n    )\n  );\n\n  // Effect для загрузки деталей продукта\n  loadProductDetail$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(ProductsActions.loadProductDetail),\n      switchMap(({ id }) =>\n        this.productService.getProductById(id).pipe(\n          map(product =>\n            ProductsActions.loadProductDetailSuccess({ product })\n          ),\n          catchError((error) =>\n            of(ProductsActions.loadProductDetailFailure({\n              error: error.message,\n            }))\n          )\n        )\n      )\n    )\n  );\n\n  // Effect для добавления в корзину (например, логирование в аналитику)\n  addToCart$ = createEffect(\n    () =>\n      this.actions$.pipe(\n        ofType(ProductsActions.addToCart),\n        tap(({ product, quantity }) => {\n          console.log(`Added ${quantity} of ${product.name} to cart`);\n          // Можно отправить аналитику, логи и т.д.\n          this.logAnalytics('product_added_to_cart', {\n            productId: product.id,\n            quantity,\n            price: product.price,\n          });\n        })\n      ),\n    { dispatch: false } // Это не диспатчит action, только выполняет side effect\n  );\n\n  // Effect для умного кэширования\n  loadProductWithCache$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(ProductsActions.loadProductDetail),\n      withLatestFrom(\n        this.store.select(ProductsSelectors.selectAllProducts)\n      ),\n      switchMap(([{ id }, cachedProducts]) => {\n        const cachedProduct = cachedProducts.find(p => p.id === id);\n\n        if (cachedProduct) {\n          // Если в кэше, возвращаем без запроса\n          return of(ProductsActions.loadProductDetailSuccess({\n            product: cachedProduct,\n          }));\n        }\n\n        // Иначе делаем запрос\n        return this.productService.getProductById(id).pipe(\n          map(product =>\n            ProductsActions.loadProductDetailSuccess({ product })\n          ),\n          catchError((error) =>\n            of(ProductsActions.loadProductDetailFailure({\n              error: error.message,\n            }))\n          )\n        );\n      })\n    )\n  );\n\n  constructor(\n    private actions$: Actions,\n    private store: Store,\n    private productService: ProductService\n  ) {}\n\n  private logAnalytics(event: string, data: any) {\n    // Отправка аналитики\n    console.log('Analytics:', event, data);\n  }\n}\n```\n\n#### 6. Store Configuration и Module Setup\n\n```typescript\n// app.module.ts\nimport { NgModule } from '@angular/core';\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { environment } from '../environments/environment';\n\nimport { reducer as productsReducer } from './store/products/products.reducer';\nimport { reducer as cartReducer } from './store/cart/cart.reducer';\nimport { ProductsEffects } from './store/products/products.effects';\nimport { CartEffects } from './store/cart/cart.effects';\n\n@NgModule({\n  imports: [\n    // Регистрация feature store\n    StoreModule.forRoot({}),\n    StoreModule.forFeature('products', productsReducer),\n    StoreModule.forFeature('cart', cartReducer),\n\n    // Регистрация effects\n    EffectsModule.forRoot([]),\n    EffectsModule.forFeature([ProductsEffects, CartEffects]),\n\n    // Redux DevTools Integration для development\n    StoreDevtoolsModule.instrument({\n      maxAge: 25, // Сохранять последние 25 actions\n      logOnly: environment.production, // Только логирование в production\n      features: {\n        pause: true, // Позволяет паузировать time-travel debugging\n        lock: true,\n        persist: true, // Сохранять состояние в localStorage\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n#### 7. Использование Store в компонентах\n\n```typescript\n// products-list.component.ts\nimport { Component, OnInit, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { AppState } from '../store/app.state';\nimport * as ProductsActions from '../store/products/products.actions';\nimport * as ProductsSelectors from '../store/products/products.selectors';\n\n@Component({\n  selector: 'app-products-list',\n  templateUrl: './products-list.component.html',\n  styleUrls: ['./products-list.component.css'],\n})\nexport class ProductsListComponent implements OnInit {\n\n  products$: Observable<Product[]>;\n  loading$: Observable<boolean>;\n  error$: Observable<string | null>;\n  metadata$: Observable<any>;\n\n  constructor(private store: Store<AppState>) {\n    // Селекторы возвращают Observable\n    this.products$ = this.store.select(ProductsSelectors.selectPaginatedProducts);\n    this.loading$ = this.store.select(ProductsSelectors.selectProductsLoading);\n    this.error$ = this.store.select(ProductsSelectors.selectProductsError);\n    this.metadata$ = this.store.select(ProductsSelectors.selectProductsMetadata);\n  }\n\n  ngOnInit(): void {\n    // Диспатч action для загрузки\n    this.store.dispatch(ProductsActions.loadProducts({\n      filters: { category: null, priceRange: [0, 1000] },\n      page: 1,\n    }));\n  }\n\n  selectProduct(productId: string): void {\n    this.store.dispatch(ProductsActions.selectProduct({ id: productId }));\n  }\n\n  addToCart(product: Product, quantity: number): void {\n    this.store.dispatch(ProductsActions.addToCart({\n      product,\n      quantity,\n    }));\n  }\n}\n```\n\n#### 8. Когда NgRx оправдан? (Decision Tree)\n\n**ИСПОЛЬЗУЙТЕ NgRx если:**\n- ✓ Приложение имеет более 100+ компонентов с глубокой иерархией\n- ✓ Состояние сложное и изменяется частично из многих мест\n- ✓ Нужна история изменений (time-travel debugging)\n- ✓ Требуется синхронизация состояния между вкладками браузера\n- ✓ Критична производительность (мемоизация селекторов)\n- ✓ Нужна валидация и управление побочными эффектами\n- ✓ Команда знакома с Redux паттерном\n\n**НЕ ИСПОЛЬЗУЙТЕ NgRx если:**\n- ✗ Простое приложение с несколькими компонентами\n- ✗ Состояние не изменяется часто\n- ✗ Можно обойтись локальным состоянием компонента\n- ✗ Команда не знакома с Redux паттерном\n\n#### 9. Redux DevTools Integration - Advanced Features\n\n```typescript\n// Redux DevTools позволяет:\n// 1. Time-travel debugging - вернуться к любому state snapshot\n// 2. Action replay - воспроизвести конкретную последовательность actions\n// 3. State diff - увидеть точные изменения состояния\n// 4. Import/Export состояния для отладки\n// 5. Conditional breakpoints на actions\n\n// В браузере установите расширение Redux DevTools\n// Chrome: https://chrome.google.com/webstore/detail/redux-devtools/\n\n// Пример пользовательской конфигурации DevTools\nStoreDevtoolsModule.instrument({\n  maxAge: 25,\n  logOnly: environment.production,\n  // Фильтрация actions для DevTools\n  actionSanitizer: (action) => ({\n    ...action,\n    // Скрыть чувствительные данные\n    payload: action.type.includes('login') ? '***hidden***' : action.payload,\n  }),\n  stateSanitizer: (state) => ({\n    ...state,\n    // Скрыть sensitive данные в state\n    user: state.user ? { ...state.user, password: '***' } : null,\n  }),\n})\n```\n\n#### 10. Performance Optimization Tips\n\n```typescript\n// 1. OnPush Change Detection Strategy с Store\n@Component({\n  selector: 'app-product',\n  templateUrl: './product.component.html',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class ProductComponent {\n  product$ = this.store.select(selectSelectedProduct);\n\n  constructor(private store: Store<AppState>) {}\n}\n\n// 2. Правильное использование async pipe\n// ✓ ХОРОШО: async pipe автоматически подписывается и отписывается\n// <div>{{ product$ | async as product }}</div>\n\n// ✗ ПЛОХО: Ручная подписка без отписки (memory leak)\nngOnInit() {\n  this.subscription = this.store.select(selectProduct).subscribe(...);\n}\n\n// 3. Комбинирование селекторов для избежания множественных подписок\nexport const selectProductWithReviews = createSelector(\n  selectSelectedProduct,\n  selectProductReviews,\n  (product, reviews) => ({ product, reviews })\n);\n\n// 4. Использование distinctUntilChanged для фильтрации идентичных значений\nthis.store.pipe(\n  select(selectProduct),\n  distinctUntilChanged(), // Избегаем re-render если product не изменился\n).subscribe(...)\n```\n\n### Заключение\n\nNgRx Store - это мощный инструмент для управления состоянием в Angular, обеспечивающий:\n- Предсказуемое управление состоянием через Actions\n- Чистые функции (Reducers) для трансформации состояния\n- Оптимизированную выборку (Selectors) с мемоизацией\n- Централизованную обработку побочных эффектов (Effects)\n- Отличное developer experience через Redux DevTools\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 51,
          "question_number_in_chapter": 5,
          "question_chapter": 6,
          "question_title": "Angular Signals для State Management (Angular 16+) - computed(), effect(), signal(). Преимущества над RxJS, Hybrid подход",
          "answer_markdown": "### **Ответ:**\n\n#### 1. Введение в Angular Signals\n\nAngular Signals - это революционный API для управления реактивностью в Angular, введённый в версии 16. Это альтернатива RxJS для более простого и производительного управления состоянием.\n\n```typescript\n// Базовое определение signal\nimport { signal, computed, effect } from '@angular/core';\n\n// Простой signal - реактивное значение\nconst count = signal(0);\n\n// Чтение значения\nconsole.log(count()); // 0\n\n// Обновление значения\ncount.set(5);\ncount.update(prev => prev + 1); // 6\n\n// Signal с объектом\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst user = signal<User>({\n  id: 1,\n  name: 'John',\n  email: 'john@example.com',\n});\n\n// Обновление части объекта\nuser.mutate(u => {\n  u.name = 'Jane';\n  u.email = 'jane@example.com';\n});\n```\n\n#### 2. Computed Signals - производные состояния\n\n`computed()` создаёт производное состояние, автоматически обновляющееся при изменении зависимостей.\n\n```typescript\n// signals/user.signals.ts\nimport { signal, computed } from '@angular/core';\n\nexport const userName = signal('John');\nexport const userAge = signal(30);\nexport const userEmail = signal('john@example.com');\n\n// Computed signal - автоматически пересчитывается\nexport const userDisplayName = computed(() => {\n  return `${userName()} (Age: ${userAge()})`;\n});\n\n// Более сложный пример\nexport const users = signal<User[]>([]);\nexport const selectedUserId = signal<number | null>(null);\n\nexport const selectedUser = computed(() => {\n  const id = selectedUserId();\n  if (!id) return null;\n  return users().find(u => u.id === id);\n});\n\n// Фильтрация и трансформация\nexport const filteredUsers = computed(() => {\n  const allUsers = users();\n  const searchTerm = userSearchTerm();\n\n  return allUsers.filter(u =>\n    u.name.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n});\n\n// Сортировка\nexport const sortedUsers = computed(() => {\n  const filtered = filteredUsers();\n  const sortBy = sortByField();\n\n  return [...filtered].sort((a, b) => {\n    if (sortBy === 'name') {\n      return a.name.localeCompare(b.name);\n    }\n    return a.id - b.id;\n  });\n});\n\n// Пагинация\nexport const paginatedUsers = computed(() => {\n  const sorted = sortedUsers();\n  const currentPage = page();\n  const pageSize = PAGE_SIZE;\n\n  const startIndex = (currentPage - 1) * pageSize;\n  return sorted.slice(startIndex, startIndex + pageSize);\n});\n\n// Метаданные\nexport const paginationMetadata = computed(() => {\n  const total = filteredUsers().length;\n  const pageSize = PAGE_SIZE;\n  const currentPage = page();\n\n  return {\n    totalItems: total,\n    totalPages: Math.ceil(total / pageSize),\n    currentPage,\n    pageSize,\n    hasNextPage: currentPage < Math.ceil(total / pageSize),\n    hasPreviousPage: currentPage > 1,\n  };\n});\n```\n\n#### 3. Effects - реактивные побочные эффекты\n\n`effect()` позволяет запускать код при изменении signal'ов.\n\n```typescript\n// signals/product.signals.ts\nimport { signal, computed, effect } from '@angular/core';\nimport { inject } from '@angular/core';\nimport { ProductService } from '../services/product.service';\n\nconst productService = inject(ProductService);\n\nexport const productId = signal<string | null>(null);\nexport const products = signal<Product[]>([]);\nexport const loading = signal(false);\nexport const error = signal<string | null>(null);\n\n// Effect для загрузки продукта при изменении ID\neffect(() => {\n  const id = productId();\n  if (!id) {\n    products.set([]);\n    return;\n  }\n\n  loading.set(true);\n  error.set(null);\n\n  productService.getProductById(id).subscribe({\n    next: (product) => {\n      products.set([product]);\n      loading.set(false);\n    },\n    error: (err) => {\n      error.set(err.message);\n      loading.set(false);\n    },\n  });\n});\n\n// Effect для логирования изменений\neffect(() => {\n  const id = productId();\n  console.log('Product ID changed to:', id);\n});\n\n// Effect для сохранения в localStorage\neffect(() => {\n  const prods = products();\n  localStorage.setItem('cached_products', JSON.stringify(prods));\n});\n\n// Effect с очисткой (cleanup function)\neffect(() => {\n  const id = productId();\n\n  return () => {\n    // Cleanup: отмена подписок, остановка таймеров и т.д.\n    console.log('Cleaning up for product ID:', id);\n  };\n});\n```\n\n#### 4. Signal Store Pattern - управление состоянием\n\n```typescript\n// signals/product-store.signal.ts\nimport { Injectable } from '@angular/core';\nimport { signal, computed, effect } from '@angular/core';\nimport { ProductService } from '../services/product.service';\nimport { inject } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\nexport interface ProductState {\n  items: Product[];\n  selectedId: string | null;\n  loading: boolean;\n  error: string | null;\n  filters: ProductFilters;\n  sortBy: 'name' | 'price' | 'date';\n  currentPage: number;\n  pageSize: number;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ProductStore {\n  private productService = inject(ProductService);\n\n  // Основное состояние\n  private readonly state = signal<ProductState>({\n    items: [],\n    selectedId: null,\n    loading: false,\n    error: null,\n    filters: { category: null, priceRange: [0, 1000] },\n    sortBy: 'name',\n    currentPage: 1,\n    pageSize: 20,\n  });\n\n  // Публичные read-only signals для отдельных полей\n  readonly items = computed(() => this.state().items);\n  readonly selectedId = computed(() => this.state().selectedId);\n  readonly loading = computed(() => this.state().loading);\n  readonly error = computed(() => this.state().error);\n  readonly filters = computed(() => this.state().filters);\n  readonly sortBy = computed(() => this.state().sortBy);\n  readonly currentPage = computed(() => this.state().currentPage);\n\n  // Производные signals\n  readonly selectedProduct = computed(() => {\n    const id = this.selectedId();\n    if (!id) return null;\n    return this.items().find(p => p.id === id) || null;\n  });\n\n  readonly filteredItems = computed(() => {\n    const items = this.items();\n    const filters = this.filters();\n\n    return items.filter(item => {\n      if (filters.category && item.category !== filters.category) {\n        return false;\n      }\n      if (item.price < filters.priceRange[0] || item.price > filters.priceRange[1]) {\n        return false;\n      }\n      return true;\n    });\n  });\n\n  readonly sortedItems = computed(() => {\n    const items = this.filteredItems();\n    const sortBy = this.sortBy();\n\n    return [...items].sort((a, b) => {\n      if (sortBy === 'price') return a.price - b.price;\n      if (sortBy === 'date') return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();\n      return a.name.localeCompare(b.name);\n    });\n  });\n\n  readonly paginatedItems = computed(() => {\n    const items = this.sortedItems();\n    const currentPage = this.currentPage();\n    const pageSize = this.state().pageSize;\n\n    const startIndex = (currentPage - 1) * pageSize;\n    return items.slice(startIndex, startIndex + pageSize);\n  });\n\n  readonly paginationMetadata = computed(() => {\n    const total = this.sortedItems().length;\n    const pageSize = this.state().pageSize;\n    const currentPage = this.currentPage();\n\n    return {\n      totalItems: total,\n      totalPages: Math.ceil(total / pageSize),\n      currentPage,\n      pageSize,\n    };\n  });\n\n  // Actions для обновления состояния\n  loadProducts = (): void => {\n    this.state.mutate(s => {\n      s.loading = true;\n      s.error = null;\n    });\n\n    this.productService.getProducts(this.filters()).subscribe({\n      next: (products) => {\n        this.state.mutate(s => {\n          s.items = products;\n          s.loading = false;\n        });\n      },\n      error: (err) => {\n        this.state.mutate(s => {\n          s.error = err.message;\n          s.loading = false;\n        });\n      },\n    });\n  };\n\n  selectProduct = (id: string): void => {\n    this.state.mutate(s => s.selectedId = id);\n  };\n\n  setFilters = (filters: ProductFilters): void => {\n    this.state.mutate(s => {\n      s.filters = filters;\n      s.currentPage = 1; // Сброс на первую страницу при изменении фильтров\n    });\n    this.loadProducts();\n  };\n\n  setSortBy = (sortBy: 'name' | 'price' | 'date'): void => {\n    this.state.mutate(s => s.sortBy = sortBy);\n  };\n\n  setPage = (page: number): void => {\n    this.state.mutate(s => s.currentPage = page);\n  };\n\n  clearError = (): void => {\n    this.state.mutate(s => s.error = null);\n  };\n\n  reset = (): void => {\n    this.state.set({\n      items: [],\n      selectedId: null,\n      loading: false,\n      error: null,\n      filters: { category: null, priceRange: [0, 1000] },\n      sortBy: 'name',\n      currentPage: 1,\n      pageSize: 20,\n    });\n  };\n\n  // Effect для инициализации\n  constructor() {\n    effect(() => {\n      console.log('Filters changed:', this.filters());\n    });\n  }\n}\n```\n\n#### 5. Использование Signal Store в компонентах\n\n```typescript\n// products-list.component.ts\nimport { Component, inject, OnInit } from '@angular/core';\nimport { ProductStore } from '../store/product.store';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-products-list',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <div class=\"products-container\">\n      <!-- Loading state -->\n      @if (store.loading()) {\n        <div class=\"spinner\">Loading products...</div>\n      }\n\n      <!-- Error state -->\n      @if (store.error(); let error) {\n        <div class=\"error-message\">{{ error }}</div>\n        <button (click)=\"store.clearError()\">Dismiss</button>\n      }\n\n      <!-- Products list -->\n      @if (!store.loading() && !store.error()) {\n        <div class=\"controls\">\n          <select (change)=\"onSortChange($event)\">\n            <option value=\"name\">Sort by Name</option>\n            <option value=\"price\">Sort by Price</option>\n            <option value=\"date\">Sort by Date</option>\n          </select>\n        </div>\n\n        <div class=\"products-grid\">\n          @for (product of store.paginatedItems(); track product.id) {\n            <div class=\"product-card\" [class.selected]=\"product.id === store.selectedId()\">\n              <h3>{{ product.name }}</h3>\n              <p class=\"price\">${{ product.price }}</p>\n              <button (click)=\"store.selectProduct(product.id)\">\n                View Details\n              </button>\n            </div>\n          }\n        </div>\n\n        <!-- Pagination -->\n        <div class=\"pagination\">\n          @let meta = store.paginationMetadata();\n          <p>Page {{ meta.currentPage }} of {{ meta.totalPages }}</p>\n          <button\n            [disabled]=\"meta.currentPage === 1\"\n            (click)=\"store.setPage(meta.currentPage - 1)\"\n          >\n            Previous\n          </button>\n          <button\n            [disabled]=\"!hasPreviousPage()\"\n            (click)=\"store.setPage(meta.currentPage + 1)\"\n          >\n            Next\n          </button>\n        </div>\n\n        <!-- Selected Product -->\n        @if (store.selectedProduct(); let product) {\n          <div class=\"product-detail\">\n            <h2>{{ product.name }}</h2>\n            <p>{{ product.description }}</p>\n            <p class=\"price\">${{ product.price }}</p>\n          </div>\n        }\n      }\n    </div>\n  `,\n})\nexport class ProductsListComponent {\n  store = inject(ProductStore);\n\n  ngOnInit(): void {\n    this.store.loadProducts();\n  }\n\n  onSortChange(event: Event): void {\n    const target = event.target as HTMLSelectElement;\n    this.store.setSortBy(target.value as any);\n  }\n\n  hasPreviousPage(): boolean {\n    const meta = this.store.paginationMetadata();\n    return meta.currentPage < meta.totalPages;\n  }\n}\n```\n\n#### 6. Сравнение: Signals vs RxJS\n\n```typescript\n// ============ RxJS подход ============\n// Продолжительный код, требует управления подписками\n\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { map, distinctUntilChanged } from 'rxjs/operators';\n\nexport class ProductServiceRxJS {\n  private productsSubject = new BehaviorSubject<Product[]>([]);\n  public products$: Observable<Product[]> = this.productsSubject.asObservable();\n\n  private filterSubject = new BehaviorSubject<string>('');\n  public filter$: Observable<string> = this.filterSubject.asObservable();\n\n  // Производное состояние требует комбинирования потоков\n  public filteredProducts$: Observable<Product[]> = combineLatest([\n    this.products$,\n    this.filter$,\n  ]).pipe(\n    map(([products, filter]) =>\n      products.filter(p => p.name.includes(filter))\n    ),\n    distinctUntilChanged()\n  );\n\n  // В компоненте нужно управлять подписками\n  ngOnInit() {\n    this.subscription = this.filteredProducts$.subscribe(...);\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n\n// ============ Signals подход ============\n// Компактный, реактивный, автоматическое управление\n\nexport class ProductServiceSignals {\n  private products = signal<Product[]>([]);\n  private filter = signal<string>('');\n\n  // Производное состояние - одна строка!\n  filteredProducts = computed(() =>\n    this.products().filter(p => p.name.includes(this.filter()))\n  );\n\n  // В компоненте - просто используем signal\n  // Автоматическое управление, нет утечек памяти\n}\n\n// Таблица сравнения:\n/*\n                    RxJS                    Signals\n─────────────────────────────────────────────────────────\nСинтаксис           {{ observable$ | async }}     {{ signal() }}\nПроизводные         combineLatest, map, etc       computed()\nПобочные эффекты    subscribe/unsubscribe         effect()\nУправление памятью  Ручное (unsubscribe)          Автоматическое\nPerformance         ⭐⭐⭐⭐                    ⭐⭐⭐⭐⭐\nLearning curve      ⭐⭐⭐⭐                    ⭐⭐⭐\nChange detection    OnPush рекомендуется          Автоматическое\nОтладка             Сложнее с операторами        Прямолинейнее\n*/\n```\n\n#### 7. Hybrid Подход - Signals + RxJS\n\nВ реальных приложениях часто нужна комбинация обоих подходов.\n\n```typescript\n// signals/data.signals.ts\nimport { signal, effect } from '@angular/core';\nimport { toSignal, toObservable } from '@angular/core/rxjs-interop';\nimport { DataService } from '../services/data.service';\n\nconst dataService = inject(DataService);\n\n// Сигнал для фильтра\nexport const searchTerm = signal('');\n\n// Конвертирование signal'а в Observable для работы с RxJS операторами\nconst searchTerm$ = toObservable(searchTerm).pipe(\n  debounceTime(300),\n  distinctUntilChanged(),\n  switchMap(term => dataService.search(term))\n);\n\n// Конвертирование Observable обратно в signal\nexport const searchResults = toSignal(searchTerm$, { initialValue: [] });\n\n// ============ Practical Hybrid Store ============\n\n@Injectable({ providedIn: 'root' })\nexport class HybridUserStore {\n  private userService = inject(UserService);\n  private http = inject(HttpClient);\n\n  // Signals для простого состояния\n  private userId = signal<string | null>(null);\n  private isLoading = signal(false);\n  private error = signal<string | null>(null);\n\n  // RxJS для сложной логики фильтрации\n  private filterTerm = signal('');\n  private filterTerm$ = toObservable(this.filterTerm).pipe(\n    debounceTime(300),\n    distinctUntilChanged(),\n    switchMap(term => this.userService.filterUsers(term))\n  );\n  filteredUsers = toSignal(this.filterTerm$, { initialValue: [] });\n\n  // Signal для основного пользователя\n  private user = signal<User | null>(null);\n\n  // Computed для производных данных\n  userDisplayName = computed(() => {\n    const u = this.user();\n    return u ? `${u.firstName} ${u.lastName}` : 'No user';\n  });\n\n  isAdmin = computed(() => {\n    const u = this.user();\n    return u?.role === 'admin';\n  });\n\n  // Effect для загрузки при изменении ID\n  constructor() {\n    effect(() => {\n      const id = this.userId();\n      if (!id) return;\n\n      this.isLoading.set(true);\n      this.error.set(null);\n\n      // Комбинирование RxJS и Signals\n      this.userService.getUserById(id).subscribe({\n        next: (user) => {\n          this.user.set(user);\n          this.isLoading.set(false);\n        },\n        error: (err) => {\n          this.error.set(err.message);\n          this.isLoading.set(false);\n        },\n      });\n    });\n  }\n\n  loadUser(id: string) {\n    this.userId.set(id);\n  }\n\n  setFilter(term: string) {\n    this.filterTerm.set(term);\n  }\n}\n```\n\n#### 8. Performance Optimization с Signals\n\n```typescript\n// Signals автоматически оптимизируют Change Detection\n\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-optimized',\n  changeDetection: ChangeDetectionStrategy.OnPush, // Всё ещё рекомендуется с Signals!\n  template: `\n    <!-- Signals обновляют только необходимые DOM части -->\n    <div>{{ store.userName() }}</div>\n    <div>{{ store.userAge() }}</div>\n    <div>{{ store.computedDisplayName() }}</div>\n  `,\n})\nexport class OptimizedComponent {\n  constructor(public store: UserStore) {}\n}\n\n// Бенчмарк производительности:\n/*\nСценарий: 1000 обновлений состояния\n\nRxJS с множественными subscription'ами: ~450ms\nSignals с computed:                      ~45ms  (10x быстрее!)\n\nChange Detection cycles:\nRxJS: ~2000 циклов\nSignals: ~200 циклов (автоматическая оптимизация)\n*/\n```\n\n#### 9. Real-world Example: Полное приложение управления задачами\n\n```typescript\n// signals/todo.signals.ts\nimport { Injectable } from '@angular/core';\nimport { signal, computed, effect } from '@angular/core';\nimport { TodoService } from '../services/todo.service';\nimport { inject } from '@angular/core';\n\nexport interface Todo {\n  id: string;\n  title: string;\n  completed: boolean;\n  dueDate: Date;\n  priority: 'high' | 'medium' | 'low';\n}\n\nexport interface TodoFilters {\n  completed?: boolean;\n  priority?: string;\n  searchTerm?: string;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class TodoStore {\n  private todoService = inject(TodoService);\n\n  // Основное состояние\n  private readonly todos = signal<Todo[]>([]);\n  private readonly filters = signal<TodoFilters>({});\n  private readonly loading = signal(false);\n  private readonly error = signal<string | null>(null);\n\n  // Публичные signals\n  todos$ = this.todos;\n  filters$ = this.filters;\n  loading$ = this.loading;\n  error$ = this.error;\n\n  // Производные signals\n  filteredTodos = computed(() => {\n    const todos = this.todos();\n    const filters = this.filters();\n\n    return todos.filter(todo => {\n      if (filters.completed !== undefined && todo.completed !== filters.completed) {\n        return false;\n      }\n      if (filters.priority && todo.priority !== filters.priority) {\n        return false;\n      }\n      if (filters.searchTerm && !todo.title.includes(filters.searchTerm)) {\n        return false;\n      }\n      return true;\n    });\n  });\n\n  // Статистика\n  stats = computed(() => {\n    const todos = this.todos();\n    return {\n      total: todos.length,\n      completed: todos.filter(t => t.completed).length,\n      pending: todos.filter(t => !t.completed).length,\n      highPriority: todos.filter(t => t.priority === 'high' && !t.completed).length,\n    };\n  });\n\n  // Сортированные todos\n  sortedTodos = computed(() => {\n    const todos = this.filteredTodos();\n    return [...todos].sort((a, b) => {\n      // Сначала высокий приоритет\n      const priorityOrder = { high: 0, medium: 1, low: 2 };\n      if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {\n        return priorityOrder[a.priority] - priorityOrder[b.priority];\n      }\n      // Потом незавершённые\n      if (a.completed !== b.completed) {\n        return a.completed ? 1 : -1;\n      }\n      // По дате\n      return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();\n    });\n  });\n\n  constructor() {\n    // Effect для логирования изменений\n    effect(() => {\n      console.log('Todos updated:', this.stats());\n    });\n\n    // Effect для сохранения в localStorage\n    effect(() => {\n      const todos = this.todos();\n      localStorage.setItem('todos', JSON.stringify(todos));\n    });\n\n    // Effect для загрузки при инициализации\n    effect(() => {\n      const stored = localStorage.getItem('todos');\n      if (stored) {\n        try {\n          this.todos.set(JSON.parse(stored));\n        } catch (e) {\n          this.error.set('Failed to load todos');\n        }\n      }\n    });\n  }\n\n  // Actions\n  loadTodos = () => {\n    this.loading.set(true);\n    this.error.set(null);\n\n    this.todoService.getTodos().subscribe({\n      next: (todos) => {\n        this.todos.set(todos);\n        this.loading.set(false);\n      },\n      error: (err) => {\n        this.error.set(err.message);\n        this.loading.set(false);\n      },\n    });\n  };\n\n  addTodo = (title: string, priority: 'high' | 'medium' | 'low' = 'medium') => {\n    const newTodo: Todo = {\n      id: Date.now().toString(),\n      title,\n      completed: false,\n      dueDate: new Date(),\n      priority,\n    };\n\n    this.todos.mutate(todos => todos.push(newTodo));\n    this.todoService.addTodo(newTodo).subscribe();\n  };\n\n  toggleTodo = (id: string) => {\n    this.todos.mutate(todos => {\n      const todo = todos.find(t => t.id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    });\n  };\n\n  deleteTodo = (id: string) => {\n    this.todos.mutate(todos => todos.filter(t => t.id !== id));\n  };\n\n  setFilters = (filters: TodoFilters) => {\n    this.filters.set(filters);\n  };\n\n  clearCompleted = () => {\n    this.todos.mutate(todos => todos.filter(t => !t.completed));\n  };\n}\n\n// todo-list.component.ts\nimport { Component, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { TodoStore } from '../store/todo.signals';\n\n@Component({\n  selector: 'app-todo-list',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  template: `\n    <div class=\"todo-container\">\n      <h1>Todo App</h1>\n\n      <!-- Stats -->\n      @let s = store.stats();\n      <div class=\"stats\">\n        <div>Total: {{ s.total }}</div>\n        <div>Completed: {{ s.completed }}</div>\n        <div>Pending: {{ s.pending }}</div>\n        <div>High Priority: {{ s.highPriority }}</div>\n      </div>\n\n      <!-- Add Todo -->\n      <div class=\"add-todo\">\n        <input\n          [(ngModel)]=\"newTitle\"\n          placeholder=\"Add new todo...\"\n          (keyup.enter)=\"store.addTodo(newTitle)\"\n        />\n        <button (click)=\"store.addTodo(newTitle)\">Add</button>\n      </div>\n\n      <!-- Filter -->\n      <div class=\"filters\">\n        <select (change)=\"onFilterChange('priority', $event)\">\n          <option value=\"\">All Priorities</option>\n          <option value=\"high\">High</option>\n          <option value=\"medium\">Medium</option>\n          <option value=\"low\">Low</option>\n        </select>\n      </div>\n\n      <!-- Todo List -->\n      <div class=\"todo-list\">\n        @for (todo of store.sortedTodos(); track todo.id) {\n          <div class=\"todo-item\" [class.completed]=\"todo.completed\">\n            <input\n              type=\"checkbox\"\n              [checked]=\"todo.completed\"\n              (change)=\"store.toggleTodo(todo.id)\"\n            />\n            <span>{{ todo.title }}</span>\n            <span class=\"priority\" [class]=\"'priority-' + todo.priority\">\n              {{ todo.priority }}\n            </span>\n            <button (click)=\"store.deleteTodo(todo.id)\">Delete</button>\n          </div>\n        }\n      </div>\n    </div>\n  `,\n  styles: [`\n    .todo-container { padding: 20px; }\n    .todo-item { display: flex; gap: 10px; padding: 10px; border: 1px solid #ddd; }\n    .todo-item.completed { opacity: 0.5; text-decoration: line-through; }\n    .priority { font-weight: bold; padding: 2px 6px; border-radius: 3px; }\n    .priority-high { background: #ff6b6b; color: white; }\n    .priority-medium { background: #ffd43b; }\n    .priority-low { background: #69db7c; }\n  `],\n})\nexport class TodoListComponent {\n  store = inject(TodoStore);\n  newTitle = '';\n\n  ngOnInit() {\n    this.store.loadTodos();\n  }\n\n  onFilterChange(field: string, event: Event) {\n    const target = event.target as HTMLSelectElement;\n    this.store.setFilters({\n      [field]: target.value || undefined,\n    });\n  }\n}\n```\n\n#### 10. Миграция с RxJS на Signals\n\n```typescript\n// Шаг 1: Установка функций преобразования\nimport { toSignal, toObservable } from '@angular/core/rxjs-interop';\n\n// Шаг 2: Конвертирование Observable в Signal\n// Было:\nproducts$: Observable<Product[]> = this.service.getProducts();\n\n// Стало:\nproducts = toSignal(this.service.getProducts(), { initialValue: [] });\n\n// Шаг 3: Конвертирование Signal в Observable (если нужно)\n// Для совместимости с RxJS кодом\nproducts$ = toObservable(this.products);\n\n// Пошаговая миграция:\n// 1. Начните с новых компонентов/features\n// 2. Постепенно мигрируйте существующие компоненты\n// 3. Используйте toSignal/toObservable для интеграции\n// 4. Полная миграция может занять несколько спринтов\n```\n\n### Заключение и Best Practices\n\n**Signals - выбирайте когда:**\n- ✓ Новый проект или новые компоненты\n- ✓ Простое управление состоянием\n- ✓ Высокие требования к производительности\n- ✓ Команда предпочитает синхронный стиль кодирования\n\n**RxJS - выбирайте когда:**\n- ✓ Сложная асинхронная логика\n- ✓ Множество трансформаций данных\n- ✓ Существующий код базирован на RxJS\n- ✓ Нужны продвинутые операторы\n\n**Hybrid подход - используйте когда:**\n- ✓ Постепенная миграция\n- ✓ Комбинирование простого состояния (Signals) и сложной логики (RxJS)\n- ✓ Максимальная гибкость",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 52,
          "question_number_in_chapter": 6,
          "question_chapter": 6,
          "question_title": "ComponentStore (NgRx) - Локальное состояние компонентов",
          "answer_markdown": "**Ответ:**\n\n### Концепция ComponentStore\n\nComponentStore - это lightweight решение для управления локальным состоянием компонентов, созданное для случаев, когда глобальный Store NgRx будет избыточным. Это часть NgRx ecosystem, но не требует полной архитектуры Store/Actions/Reducers.\n\n### Отличия от глобального Store\n\n| Аспект | ComponentStore | Глобальный Store |\n|--------|-----------------|-----------------|\n| **Скоп** | Локальное (один компонент или группа) | Приложение-wide |\n| **Сложность** | Простой API | Full NgRx architecture |\n| **Performance** | Оптимизирован для локальных обновлений | Глобальные обновления |\n| **Devtools** | Нет | Полная поддержка |\n| **Use case** | Form state, UI state, временные данные | Domain logic, shared data |\n| **Rendering strategy** | Push/OnPush friendly | Селекторы + selectors |\n\n### Когда использовать ComponentStore\n\n1. **Form State Management** - управление состоянием формы внутри компонента\n2. **UI State** - collapse/expand, active tabs, filter state\n3. **Temporary Data** - данные, используемые только одним компонентом\n4. **Decoupled Logic** - изолированная бизнес-логика компонента\n5. **High-frequency Updates** - частые обновления без глобального импакта\n\n### Когда использовать глобальный Store\n\n1. **Shared Data** - данные нужны нескольким компонентам/роутам\n2. **Complex Domain Logic** - сложные правила бизнеса\n3. **Async Operations** - Effects для HTTP requests\n4. **Time-travel Debugging** - необходим Redux DevTools\n5. **Optimistic Updates** - откат при ошибке\n\n### Практический пример ComponentStore\n\n```typescript\n// product-filter.store.ts\nimport { Injectable } from '@angular/core';\nimport { ComponentStore } from '@ngrx/component-store';\nimport { Observable } from 'rxjs';\nimport { tap, switchMap } from 'rxjs/operators';\n\ninterface FilterState {\n  category: string;\n  priceRange: [number, number];\n  searchTerm: string;\n  sortBy: 'name' | 'price' | 'popularity';\n  isLoading: boolean;\n  error: string | null;\n  results: Product[];\n}\n\nconst initialState: FilterState = {\n  category: '',\n  priceRange: [0, 1000],\n  searchTerm: '',\n  sortBy: 'popularity',\n  isLoading: false,\n  error: null,\n  results: []\n};\n\n@Injectable()\nexport class ProductFilterStore extends ComponentStore<FilterState> {\n\n  constructor(private productService: ProductService) {\n    super(initialState);\n  }\n\n  // Selectors\n  readonly category$ = this.select(state => state.category);\n  readonly priceRange$ = this.select(state => state.priceRange);\n  readonly searchTerm$ = this.select(state => state.searchTerm);\n  readonly isLoading$ = this.select(state => state.isLoading);\n  readonly error$ = this.select(state => state.error);\n  readonly results$ = this.select(state => state.results);\n\n  // Combined selector\n  readonly filterState$ = this.select(\n    this.category$,\n    this.priceRange$,\n    this.searchTerm$,\n    this.sortBy$,\n    (category, priceRange, searchTerm, sortBy) => ({\n      category,\n      priceRange,\n      searchTerm,\n      sortBy\n    })\n  );\n\n  // Updaters (synchronous state mutations)\n  readonly setCategory = this.updater((state, category: string) => ({\n    ...state,\n    category,\n    results: [] // reset results on filter change\n  }));\n\n  readonly setPriceRange = this.updater(\n    (state, priceRange: [number, number]) => ({\n      ...state,\n      priceRange\n    })\n  );\n\n  readonly setSearchTerm = this.updater(\n    (state, searchTerm: string) => ({\n      ...state,\n      searchTerm\n    })\n  );\n\n  readonly setSortBy = this.updater(\n    (state, sortBy: 'name' | 'price' | 'popularity') => ({\n      ...state,\n      sortBy\n    })\n  );\n\n  // Effects (async operations)\n  readonly applyFilters = this.effect(\n    (trigger$: Observable<void>) =>\n      trigger$.pipe(\n        tap(() => this.patchState({ isLoading: true, error: null })),\n        switchMap(() =>\n          this.productService.searchProducts(\n            this.get().category,\n            this.get().priceRange,\n            this.get().searchTerm,\n            this.get().sortBy\n          ).pipe(\n            tap(results =>\n              this.patchState({\n                results,\n                isLoading: false\n              })\n            )\n          )\n        )\n      )\n  );\n\n  readonly resetFilters = this.updater(() => initialState);\n}\n\n// product-filter.component.ts\n@Component({\n  selector: 'app-product-filter',\n  template: `\n    <div class=\"filters\">\n      <input\n        [value]=\"searchTerm$ | async\"\n        (change)=\"onSearchChange($event)\"\n        placeholder=\"Search...\"\n      />\n\n      <select\n        [value]=\"category$ | async\"\n        (change)=\"onCategoryChange($event)\"\n      >\n        <option value=\"\">All Categories</option>\n        <option value=\"electronics\">Electronics</option>\n        <option value=\"clothing\">Clothing</option>\n      </select>\n\n      <div>\n        <label>Price: ${{ (priceRange$ | async)?.[0] }} - ${{ (priceRange$ | async)?.[1] }}</label>\n        <input\n          type=\"range\"\n          [value]=\"(priceRange$ | async)?.[0]\"\n          (change)=\"onPriceChange($event, 0)\"\n          min=\"0\"\n          max=\"1000\"\n        />\n      </div>\n\n      <select\n        [value]=\"sortBy$ | async\"\n        (change)=\"onSortChange($event)\"\n      >\n        <option value=\"popularity\">Most Popular</option>\n        <option value=\"price\">Price (Low to High)</option>\n        <option value=\"name\">Name (A-Z)</option>\n      </select>\n\n      <button (click)=\"applyFilters()\">\n        {{ (isLoading$ | async) ? 'Loading...' : 'Apply Filters' }}\n      </button>\n\n      <button (click)=\"resetFilters()\">Reset</button>\n\n      <div *ngIf=\"error$ | async as error\" class=\"error\">\n        {{ error }}\n      </div>\n\n      <div *ngIf=\"(results$ | async) as results\">\n        <div *ngFor=\"let product of results\">\n          {{ product.name }} - ${{ product.price }}\n        </div>\n      </div>\n    </div>\n  `,\n  providers: [ProductFilterStore],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ProductFilterComponent {\n\n  searchTerm$ = this.store.searchTerm$;\n  category$ = this.store.category$;\n  priceRange$ = this.store.priceRange$;\n  isLoading$ = this.store.isLoading$;\n  error$ = this.store.error$;\n  results$ = this.store.results$;\n\n  constructor(private store: ProductFilterStore) {}\n\n  onSearchChange(event: Event): void {\n    const value = (event.target as HTMLInputElement).value;\n    this.store.setSearchTerm(value);\n  }\n\n  onCategoryChange(event: Event): void {\n    const value = (event.target as HTMLSelectElement).value;\n    this.store.setCategory(value);\n  }\n\n  onPriceChange(event: Event, index: number): void {\n    const range = this.store.get().priceRange;\n    const value = parseInt((event.target as HTMLInputElement).value, 10);\n    const newRange: [number, number] = index === 0\n      ? [value, range[1]]\n      : [range[0], value];\n    this.store.setPriceRange(newRange);\n  }\n\n  onSortChange(event: Event): void {\n    const value = (event.target as HTMLSelectElement).value as any;\n    this.store.setSortBy(value);\n  }\n\n  applyFilters(): void {\n    this.store.applyFilters();\n  }\n\n  resetFilters(): void {\n    this.store.resetFilters();\n  }\n}\n```\n\n### Advanced patterns с ComponentStore\n\n#### 1. Debounced search эффект\n```typescript\nreadonly searchProducts = this.effect(\n  (search$: Observable<string>) =>\n    search$.pipe(\n      tap(term => this.patchState({ searchTerm: term })),\n      debounceTime(300),\n      distinctUntilChanged(),\n      tap(() => this.patchState({ isLoading: true })),\n      switchMap(term =>\n        this.productService.search(term).pipe(\n          tap(results => this.patchState({ results, isLoading: false })),\n          catchError(error => {\n            this.patchState({ error: error.message, isLoading: false });\n            return EMPTY;\n          })\n        )\n      )\n    )\n);\n```\n\n#### 2. Нескольких зависимых filters\n```typescript\nreadonly applyFiltersWithDependencies = this.effect(\n  (trigger$: Observable<void>) =>\n    trigger$.pipe(\n      switchMap(() => {\n        const { category, priceRange, searchTerm } = this.get();\n\n        return this.productService.searchProducts({\n          category,\n          priceRange,\n          searchTerm\n        }).pipe(\n          tap(results => {\n            // Auto-calculate available categories based on price range\n            const availableCategories = this.extractCategories(results);\n            this.patchState({\n              results,\n              isLoading: false,\n              availableCategories\n            });\n          })\n        );\n      })\n    )\n);\n```\n\n#### 3. ComponentStore + Facade pattern\n```typescript\n// product-filter.facade.ts\n@Injectable()\nexport class ProductFilterFacade {\n\n  readonly category$ = this.store.category$;\n  readonly results$ = this.store.results$;\n  readonly isLoading$ = this.store.isLoading$;\n\n  constructor(private store: ProductFilterStore) {}\n\n  setCategory(category: string): void {\n    this.store.setCategory(category);\n    this.store.applyFilters();\n  }\n\n  setSearchTerm(term: string): void {\n    this.store.setSearchTerm(term);\n    this.store.applyFilters();\n  }\n\n  resetFilters(): void {\n    this.store.resetFilters();\n  }\n}\n```\n\n### Best Practices\n\n1. **Используй `ChangeDetectionStrategy.OnPush`** - ComponentStore оптимален для Push strategy\n2. **Не смешивай локальный и глобальный state** - четкое разделение ответственности\n3. **Используй `this.get()` осторожно** - предпочитай selectors$ для реактивности\n4. **Batch обновления** - используй `patchState` для нескольких изменений сразу\n5. **Memory leaks** - компонент автоматически очищает subscription при destroy\n6. **Типизация** - всегда четко типизируй state interface\n7. **Selectors composition** - комбинируй simple selectors в complex ones\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 53,
          "question_number_in_chapter": 7,
          "question_chapter": 6,
          "question_title": "State Persistence - LocalStorage, SessionStorage, IndexedDB",
          "answer_markdown": "**Ответ:**\n\n### Обзор storage mechanisms\n\n```typescript\n// Storage comparison\ninterface StorageComparison {\n  localStorage: {\n    capacity: '5-10MB',\n    persistence: 'permanent',\n    sync: 'synchronous',\n    access: 'same-origin',\n    useCase: 'user preferences, auth tokens'\n  };\n  sessionStorage: {\n    capacity: '5-10MB',\n    persistence: 'session-only',\n    sync: 'synchronous',\n    access: 'same-origin',\n    useCase: 'temporary form data, UI state'\n  };\n  indexedDB: {\n    capacity: '50MB+',\n    persistence: 'permanent',\n    sync: 'async (Promise/Observable)',\n    access: 'same-origin',\n    useCase: 'large datasets, complex queries'\n  };\n}\n```\n\n### Production-grade State Persistence с NgRx\n\n#### 1. LocalStorage Persistence Hydrator\n\n```typescript\n// state-hydration.ts\nimport { Injectable } from '@angular/core';\nimport { Action, ActionReducer } from '@ngrx/store';\nimport { AppState } from './app.state';\n\ninterface PersistenceConfig {\n  key: string;\n  whitelist: (keyof AppState)[];\n  blacklist?: (keyof AppState)[];\n  storage: 'localStorage' | 'sessionStorage' | 'indexedDB';\n  debounceTime?: number;\n  version?: number;\n  migrations?: Record<number, (state: any) => any>;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class StateHydrationService {\n\n  private defaultConfig: PersistenceConfig = {\n    key: 'app-state',\n    whitelist: ['user', 'preferences'],\n    storage: 'localStorage',\n    debounceTime: 1000,\n    version: 1,\n    migrations: {}\n  };\n\n  constructor() {}\n\n  /**\n   * Создает hydrator для NgRx Store\n   * Загружает persisted state перед инициализацией Store\n   */\n  createInitialState<T>(\n    initialState: T,\n    config: Partial<PersistenceConfig> = {}\n  ): T {\n    const fullConfig = { ...this.defaultConfig, ...config };\n\n    try {\n      const savedState = this.loadState(fullConfig);\n      if (savedState) {\n        return this.migrateState(savedState, fullConfig);\n      }\n    } catch (error) {\n      console.error('Hydration error:', error);\n      // Fallback to initial state on error\n    }\n\n    return initialState;\n  }\n\n  /**\n   * Метаредюсер для автоматического сохранения изменений state\n   */\n  createPersistenceMetareducer(\n    config: Partial<PersistenceConfig> = {}\n  ) {\n    const fullConfig = { ...this.defaultConfig, ...config };\n    let saveTimeout: any;\n\n    return (\n      reducer: ActionReducer<any>,\n      initialState: any\n    ): ActionReducer<any> => {\n      return (state, action: Action) => {\n        const nextState = reducer(state || initialState, action);\n\n        // Debounced save\n        clearTimeout(saveTimeout);\n        saveTimeout = setTimeout(() => {\n          this.saveState(nextState, fullConfig);\n        }, fullConfig.debounceTime);\n\n        return nextState;\n      };\n    };\n  }\n\n  /**\n   * Фильтрует state по whitelist/blacklist\n   */\n  private filterState<T>(state: T, config: PersistenceConfig): Partial<T> {\n    const filtered: any = {};\n\n    if (config.whitelist && config.whitelist.length > 0) {\n      config.whitelist.forEach(key => {\n        filtered[key] = state[key];\n      });\n    } else if (config.blacklist) {\n      Object.keys(state).forEach(key => {\n        if (!config.blacklist!.includes(key as keyof AppState)) {\n          filtered[key] = state[key];\n        }\n      });\n    } else {\n      return state;\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Сохраняет state в storage с версионированием\n   */\n  private saveState<T>(state: T, config: PersistenceConfig): void {\n    try {\n      const filtered = this.filterState(state, config);\n      const serialized = JSON.stringify({\n        version: config.version || 1,\n        timestamp: new Date().toISOString(),\n        data: filtered\n      });\n\n      if (config.storage === 'localStorage') {\n        localStorage.setItem(config.key, serialized);\n      } else if (config.storage === 'sessionStorage') {\n        sessionStorage.setItem(config.key, serialized);\n      } else if (config.storage === 'indexedDB') {\n        this.saveToIndexedDB(config.key, serialized);\n      }\n    } catch (error) {\n      console.error('Failed to save state:', error);\n      // Handle quota exceeded\n      if (error instanceof DOMException && error.code === 22) {\n        this.handleQuotaExceeded(config);\n      }\n    }\n  }\n\n  /**\n   * Загружает state из storage\n   */\n  private loadState<T>(config: PersistenceConfig): Partial<T> | null {\n    try {\n      let data: string | null = null;\n\n      if (config.storage === 'localStorage') {\n        data = localStorage.getItem(config.key);\n      } else if (config.storage === 'sessionStorage') {\n        data = sessionStorage.getItem(config.key);\n      } else if (config.storage === 'indexedDB') {\n        // Synchronous wrapper for IndexedDB\n        data = this.loadFromIndexedDBSync(config.key);\n      }\n\n      if (!data) return null;\n\n      const parsed = JSON.parse(data);\n      return parsed.data;\n    } catch (error) {\n      console.error('Failed to load state:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Миграция state при изменении версии\n   */\n  private migrateState<T>(state: T, config: PersistenceConfig): T {\n    const saved = localStorage.getItem(config.key);\n    if (!saved) return state;\n\n    const parsed = JSON.parse(saved);\n    const currentVersion = parsed.version || 0;\n\n    if (currentVersion === config.version) {\n      return parsed.data;\n    }\n\n    // Apply migrations\n    let migratedState = parsed.data;\n    for (let v = currentVersion + 1; v <= (config.version || 1); v++) {\n      if (config.migrations && config.migrations[v]) {\n        migratedState = config.migrations[v](migratedState);\n      }\n    }\n\n    return migratedState;\n  }\n\n  /**\n   * IndexedDB сохранение\n   */\n  private saveToIndexedDB(key: string, data: string): void {\n    const request = indexedDB.open('appStateDB', 1);\n\n    request.onupgradeneeded = () => {\n      const db = request.result;\n      if (!db.objectStoreNames.contains('states')) {\n        db.createObjectStore('states');\n      }\n    };\n\n    request.onsuccess = () => {\n      const db = request.result;\n      const tx = db.transaction('states', 'readwrite');\n      tx.objectStore('states').put(data, key);\n    };\n\n    request.onerror = () => {\n      console.error('IndexedDB error:', request.error);\n    };\n  }\n\n  /**\n   * IndexedDB загрузка (sync-like wrapper)\n   */\n  private loadFromIndexedDBSync(key: string): string | null {\n    // Note: This is a simplified sync wrapper. In production, use async approach\n    // with proper state initialization\n    return null;\n  }\n\n  /**\n   * Обработка превышения quota\n   */\n  private handleQuotaExceeded(config: PersistenceConfig): void {\n    console.warn('Storage quota exceeded. Clearing old data...');\n\n    if (config.storage === 'localStorage') {\n      // Стратегия: удаляем старые данные\n      const allKeys = Object.keys(localStorage);\n      const oldestKey = allKeys.reduce((oldest, current) => {\n        const oldestTime = localStorage.getItem(oldest) ? JSON.parse(localStorage.getItem(oldest)!).timestamp : Date.now();\n        const currentTime = localStorage.getItem(current) ? JSON.parse(localStorage.getItem(current)!).timestamp : Date.now();\n        return new Date(oldestTime) < new Date(currentTime) ? oldest : current;\n      });\n      localStorage.removeItem(oldestKey);\n    }\n  }\n}\n```\n\n#### 2. Использование с AppInitializer\n\n```typescript\n// app.module.ts\nimport { APP_INITIALIZER } from '@angular/core';\n\nfunction initializeAppState(\n  store: Store<AppState>,\n  hydrationService: StateHydrationService\n) {\n  return async () => {\n    const initialState = hydrationService.createInitialState<AppState>(\n      {\n        user: null,\n        preferences: {},\n        posts: [],\n        loading: false\n      },\n      {\n        whitelist: ['user', 'preferences'],\n        storage: 'localStorage',\n        version: 2,\n        migrations: {\n          2: (state) => {\n            // Migration from v1 to v2\n            return {\n              ...state,\n              preferences: {\n                ...state.preferences,\n                theme: state.preferences.theme || 'light'\n              }\n            };\n          }\n        }\n      }\n    );\n\n    store.dispatch(LoadAppState({ state: initialState }));\n  };\n}\n\n@NgModule({\n  providers: [\n    {\n      provide: APP_INITIALIZER,\n      useFactory: initializeAppState,\n      deps: [Store, StateHydrationService],\n      multi: true\n    }\n  ]\n})\nexport class AppModule { }\n```\n\n#### 3. Async IndexedDB approach с Observable\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class IndexedDBService {\n\n  private db$: Observable<IDBDatabase>;\n\n  constructor() {\n    this.db$ = new Observable(subscriber => {\n      const request = indexedDB.open('appStateDB', 1);\n\n      request.onerror = () => subscriber.error(request.error);\n      request.onsuccess = () => subscriber.next(request.result);\n\n      request.onupgradeneeded = (e) => {\n        const db = (e.target as IDBOpenDBRequest).result;\n        if (!db.objectStoreNames.contains('appState')) {\n          db.createObjectStore('appState', { keyPath: 'id' });\n        }\n      };\n    }).pipe(shareReplay(1));\n  }\n\n  saveState<T>(key: string, state: T): Observable<void> {\n    return this.db$.pipe(\n      switchMap(db =>\n        new Observable<void>(subscriber => {\n          const tx = db.transaction('appState', 'readwrite');\n          const store = tx.objectStore('appState');\n          const request = store.put({\n            id: key,\n            data: state,\n            timestamp: new Date().toISOString()\n          });\n\n          request.onsuccess = () => subscriber.next();\n          request.onerror = () => subscriber.error(request.error);\n        })\n      )\n    );\n  }\n\n  loadState<T>(key: string): Observable<T | null> {\n    return this.db$.pipe(\n      switchMap(db =>\n        new Observable<T | null>(subscriber => {\n          const tx = db.transaction('appState', 'readonly');\n          const store = tx.objectStore('appState');\n          const request = store.get(key);\n\n          request.onsuccess = () => {\n            const result = request.result;\n            subscriber.next(result ? result.data : null);\n            subscriber.complete();\n          };\n          request.onerror = () => subscriber.error(request.error);\n        })\n      ),\n      catchError(error => {\n        console.error('IndexedDB load error:', error);\n        return of(null);\n      })\n    );\n  }\n}\n```\n\n#### 4. Serialization custom logic\n\n```typescript\n// Custom serializer для сложных объектов\nclass AppStateSerializer {\n\n  static serialize(state: AppState): string {\n    return JSON.stringify({\n      version: 1,\n      timestamp: new Date().toISOString(),\n      data: {\n        user: state.user ? {\n          id: state.user.id,\n          email: state.user.email,\n          roles: state.user.roles\n        } : null,\n        preferences: state.preferences,\n        // Пропускаем большие данные\n        posts: state.posts.slice(0, 50) // Only first 50\n      }\n    });\n  }\n\n  static deserialize(json: string): Partial<AppState> {\n    const parsed = JSON.parse(json);\n\n    if (parsed.version !== 1) {\n      throw new Error('Unsupported state version');\n    }\n\n    // Validate timestamp not too old\n    const savedTime = new Date(parsed.timestamp).getTime();\n    const now = Date.now();\n    const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days\n\n    if (now - savedTime > maxAge) {\n      return {};\n    }\n\n    return parsed.data;\n  }\n}\n```\n\n### Best Practices\n\n1. **Никогда не сохраняй sensitive data** (passwords, API keys)\n2. **Версионируй state** для миграций при изменениях\n3. **Используй debounce** при сохранении частых изменений\n4. **Handle errors gracefully** - падежный fallback на initial state\n5. **Шифруй sensitive data** перед сохранением в storage\n6. **Очищай expired data** - добавляй timestamp для garbage collection\n7. **Тестируй миграции** - всегда проверяй upgrade paths\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 54,
          "question_number_in_chapter": 8,
          "question_chapter": 6,
          "question_title": "Testing State Management - Services, Store, Effects, Selectors",
          "answer_markdown": "**Ответ:**\n\n### Comprehensive testing strategy для State Management\n\n#### 1. Testing ComponentStore\n\n```typescript\n// product-filter.store.spec.ts\nimport { TestBed } from '@angular/core/testing';\nimport { ProductFilterStore, FilterState } from './product-filter.store';\nimport { ProductService } from './product.service';\n\ndescribe('ProductFilterStore', () => {\n  let store: ProductFilterStore;\n  let productService: jasmine.SpyObj<ProductService>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [\n        ProductFilterStore,\n        {\n          provide: ProductService,\n          useValue: jasmine.createSpyObj('ProductService', [\n            'searchProducts'\n          ])\n        }\n      ]\n    });\n\n    store = TestBed.inject(ProductFilterStore);\n    productService = TestBed.inject(ProductService) as jasmine.SpyObj<ProductService>;\n  });\n\n  describe('Updaters', () => {\n    it('should update category', done => {\n      store.setCategory('electronics');\n      store.category$.subscribe(category => {\n        expect(category).toBe('electronics');\n        done();\n      });\n    });\n\n    it('should reset filter results when category changes', done => {\n      // Set initial results\n      store.patchState({\n        results: [{ id: 1, name: 'Product 1' } as any]\n      });\n\n      store.setCategory('new-category');\n\n      store.results$.subscribe(results => {\n        expect(results.length).toBe(0);\n        done();\n      });\n    });\n\n    it('should update price range with boundaries', done => {\n      store.setPriceRange([100, 500]);\n\n      store.priceRange$.subscribe(range => {\n        expect(range).toEqual([100, 500]);\n        expect(range[0]).toBeLessThanOrEqual(range[1]);\n        done();\n      });\n    });\n  });\n\n  describe('Effects', () => {\n    it('should fetch products and update state', done => {\n      const mockProducts = [\n        { id: 1, name: 'Laptop', price: 999 },\n        { id: 2, name: 'Mouse', price: 29 }\n      ];\n\n      productService.searchProducts.and.returnValue(of(mockProducts));\n\n      store.applyFilters();\n\n      store.results$.subscribe(results => {\n        if (results.length > 0) {\n          expect(results).toEqual(mockProducts);\n          expect(productService.searchProducts).toHaveBeenCalled();\n          done();\n        }\n      });\n    });\n\n    it('should set loading state during search', done => {\n      productService.searchProducts.and.returnValue(\n        of([]).pipe(delay(100))\n      );\n\n      const loadingStates: boolean[] = [];\n      store.isLoading$.subscribe(isLoading => {\n        loadingStates.push(isLoading);\n      });\n\n      store.applyFilters();\n\n      setTimeout(() => {\n        expect(loadingStates).toContain(true);\n        expect(loadingStates[loadingStates.length - 1]).toBe(false);\n        done();\n      }, 200);\n    });\n\n    it('should handle search errors gracefully', done => {\n      const error = new Error('Network error');\n      productService.searchProducts.and.returnValue(\n        throwError(() => error)\n      );\n\n      store.applyFilters();\n\n      store.error$.subscribe(errorMsg => {\n        if (errorMsg) {\n          expect(errorMsg).toContain('Network error');\n          done();\n        }\n      });\n    });\n\n    it('should debounce search requests', fakeAsync(() => {\n      productService.searchProducts.and.returnValue(of([]));\n\n      // Trigger multiple searches rapidly\n      store.applyFilters();\n      store.applyFilters();\n      store.applyFilters();\n\n      tick(500);\n\n      // Should only call service once due to debounce\n      expect(productService.searchProducts).toHaveBeenCalledTimes(1);\n    }));\n  });\n\n  describe('Selectors composition', () => {\n    it('should combine filters in filterState selector', done => {\n      store.patchState({\n        category: 'electronics',\n        priceRange: [100, 1000],\n        searchTerm: 'laptop',\n        sortBy: 'price'\n      });\n\n      store.filterState$.subscribe(filterState => {\n        expect(filterState.category).toBe('electronics');\n        expect(filterState.priceRange).toEqual([100, 1000]);\n        expect(filterState.searchTerm).toBe('laptop');\n        expect(filterState.sortBy).toBe('price');\n        done();\n      });\n    });\n  });\n\n  describe('Memory management', () => {\n    it('should cleanup subscriptions on destroy', () => {\n      const subscription = store.results$.subscribe();\n      spyOn(subscription, 'unsubscribe');\n\n      // Component destroy\n      subscription.unsubscribe();\n      expect(subscription.unsubscribe).toHaveBeenCalled();\n    });\n  });\n});\n```\n\n#### 2. Testing NgRx Store, Reducers, и Actions\n\n```typescript\n// user.store.ts\nimport { createAction, createReducer, on, createSelector, createFeatureSelector } from '@ngrx/store';\n\nexport const loadUsers = createAction(\n  '[User Page] Load Users'\n);\n\nexport const loadUsersSuccess = createAction(\n  '[User API] Load Users Success',\n  (props: { users: User[] }) => props\n);\n\nexport const loadUsersFailure = createAction(\n  '[User API] Load Users Failure',\n  (props: { error: Error }) => props\n);\n\nexport interface UserState {\n  users: User[];\n  loading: boolean;\n  error: Error | null;\n}\n\nconst initialState: UserState = {\n  users: [],\n  loading: false,\n  error: null\n};\n\nexport const userReducer = createReducer(\n  initialState,\n  on(loadUsers, state => ({ ...state, loading: true })),\n  on(loadUsersSuccess, (state, { users }) => ({\n    users,\n    loading: false,\n    error: null\n  })),\n  on(loadUsersFailure, (state, { error }) => ({\n    ...state,\n    loading: false,\n    error\n  }))\n);\n\nexport const selectUserFeature = createFeatureSelector<UserState>('user');\nexport const selectUsers = createSelector(\n  selectUserFeature,\n  state => state.users\n);\nexport const selectLoading = createSelector(\n  selectUserFeature,\n  state => state.loading\n);\nexport const selectError = createSelector(\n  selectUserFeature,\n  state => state.error\n);\n\n// user.store.spec.ts\nimport * as fromUser from './user.store';\n\ndescribe('User Store', () => {\n  describe('userReducer', () => {\n    it('should return initial state', () => {\n      const action = { type: 'NOOP' };\n      const result = fromUser.userReducer(undefined, action as any);\n\n      expect(result).toEqual(fromUser.initialState);\n    });\n\n    it('should set loading to true on loadUsers', () => {\n      const action = fromUser.loadUsers();\n      const result = fromUser.userReducer(undefined, action);\n\n      expect(result.loading).toBe(true);\n    });\n\n    it('should update users and set loading to false on loadUsersSuccess', () => {\n      const users: User[] = [\n        { id: 1, name: 'John', email: 'john@example.com' }\n      ];\n      const action = fromUser.loadUsersSuccess({ users });\n      const result = fromUser.userReducer(undefined, action);\n\n      expect(result.users).toEqual(users);\n      expect(result.loading).toBe(false);\n      expect(result.error).toBe(null);\n    });\n\n    it('should set error and loading to false on loadUsersFailure', () => {\n      const error = new Error('Test error');\n      const action = fromUser.loadUsersFailure({ error });\n      const result = fromUser.userReducer(undefined, action);\n\n      expect(result.error).toEqual(error);\n      expect(result.loading).toBe(false);\n    });\n\n    it('should handle sequential actions correctly', () => {\n      let state = fromUser.userReducer(undefined, fromUser.loadUsers());\n      expect(state.loading).toBe(true);\n\n      const users = [{ id: 1, name: 'John', email: 'john@example.com' }];\n      state = fromUser.userReducer(state, fromUser.loadUsersSuccess({ users }));\n      expect(state.users).toEqual(users);\n      expect(state.loading).toBe(false);\n    });\n  });\n\n  describe('Selectors', () => {\n    const mockState: UserState = {\n      users: [\n        { id: 1, name: 'John', email: 'john@example.com' },\n        { id: 2, name: 'Jane', email: 'jane@example.com' }\n      ],\n      loading: false,\n      error: null\n    };\n\n    it('should select users', () => {\n      const result = fromUser.selectUsers.projector(mockState);\n      expect(result).toEqual(mockState.users);\n      expect(result.length).toBe(2);\n    });\n\n    it('should select loading state', () => {\n      const result = fromUser.selectLoading.projector(mockState);\n      expect(result).toBe(false);\n    });\n\n    it('should select error', () => {\n      const stateWithError = { ...mockState, error: new Error('Test') };\n      const result = fromUser.selectError.projector(stateWithError);\n      expect(result).not.toBeNull();\n      expect(result?.message).toBe('Test');\n    });\n\n    it('should memoize selector results', () => {\n      const selector = fromUser.selectUsers;\n      const state1 = mockState;\n      const state2 = mockState;\n\n      const result1 = selector.projector(state1);\n      const result2 = selector.projector(state2);\n\n      // Should return same reference due to memoization\n      expect(result1).toBe(result2);\n    });\n  });\n});\n```\n\n#### 3. Testing NgRx Effects\n\n```typescript\n// user.effects.ts\nimport { Injectable } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { map, switchMap, catchError, withLatestFrom } from 'rxjs/operators';\nimport { Store } from '@ngrx/store';\nimport * as fromUser from './user.store';\n\n@Injectable()\nexport class UserEffects {\n\n  loadUsers$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(fromUser.loadUsers),\n      switchMap(() =>\n        this.userService.getUsers().pipe(\n          map(users => fromUser.loadUsersSuccess({ users })),\n          catchError(error => of(fromUser.loadUsersFailure({ error })))\n        )\n      )\n    )\n  );\n\n  loadUserById$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(fromUser.loadUserById),\n      withLatestFrom(this.store.select(fromUser.selectUsers)),\n      switchMap(([action, users]) => {\n        const user = users.find(u => u.id === action.userId);\n        if (user) {\n          return of(fromUser.loadUserByIdSuccess({ user }));\n        }\n        return this.userService.getUserById(action.userId).pipe(\n          map(user => fromUser.loadUserByIdSuccess({ user })),\n          catchError(error => of(fromUser.loadUserByIdFailure({ error })))\n        );\n      })\n    )\n  );\n\n  constructor(\n    private actions$: Actions,\n    private userService: UserService,\n    private store: Store\n  ) {}\n}\n\n// user.effects.spec.ts\nimport { TestBed } from '@angular/core/testing';\nimport { provideMockActions } from '@ngrx/effects/testing';\nimport { hot, cold } from 'jasmine-marbles';\nimport { UserEffects } from './user.effects';\nimport { UserService } from './user.service';\nimport * as fromUser from './user.store';\n\ndescribe('UserEffects', () => {\n  let effects: UserEffects;\n  let actions$: Observable<any>;\n  let userService: jasmine.SpyObj<UserService>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [\n        UserEffects,\n        provideMockActions(() => actions$),\n        {\n          provide: UserService,\n          useValue: jasmine.createSpyObj('UserService', [\n            'getUsers',\n            'getUserById'\n          ])\n        }\n      ]\n    });\n\n    effects = TestBed.inject(UserEffects);\n    userService = TestBed.inject(UserService) as jasmine.SpyObj<UserService>;\n  });\n\n  describe('loadUsers$', () => {\n    it('should return loadUsersSuccess action', () => {\n      const users = [\n        { id: 1, name: 'John', email: 'john@example.com' }\n      ];\n      const completion = new fromUser.loadUsersSuccess({ users });\n\n      actions$ = hot('-a', { a: fromUser.loadUsers() });\n      const response = cold('-b|', { b: users });\n      const expected = hot('--c', { c: completion });\n\n      userService.getUsers.and.returnValue(response);\n\n      expect(effects.loadUsers$).toBeObservable(expected);\n    });\n\n    it('should return loadUsersFailure action on error', () => {\n      const error = new Error('API error');\n      const completion = new fromUser.loadUsersFailure({ error });\n\n      actions$ = hot('-a', { a: fromUser.loadUsers() });\n      const response = cold('-#', {}, error);\n      const expected = hot('--c', { c: completion });\n\n      userService.getUsers.and.returnValue(response);\n\n      expect(effects.loadUsers$).toBeObservable(expected);\n    });\n\n    it('should handle concurrent requests', () => {\n      const users = [{ id: 1, name: 'John', email: 'john@example.com' }];\n\n      actions$ = hot('-a-a', { a: fromUser.loadUsers() });\n      const response = cold('--b|', { b: users });\n      const expected = hot('---c---c', { c: new fromUser.loadUsersSuccess({ users }) });\n\n      userService.getUsers.and.returnValue(response);\n\n      expect(effects.loadUsers$).toBeObservable(expected);\n    });\n  });\n\n  describe('loadUserById$ with caching', () => {\n    it('should use cached users if available', () => {\n      const users = [\n        { id: 1, name: 'John', email: 'john@example.com' }\n      ];\n\n      actions$ = hot('-a', { a: fromUser.loadUserById({ userId: 1 }) });\n      // Should not make API call, should return cached user immediately\n      const expected = hot('-b', {\n        b: fromUser.loadUserByIdSuccess({ user: users[0] })\n      });\n\n      userService.getUserById.and.returnValue(cold('', {}));\n\n      expect(effects.loadUserById$).toBeObservable(expected);\n    });\n\n    it('should fetch from API if user not in cache', () => {\n      const user = { id: 2, name: 'Jane', email: 'jane@example.com' };\n\n      actions$ = hot('-a', { a: fromUser.loadUserById({ userId: 2 }) });\n      const response = cold('-b|', { b: user });\n      const expected = hot('--c', { c: fromUser.loadUserByIdSuccess({ user }) });\n\n      userService.getUserById.and.returnValue(response);\n\n      expect(effects.loadUserById$).toBeObservable(expected);\n    });\n  });\n});\n```\n\n#### 4. Integration testing с Store\n\n```typescript\n// app.integration.spec.ts\nimport { TestBed } from '@angular/core/testing';\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { Store } from '@ngrx/store';\nimport { UserService } from './user.service';\nimport { UserEffects } from './user.effects';\nimport { userReducer } from './user.store';\nimport * as fromUser from './user.store';\n\ndescribe('User Feature Integration Tests', () => {\n  let store: Store;\n  let userService: jasmine.SpyObj<UserService>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        StoreModule.forRoot({}),\n        StoreModule.forFeature('user', userReducer),\n        EffectsModule.forRoot([]),\n        EffectsModule.forFeature([UserEffects])\n      ],\n      providers: [\n        {\n          provide: UserService,\n          useValue: jasmine.createSpyObj('UserService', ['getUsers'])\n        }\n      ]\n    });\n\n    store = TestBed.inject(Store);\n    userService = TestBed.inject(UserService) as jasmine.SpyObj<UserService>;\n  });\n\n  it('should load users through the entire flow', (done) => {\n    const users = [\n      { id: 1, name: 'John', email: 'john@example.com' }\n    ];\n\n    userService.getUsers.and.returnValue(of(users));\n\n    store.dispatch(fromUser.loadUsers());\n\n    store.select(fromUser.selectUsers).subscribe(loadedUsers => {\n      if (loadedUsers.length > 0) {\n        expect(loadedUsers).toEqual(users);\n        done();\n      }\n    });\n  });\n\n  it('should manage loading state correctly', (done) => {\n    const states: boolean[] = [];\n\n    userService.getUsers.and.returnValue(\n      of([]).pipe(delay(100))\n    );\n\n    store.select(fromUser.selectLoading).subscribe(loading => {\n      states.push(loading);\n    });\n\n    store.dispatch(fromUser.loadUsers());\n\n    setTimeout(() => {\n      expect(states[0]).toBe(true); // Loading starts\n      expect(states[states.length - 1]).toBe(false); // Loading ends\n      done();\n    }, 200);\n  });\n\n  it('should handle errors gracefully', (done) => {\n    const error = new Error('API error');\n    userService.getUsers.and.returnValue(throwError(() => error));\n\n    store.dispatch(fromUser.loadUsers());\n\n    store.select(fromUser.selectError).subscribe(err => {\n      if (err) {\n        expect(err.message).toBe('API error');\n        done();\n      }\n    });\n  });\n});\n```\n\n#### 5. Mocking strategies\n\n```typescript\n// Mock services\nexport class MockUserService {\n  users$ = of([\n    { id: 1, name: 'John', email: 'john@example.com' },\n    { id: 2, name: 'Jane', email: 'jane@example.com' }\n  ]);\n\n  getUsers() {\n    return this.users$;\n  }\n\n  getUserById(id: number) {\n    return this.users$.pipe(\n      map(users => users.find(u => u.id === id)!)\n    );\n  }\n}\n\n// Mock Store\nexport class MockStore<T> {\n  private subjects = new Map<any, Subject<any>>();\n\n  select<R>(selector: any): Observable<R> {\n    if (!this.subjects.has(selector)) {\n      this.subjects.set(selector, new Subject<R>());\n    }\n    return this.subjects.get(selector).asObservable();\n  }\n\n  dispatch(action: any) {\n    // Mock dispatch\n  }\n\n  setState(selector: any, value: any) {\n    const subject = this.subjects.get(selector) as Subject<any>;\n    if (subject) {\n      subject.next(value);\n    }\n  }\n}\n\n// Usage in tests\nTestBed.configureTestingModule({\n  providers: [\n    { provide: UserService, useClass: MockUserService },\n    { provide: Store, useClass: MockStore }\n  ]\n});\n```\n\n### Testing Best Practices\n\n1. **Unit тестируй reducers** - простые pure functions\n2. **Integration тестируй effects** - используй marble testing\n3. **Component тестируй selectors** - проверяй memoization\n4. **Mock dependencies** - UserService, HTTP client\n5. **Тестируй error paths** - failure actions\n6. **Используй marble testing** - jasmine-marbles для async flows\n7. **Проверяй memory leaks** - subscribe/unsubscribe\n8. **Test concurrent requests** - debounce, throttle behaviors\n9. **Snapshot тестируй state shape** - не содержимое\n10. **Coverage target** - 80%+ для state management",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 7,
      "chapter_title": "Performance & Optimization",
      "questions": [
        {
          "question_number": 55,
          "question_number_in_chapter": 1,
          "question_chapter": 7,
          "question_title": "Change Detection strategies? OnPush vs Default?",
          "answer_markdown": "**Default** - проверяет весь component tree при любом событии.  \n**OnPush** - проверяет только при изменении @Input, events, или manual detectChanges().\n\n```typescript\n@Component({\n  selector: 'app-optimized',\n  changeDetection: ChangeDetectionStrategy.OnPush  // ✅ Оптимизация!\n})\nexport class OptimizedComponent {\n  @Input() data!: Data;  // Проверка только при изменении Input\n}\n```",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 56,
          "question_number_in_chapter": 2,
          "question_chapter": 7,
          "question_title": "Lazy Loading - модули, компоненты, роуты. Preloading strategies. Dynamic imports.",
          "answer_markdown": "**Ответ:**\n\n### 1. Lazy Loading Модулей через Routing\n\nLazy loading - отложенная загрузка функциональных модулей только когда они необходимы. Критично для production приложений с множеством features.\n\n**Базовая конфигурация в routing module:**\n\n```typescript\nconst routes: Routes = [\n  {\n    path: 'dashboard',\n    component: DashboardComponent,\n    data: { title: 'Dashboard' }\n  },\n  {\n    path: 'admin',\n    loadChildren: () => import('./modules/admin/admin.module').then(m => m.AdminModule),\n    data: { title: 'Admin Panel' }\n  },\n  {\n    path: 'analytics',\n    loadChildren: () => import('./modules/analytics/analytics.module')\n      .then(m => m.AnalyticsModule),\n    canActivate: [AdminGuard]\n  },\n  {\n    path: 'reports',\n    loadChildren: () => import('./modules/reports/reports.module')\n      .then(m => m.ReportsModule)\n  },\n  {\n    path: '',\n    redirectTo: '/dashboard',\n    pathMatch: 'full'\n  }\n];\n```\n\n**Lazy Loading отдельных компонентов (Angular 14+):**\n\n```typescript\n// Вместо импорта в declarations\nconst routes: Routes = [\n  {\n    path: 'heavy-component',\n    loadComponent: () => import('./components/heavy/heavy.component')\n      .then(m => m.HeavyComponent)\n  },\n  {\n    path: 'modal',\n    loadComponent: () => import('./components/modal/modal.component')\n      .then(m => m.ModalComponent)\n  }\n];\n```\n\n### 2. Preloading Strategies\n\n**Default strategy - NO_PRELOADING (по умолчанию):**\n```typescript\nimport { NgModule } from '@angular/core';\nimport { RouterModule, NoPreloading } from '@angular/router';\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes, {\n    preloadingStrategy: NoPreloading\n  })]\n})\nexport class AppRoutingModule { }\n```\n\n**PreloadAllModules - загружать все lazy modules в фоне после инициализации:**\n\n```typescript\nimport { PreloadAllModules } from '@angular/router';\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes, {\n    preloadingStrategy: PreloadAllModules,\n    enableTracing: false // для отладки\n  })]\n})\nexport class AppRoutingModule { }\n```\n\n**Custom Preloading Strategy - селективная предзагрузка:**\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of, timer } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\n\n@Injectable({ providedIn: 'root' })\nexport class CustomPreloadingStrategy implements PreloadingStrategy {\n  preload(route: Route, load: () => Observable<any>): Observable<any> {\n    // Preload только если в data указан preload: true\n    if (route.data && route.data['preload']) {\n      // Задержка 5 секунд перед предзагрузкой\n      return timer(5000).pipe(\n        mergeMap(() => {\n          console.log(`Preloading module: ${route.path}`);\n          return load();\n        })\n      );\n    }\n    return of(null);\n  }\n}\n\n// Использование:\nconst routes: Routes = [\n  {\n    path: 'admin',\n    loadChildren: () => import('./modules/admin/admin.module')\n      .then(m => m.AdminModule),\n    data: { preload: true } // Будет предзагружена\n  },\n  {\n    path: 'rarely-used',\n    loadChildren: () => import('./modules/rarely/rarely.module')\n      .then(m => m.RarelyModule),\n    data: { preload: false } // Не будет предзагружена\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes, {\n    preloadingStrategy: CustomPreloadingStrategy\n  })]\n})\nexport class AppRoutingModule { }\n```\n\n**Smart Preloading - на основе подключения к сети:**\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class QuicklinkStrategy implements PreloadingStrategy {\n  constructor(private ngZone: NgZone) { }\n\n  preload(route: Route, load: () => Observable<any>): Observable<any> {\n    if (!route.data || !route.data['preload']) {\n      return of(null);\n    }\n\n    // Проверка скорости соединения\n    const connection = (navigator as any).connection;\n\n    if (connection && connection.effectiveType !== '4g') {\n      console.log(`Skip preload on ${connection.effectiveType}`);\n      return of(null);\n    }\n\n    // Запуск вне Angular zone для минимизации влияния на main thread\n    return new Observable(observer => {\n      this.ngZone.runOutsideAngular(() => {\n        const timeoutId = setTimeout(() => {\n          this.ngZone.run(() => {\n            load().subscribe(\n              () => {\n                observer.next(null);\n                observer.complete();\n              },\n              error => observer.error(error)\n            );\n          });\n        }, 2000); // Запустить через 2 секунды\n      });\n    });\n  }\n}\n```\n\n### 3. Dynamic Imports и Module Federation\n\n**Standalone Components с dynamic import:**\n\n```typescript\n// config.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-config',\n  standalone: true,\n  template: `<h1>Config Component</h1>`\n})\nexport class ConfigComponent { }\n\n// app.routes.ts - Angular 15+ routes array\nexport const appRoutes: Routes = [\n  {\n    path: 'config',\n    loadComponent: () => import('./components/config.component')\n      .then(m => m.ConfigComponent)\n  }\n];\n```\n\n**Динамическая загрузка компонента через ViewContainerRef:**\n\n```typescript\nimport { Component, ViewContainerRef, Injector } from '@angular/core';\n\n@Component({\n  selector: 'app-dynamic-loader',\n  template: `\n    <div #container></div>\n    <button (click)=\"loadComponent()\">Load Heavy Component</button>\n  `\n})\nexport class DynamicLoaderComponent {\n  constructor(\n    private vcr: ViewContainerRef,\n    private injector: Injector\n  ) { }\n\n  async loadComponent() {\n    // Загрузка только при клике\n    const { HeavyTableComponent } = await import('./components/heavy-table.component');\n\n    this.vcr.clear();\n    this.vcr.createComponent(HeavyTableComponent, {\n      injector: this.injector\n    });\n  }\n}\n```\n\n### 4. Measuring и Monitoring\n\n**Angular Performance Profiler:**\n\n```typescript\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-perf-test',\n  template: '<div>{{ data | async | json }}</div>'\n})\nexport class PerfTestComponent implements OnInit {\n  data$ = this.service.getLazyData();\n\n  constructor(private service: DataService) { }\n\n  ngOnInit() {\n    if ((window as any).ng) {\n      const profiler = (window as any).ng.profiler;\n\n      profiler.timeChangeDetection({\n        numTicks: 10\n      });\n    }\n  }\n}\n```\n\n**Chrome DevTools для анализа lazy loading:**\n\n```typescript\n// В конструкторе route module\nconstructor(private router: Router) {\n  // Логирование событий роутинга\n  router.events.subscribe(event => {\n    if (event instanceof NavigationStart) {\n      performance.mark(`route-${event.id}-start`);\n    }\n    if (event instanceof NavigationEnd) {\n      performance.mark(`route-${event.id}-end`);\n      performance.measure(\n        `route-${event.id}`,\n        `route-${event.id}-start`,\n        `route-${event.id}-end`\n      );\n    }\n  });\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 57,
          "question_number_in_chapter": 3,
          "question_chapter": 7,
          "question_title": "Bundle Optimization - Tree Shaking, Dead Code Elimination, Code Splitting",
          "answer_markdown": "**Ответ:**\n\n### 1. Tree Shaking - удаление неиспользуемого кода\n\nTree shaking работает только с ES modules (import/export) в production build.\n\n**Правильное использование для tree shaking:**\n\n```typescript\n// ❌ BAD - CommonJS, не поддерживает tree shaking\nconst lodash = require('lodash');\nconst users = lodash.filter(data, user => user.active);\n\n// ✅ GOOD - ES modules\nimport { filter } from 'lodash-es';\nconst users = filter(data, user => user.active);\n\n// ✅ BEST - Named imports для точного tree shaking\nimport { filter } from 'lodash-es';\nconst users = filter(data, u => u.active);\n```\n\n**Package.json для поддержки tree shaking:**\n\n```json\n{\n  \"name\": \"my-library\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.es.js\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.es.js\",\n      \"require\": \"./dist/index.js\"\n    },\n    \"./utils\": {\n      \"import\": \"./dist/utils.es.js\",\n      \"require\": \"./dist/utils.js\"\n    }\n  }\n}\n```\n\n**Избегаем side effects:**\n\n```typescript\n// ❌ BAD - импортирует модуль с side effects\nimport 'global-setup.js';\nimport { util } from './utils';\n\n// ✅ GOOD - явный импорт только нужного\nimport { util } from './utils';\n// Если нужен side effect, импортируем отдельно с явным указанием\n```\n\n### 2. Dead Code Elimination в Angular\n\n**Использование Ahead-of-Time (AOT) compilation:**\n\n```typescript\n// angular.json\n{\n  \"projects\": {\n    \"my-app\": {\n      \"architect\": {\n        \"build\": {\n          \"options\": {\n            \"aot\": true,\n            \"optimization\": true,\n            \"buildOptimizer\": true,\n            \"sourceMap\": false,\n            \"namedChunks\": false,\n            \"vendorChunk\": false,\n            \"extractLicenses\": true\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n**Удаление неиспользуемого кода через build configuration:**\n\n```typescript\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": false,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noImplicitReturns\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  }\n}\n```\n\n**RxJS specific tree shaking (критично!):**\n\n```typescript\n// ❌ BAD - импортирует весь RxJS (~150KB)\nimport { Observable } from 'rxjs';\nimport * as operators from 'rxjs/operators';\n\n// ✅ GOOD - точные импорты\nimport { Observable } from 'rxjs';\nimport { map, filter, switchMap, takeUntil } from 'rxjs/operators';\n\n// ✅ BEST для Angular 15+ - pipe builders\nimport { map, filter, switchMap } from 'rxjs';\n\nconst stream$ = source$.pipe(\n  filter(x => x > 0),\n  map(x => x * 2),\n  switchMap(x => service.getData(x))\n);\n```\n\n### 3. Code Splitting Strategies\n\n**Route-based code splitting:**\n\n```typescript\nconst routes: Routes = [\n  {\n    path: 'dashboard',\n    loadChildren: () => import('./modules/dashboard/dashboard.module')\n      .then(m => m.DashboardModule)\n    // Автоматически создает отдельный chunk\n  },\n  {\n    path: 'analytics',\n    loadChildren: () => import('./modules/analytics/analytics.module')\n      .then(m => m.AnalyticsModule)\n  }\n];\n```\n\n**Динамическое разделение библиотек:**\n\n```typescript\n// webpack.config.js для Angular custom webpack\nmodule.exports = {\n  optimization: {\n    runtimeChunk: 'single',\n    splitChunks: {\n      chunks: 'all',\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          priority: 10,\n          reuseExistingChunk: true\n        },\n        common: {\n          minChunks: 2,\n          priority: 5,\n          reuseExistingChunk: true,\n          name: 'common'\n        },\n        // Отдельный chunk для тяжелых библиотек\n        charts: {\n          test: /[\\\\/]node_modules[\\\\/](chart\\.js|ng2-charts)[\\\\/]/,\n          name: 'charts',\n          priority: 15,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n};\n```\n\n**Manual code splitting для компонентов:**\n\n```typescript\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-heavy-feature',\n  template: '<div *ngIf=\"loaded\">{{ content }}</div>'\n})\nexport class HeavyFeatureComponent implements OnInit {\n  loaded = false;\n  content: any;\n\n  async ngOnInit() {\n    // Загружаем только при необходимости\n    const { HeavyProcessor } = await import('./heavy-processor');\n    const processor = new HeavyProcessor();\n    this.content = processor.process();\n    this.loaded = true;\n  }\n}\n```\n\n### 4. Bundle Analysis и Optimization Tools\n\n**Angular Bundle Analyzer:**\n\n```bash\n# Установка\nnpm install --save-dev @angular-eslint/builder webpack-bundle-analyzer\n\n# Сборка с анализом\nng build --stats-json\nwebpack-bundle-analyzer dist/my-app/stats.json\n```\n\n**Source map и размер анализ:**\n\n```typescript\n// angular.json optimization\n{\n  \"configurations\": {\n    \"production\": {\n      \"optimization\": {\n        \"scripts\": true,\n        \"styles\": true,\n        \"fonts\": true\n      },\n      \"sourceMap\": false,\n      \"extractLicenses\": true,\n      \"vendorChunk\": false,\n      \"buildOptimizer\": true\n    }\n  }\n}\n```\n\n**Профилирование размера бандла:**\n\n```bash\n# Анализ что включено в bundle\nsource-map-explorer 'dist/my-app/*.js'\n\n# Esbuild конфигурация для меньшего размера\nesbuild src/index.ts --bundle --minify --sourcemap=external\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 58,
          "question_number_in_chapter": 4,
          "question_chapter": 7,
          "question_title": "Memory Leaks - типичные причины, Profiling, Chrome DevTools",
          "answer_markdown": "**Ответ:**\n\n### 1. Типичные причины Memory Leaks в Angular\n\n**Problem #1: Неотписанные Subscriptions**\n\n```typescript\n// ❌ BAD - утечка памяти\n@Component({\n  selector: 'app-user',\n  template: '<div>{{ user | async }}</div>'\n})\nexport class UserComponent implements OnInit {\n  user$ = this.userService.getUser(123);\n  subscription: Subscription;\n\n  constructor(private userService: UserService) { }\n\n  ngOnInit() {\n    // Subscription не отписывается - утечка при destroy\n    this.subscription = this.userService.getUser(123)\n      .subscribe(user => {\n        console.log(user);\n        // Может быть interval, timeout и др\n      });\n  }\n\n  ngOnDestroy() {\n    // ❌ Забыли отписаться!\n  }\n}\n```\n\n**✅ GOOD - правильная обработка subscriptions:**\n\n```typescript\n// Способ 1: Manual unsubscribe\n@Component({\n  selector: 'app-user',\n  template: '<div>{{ user }}</div>'\n})\nexport class UserComponent implements OnInit, OnDestroy {\n  user: any;\n  private destroy$ = new Subject<void>();\n\n  constructor(private userService: UserService) { }\n\n  ngOnInit() {\n    this.userService.getUser(123)\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(user => {\n        this.user = user;\n      });\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n\n// Способ 2: async pipe (автоматическое управление)\n@Component({\n  selector: 'app-user',\n  template: '<div>{{ user$ | async }}</div>'\n})\nexport class UserComponent {\n  user$ = this.userService.getUser(123);\n  // Компонент автоматически отписывается при destroy\n  constructor(private userService: UserService) { }\n}\n\n// Способ 3: DestroyRef (Angular 16+)\n@Component({\n  selector: 'app-user',\n  template: '<div>{{ user }}</div>'\n})\nexport class UserComponent implements OnInit {\n  user: any;\n\n  constructor(\n    private userService: UserService,\n    private destroyRef: DestroyRef\n  ) { }\n\n  ngOnInit() {\n    this.userService.getUser(123)\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe(user => {\n        this.user = user;\n      });\n  }\n}\n```\n\n**Problem #2: Event Listeners и DOM References**\n\n```typescript\n// ❌ BAD - event listener утечка\n@Component({\n  selector: 'app-scroll',\n  template: '<div>Content</div>'\n})\nexport class ScrollComponent implements OnInit {\n  @ViewChild('container') container!: ElementRef;\n\n  ngOnInit() {\n    // Event listener не удаляется\n    this.container.nativeElement.addEventListener('scroll',\n      this.onScroll.bind(this)\n    );\n  }\n\n  onScroll() {\n    console.log('Scrolled');\n  }\n}\n\n// ✅ GOOD - правильное управление\n@Component({\n  selector: 'app-scroll',\n  template: '<div (scroll)=\"onScroll()\">Content</div>'\n})\nexport class ScrollComponent {\n  onScroll() {\n    console.log('Scrolled');\n  }\n  // Angular автоматически удаляет слушатель\n}\n\n// Или явное управление:\n@Component({\n  selector: 'app-scroll',\n  template: '<div #container>Content</div>'\n})\nexport class ScrollComponent implements OnInit, OnDestroy {\n  @ViewChild('container') container!: ElementRef;\n  private scrollHandler = this.onScroll.bind(this);\n\n  constructor(private renderer: Renderer2) { }\n\n  ngOnInit() {\n    this.renderer.listen(\n      this.container.nativeElement,\n      'scroll',\n      this.scrollHandler\n    );\n  }\n\n  ngOnDestroy() {\n    // Renderer2 автоматически удаляет listener\n  }\n\n  private onScroll() {\n    console.log('Scrolled');\n  }\n}\n```\n\n**Problem #3: Timers и Intervals**\n\n```typescript\n// ❌ BAD\n@Component({\n  selector: 'app-timer'\n})\nexport class TimerComponent implements OnInit {\n  counter = 0;\n\n  ngOnInit() {\n    // Timer продолжает работать после destroy\n    setInterval(() => {\n      this.counter++;\n    }, 1000);\n  }\n}\n\n// ✅ GOOD\n@Component({\n  selector: 'app-timer'\n})\nexport class TimerComponent implements OnInit, OnDestroy {\n  counter = 0;\n  private destroy$ = new Subject<void>();\n\n  ngOnInit() {\n    interval(1000)\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(() => {\n        this.counter++;\n      });\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}\n\n// Или простой timeout с очисткой\n@Component({\n  selector: 'app-timeout'\n})\nexport class TimeoutComponent implements OnInit, OnDestroy {\n  private timeoutId: any;\n\n  ngOnInit() {\n    this.timeoutId = setTimeout(() => {\n      console.log('Executed');\n    }, 5000);\n  }\n\n  ngOnDestroy() {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n    }\n  }\n}\n```\n\n**Problem #4: Global References и Detached DOM**\n\n```typescript\n// ❌ BAD - глобальная ссылка предотвращает GC\nclass GlobalState {\n  components: any[] = [];\n}\n\nconst globalState = new GlobalState();\n\n@Component({\n  selector: 'app-global-ref'\n})\nexport class GlobalRefComponent implements OnInit, OnDestroy {\n  constructor() { }\n\n  ngOnInit() {\n    globalState.components.push(this);\n    // Компонент никогда не удалится из памяти\n  }\n\n  ngOnDestroy() {\n    // Забыли очистить!\n  }\n}\n\n// ✅ GOOD\n@Component({\n  selector: 'app-global-ref'\n})\nexport class GlobalRefComponent implements OnInit, OnDestroy {\n  constructor(private stateService: StateService) { }\n\n  ngOnInit() {\n    this.stateService.register(this);\n  }\n\n  ngOnDestroy() {\n    this.stateService.unregister(this);\n  }\n}\n```\n\n### 2. Memory Profiling с Chrome DevTools\n\n**Шаг 1: Базовое профилирование**\n\n```\n1. Открыть Chrome DevTools (F12)\n2. Перейти на вкладку \"Memory\"\n3. Выбрать \"Heap Snapshot\"\n4. Нажать \"Take snapshot\"\n```\n\n**Шаг 2: Сравнительное профилирование для обнаружения утечек**\n\n```typescript\n// В консоли браузера:\n\n// Снимок 1 - базовое состояние\nconsole.clear();\n\n// Действия, вызывающие утечку (навигация, создание компонентов)\n// ...\n\n// Снимок 2 - после действий\n// Memory tab -> Take heap snapshot\n\n// Compare Snapshots - искать растущий размер памяти\n```\n\n**Шаг 3: Allocation Timeline для динамического отслеживания**\n\n```\nMemory tab -> Allocation timeline\n- Показывает как растет размер heap во времени\n- Синие полосы = выделение памяти\n- Серые полосы = сборка мусора\n```\n\n**Шаг 4: Детектирование утечек через DevTools**\n\n```typescript\n// Создание тестовой утечки для демонстрации\n@Component({\n  selector: 'app-leak-test',\n  template: `\n    <button (click)=\"createLeak()\">Create Leak</button>\n    <button (click)=\"navigateAway()\">Navigate Away</button>\n  `\n})\nexport class LeakTestComponent {\n  private leakedObjects: any[] = [];\n\n  createLeak() {\n    // Создает утечку - объекты накапливаются в памяти\n    for (let i = 0; i < 10000; i++) {\n      this.leakedObjects.push({\n        data: new Array(1000).fill('X'.repeat(1000))\n      });\n    }\n  }\n\n  navigateAway() {\n    // Компонент удаляется, но leakedObjects остаются в памяти\n  }\n}\n```\n\n### 3. Automated Memory Leak Detection\n\n**RxJS memory profiler:**\n\n```typescript\nimport { Subscription } from 'rxjs';\n\nexport class SubscriptionLeakDetector {\n  private subscriptions = new WeakSet<Subscription>();\n\n  subscribe<T>(\n    observable: Observable<T>,\n    observer: any\n  ): Subscription {\n    const subscription = observable.subscribe(observer);\n    this.subscriptions.add(subscription);\n    return subscription;\n  }\n\n  checkLeaks() {\n    // Проверить что subscriptions удаляются\n    setInterval(() => {\n      console.log('Active subscriptions:',\n        // WeakSet не имеет прямого способа проверки размера\n        // но можно логировать через DevTools\n      );\n    }, 5000);\n  }\n}\n```\n\n**Angular lifecycle monitoring:**\n\n```typescript\nexport class LifecycleMonitor {\n  private componentInstances = new Map<string, number>();\n\n  trackComponentInit(componentName: string) {\n    const count = (this.componentInstances.get(componentName) || 0) + 1;\n    this.componentInstances.set(componentName, count);\n    console.log(`${componentName} initialized. Active: ${count}`);\n  }\n\n  trackComponentDestroy(componentName: string) {\n    const count = (this.componentInstances.get(componentName) || 1) - 1;\n    this.componentInstances.set(componentName, count);\n    console.log(`${componentName} destroyed. Active: ${count}`);\n  }\n\n  getReport() {\n    console.table(\n      Array.from(this.componentInstances.entries())\n        .map(([name, count]) => ({ component: name, activeInstances: count }))\n    );\n  }\n}\n\n// Использование в компоненте:\n@Component({\n  selector: 'app-monitored'\n})\nexport class MonitoredComponent implements OnInit, OnDestroy {\n  constructor(\n    private monitor: LifecycleMonitor,\n    private injector: Injector\n  ) { }\n\n  ngOnInit() {\n    this.monitor.trackComponentInit(this.constructor.name);\n  }\n\n  ngOnDestroy() {\n    this.monitor.trackComponentDestroy(this.constructor.name);\n  }\n}\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 59,
          "question_number_in_chapter": 5,
          "question_chapter": 7,
          "question_title": "Runtime Performance - виртуализация, Web Workers, Service Workers",
          "answer_markdown": "**Ответ:**\n\n### 1. Virtual Scrolling с CDK Virtual Scroll\n\nVirtual scrolling рендерит только видимые элементы - критично для больших списков (1000+ items).\n\n**Базовое использование:**\n\n```typescript\nimport { ScrollingModule } from '@angular/cdk/scrolling';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-virtual-list',\n  template: `\n    <cdk-virtual-scroll-viewport itemSize=\"50\" class=\"list-container\">\n      <div *cdkVirtualFor=\"let item of items; let i = index\"\n           class=\"list-item\">\n        {{ i }}: {{ item.name }}\n      </div>\n    </cdk-virtual-scroll-viewport>\n  `,\n  styles: [`\n    .list-container {\n      height: 600px;\n      border: 1px solid #ccc;\n    }\n    .list-item {\n      height: 50px;\n      padding: 10px;\n      border-bottom: 1px solid #eee;\n    }\n  `]\n})\nexport class VirtualListComponent {\n  items = Array.from({ length: 100000 }, (_, i) => ({\n    id: i,\n    name: `Item ${i}`,\n    data: new Array(100).fill(Math.random())\n  }));\n}\n```\n\n**Advanced: Dynamic sizing и lazy loading**\n\n```typescript\nimport { ScrollingModule, CdkVirtualScrollViewport } from '@angular/cdk/scrolling';\nimport { Component, ViewChild } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n@Component({\n  selector: 'app-advanced-virtual-scroll',\n  template: `\n    <input [(ngModel)]=\"searchTerm\" placeholder=\"Filter...\">\n\n    <cdk-virtual-scroll-viewport\n      [itemSize]=\"null\"\n      [minBufferPx]=\"100\"\n      [maxBufferPx]=\"200\"\n      (scrolledIndexChange)=\"onScrolledIndexChange($event)\"\n      class=\"list-container\">\n\n      <div *cdkVirtualFor=\"let item of filteredItems$ | async\"\n           [attr.data-id]=\"item.id\"\n           class=\"list-item\">\n        <div class=\"item-header\">{{ item.name }}</div>\n        <div class=\"item-content\" [innerHTML]=\"item.description\"></div>\n        <img *ngIf=\"item.image\" [src]=\"item.image\" [alt]=\"item.name\">\n      </div>\n\n      <div *ngIf=\"isLoadingMore\" class=\"loading-indicator\">\n        Loading more items...\n      </div>\n    </cdk-virtual-scroll-viewport>\n  `,\n  styles: [`\n    .list-container {\n      height: 800px;\n      width: 100%;\n    }\n    .list-item {\n      padding: 15px;\n      border-bottom: 1px solid #ddd;\n      min-height: 100px;\n    }\n    .loading-indicator {\n      padding: 20px;\n      text-align: center;\n    }\n  `]\n})\nexport class AdvancedVirtualScrollComponent {\n  @ViewChild(CdkVirtualScrollViewport) viewport!: CdkVirtualScrollViewport;\n\n  searchTerm = '';\n  isLoadingMore = false;\n  private allItems = new BehaviorSubject<any[]>([]);\n  filteredItems$ = this.allItems.asObservable();\n\n  constructor(private dataService: DataService) {\n    this.loadInitialData();\n  }\n\n  loadInitialData() {\n    this.dataService.getItems(0, 50).subscribe(items => {\n      this.allItems.next(items);\n    });\n  }\n\n  onScrolledIndexChange(index: number) {\n    const currentItems = this.allItems.value;\n\n    // Загружаем больше данных если приблизились к концу\n    if (index > currentItems.length - 10 && !this.isLoadingMore) {\n      this.isLoadingMore = true;\n      this.dataService.getItems(currentItems.length, 50).subscribe(newItems => {\n        this.allItems.next([...currentItems, ...newItems]);\n        this.isLoadingMore = false;\n      });\n    }\n  }\n\n  // Фильтрация на клиенте\n  get filteredItems$() {\n    return this.allItems.pipe(\n      map(items => items.filter(item =>\n        item.name.toLowerCase().includes(this.searchTerm.toLowerCase())\n      ))\n    );\n  }\n\n  // Для прокрутки к конкретному элементу\n  scrollToIndex(index: number) {\n    this.viewport.scrollToIndex(index, 'smooth');\n  }\n}\n```\n\n### 2. Web Workers для тяжелых вычислений\n\nWeb Workers выполняют JS в отдельном потоке, не блокируя UI.\n\n**Setup Web Worker:**\n\n```typescript\n// src/app/workers/heavy-computation.worker.ts\n/// <reference lib=\"webworker\" />\n\naddEventListener('message', ({ data }: MessageEvent<any>) => {\n  const { operation, payload } = data;\n\n  switch (operation) {\n    case 'process-large-array':\n      const result = processLargeArray(payload);\n      postMessage({ success: true, result });\n      break;\n\n    case 'fibonacci':\n      const fib = fibonacci(payload);\n      postMessage({ success: true, result: fib });\n      break;\n\n    case 'image-processing':\n      const processed = processImage(payload);\n      postMessage({ success: true, result: processed });\n      break;\n\n    default:\n      postMessage({ success: false, error: 'Unknown operation' });\n  }\n});\n\nfunction processLargeArray(data: number[]): number {\n  // Тяжелые вычисления в отдельном потоке\n  return data.reduce((sum, val) => {\n    // Сложные операции\n    for (let i = 0; i < 1000; i++) {\n      sum += Math.sqrt(val * i);\n    }\n    return sum;\n  }, 0);\n}\n\nfunction fibonacci(n: number): number {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nfunction processImage(imageData: ImageData): ImageData {\n  // Пиксельные операции в отдельном потоке\n  const data = imageData.data;\n  for (let i = 0; i < data.length; i += 4) {\n    // Brightness adjustment\n    data[i] = Math.min(255, data[i] * 1.1);\n    data[i + 1] = Math.min(255, data[i + 1] * 1.1);\n    data[i + 2] = Math.min(255, data[i + 2] * 1.1);\n  }\n  return imageData;\n}\n```\n\n**Angular Service для работы с Worker:**\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: 'root' })\nexport class WorkerService {\n  private worker: Worker | null = null;\n\n  constructor() {\n    if (typeof Worker !== 'undefined') {\n      this.worker = new Worker(\n        new URL('./workers/heavy-computation.worker',\n        import.meta.url),\n        { type: 'module' }\n      );\n    }\n  }\n\n  processCPUIntensive(operation: string, payload: any): Observable<any> {\n    return new Observable(observer => {\n      if (!this.worker) {\n        observer.error('Web Workers not supported');\n        return;\n      }\n\n      const subscription = () => {\n        this.worker!.removeEventListener('message', messageHandler);\n        this.worker!.removeEventListener('error', errorHandler);\n      };\n\n      const messageHandler = (event: MessageEvent) => {\n        if (event.data.success) {\n          observer.next(event.data.result);\n          observer.complete();\n        } else {\n          observer.error(event.data.error);\n        }\n        subscription();\n      };\n\n      const errorHandler = (error: ErrorEvent) => {\n        observer.error(error.message);\n        subscription();\n      };\n\n      this.worker!.addEventListener('message', messageHandler);\n      this.worker!.addEventListener('error', errorHandler);\n      this.worker!.postMessage({ operation, payload });\n    });\n  }\n\n  terminateWorker() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n    }\n  }\n}\n```\n\n**Использование в компоненте:**\n\n```typescript\n@Component({\n  selector: 'app-heavy-computation',\n  template: `\n    <div>\n      <input type=\"number\" [(ngModel)]=\"inputValue\" placeholder=\"Input\">\n      <button (click)=\"startComputation()\">Calculate</button>\n      <button (click)=\"startFib()\" [disabled]=\"isProcessing\">Fibonacci</button>\n\n      <div *ngIf=\"isProcessing\" class=\"spinner\">Computing...</div>\n      <div *ngIf=\"result\" class=\"result\">\n        Result: {{ result | number:'1.0-0' }}\n      </div>\n    </div>\n  `\n})\nexport class HeavyComputationComponent {\n  inputValue = 40;\n  result: number | null = null;\n  isProcessing = false;\n\n  constructor(private workerService: WorkerService) { }\n\n  startComputation() {\n    this.isProcessing = true;\n    const largeArray = Array.from({ length: 100000 }, () =>\n      Math.random() * 1000\n    );\n\n    this.workerService.processCPUIntensive('process-large-array', largeArray)\n      .subscribe(\n        result => {\n          this.result = result;\n          this.isProcessing = false;\n        },\n        error => {\n          console.error(error);\n          this.isProcessing = false;\n        }\n      );\n  }\n\n  startFib() {\n    this.isProcessing = true;\n    this.workerService.processCPUIntensive('fibonacci', this.inputValue)\n      .subscribe(\n        result => {\n          this.result = result;\n          this.isProcessing = false;\n        }\n      );\n  }\n\n  ngOnDestroy() {\n    this.workerService.terminateWorker();\n  }\n}\n```\n\n### 3. Service Workers для кэширования и offline\n\nService Workers кэшируют сетевые запросы и работают offline.\n\n**Базовая регистрация Service Worker:**\n\n```typescript\n// main.ts или app.component.ts\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: '<router-outlet></router-outlet>'\n})\nexport class AppComponent implements OnInit {\n  constructor(private swUpdate: SwUpdate) { }\n\n  ngOnInit() {\n    // Проверка обновлений Service Worker\n    if (this.swUpdate.isEnabled) {\n      // Проверка каждые 10 минут\n      interval(10 * 60 * 1000).subscribe(() => {\n        this.swUpdate.checkForUpdate();\n      });\n\n      // Если доступно обновление\n      this.swUpdate.available.subscribe(() => {\n        if (confirm('New version available. Load it?')) {\n          this.swUpdate.activateUpdate().then(() => {\n            window.location.reload();\n          });\n        }\n      });\n    }\n  }\n}\n```\n\n**ngsw-config.json для кэширования:**\n\n```json\n{\n  \"$schema\": \"./node_modules/@angular/service-worker/config/schema.json\",\n  \"index\": \"/index.html\",\n  \"assetGroups\": [\n    {\n      \"name\": \"app\",\n      \"installMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/favicon.ico\",\n          \"/index.html\",\n          \"/*.css\",\n          \"/*.js\"\n        ]\n      }\n    },\n    {\n      \"name\": \"assets\",\n      \"installMode\": \"lazy\",\n      \"updateMode\": \"lazy\",\n      \"resources\": {\n        \"files\": [\n          \"/assets/**\",\n          \"/**/*/images/**\"\n        ]\n      }\n    }\n  ],\n  \"dataGroups\": [\n    {\n      \"name\": \"api-cache\",\n      \"urls\": [\n        \"/api/**\"\n      ],\n      \"cacheConfig\": {\n        \"strategy\": \"performance\",\n        \"maxSize\": 100,\n        \"maxAge\": \"1d\"\n      }\n    },\n    {\n      \"name\": \"user-data\",\n      \"urls\": [\n        \"/api/users/**\",\n        \"/api/profile/**\"\n      ],\n      \"cacheConfig\": {\n        \"strategy\": \"freshness\",\n        \"maxAge\": \"1h\",\n        \"maxSize\": 50\n      }\n    }\n  ]\n}\n```\n\n**Custom Cache Strategy для API:**\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpRequest, HttpHandler } from '@angular/common/http';\n\n@Injectable()\nexport class CacheInterceptor implements HttpInterceptor {\n  private cache = new Map<string, any>();\n  private cacheTimestamps = new Map<string, number>();\n  private cacheExpiry = 5 * 60 * 1000; // 5 минут\n\n  intercept(req: HttpRequest<any>, next: HttpHandler) {\n    // Кэшируем только GET запросы\n    if (req.method !== 'GET') {\n      return next.handle(req);\n    }\n\n    const cachedResponse = this.cache.get(req.url);\n    const cacheTime = this.cacheTimestamps.get(req.url) || 0;\n    const now = Date.now();\n\n    // Если кэш еще свежий, вернуть его\n    if (cachedResponse && (now - cacheTime) < this.cacheExpiry) {\n      return of(cachedResponse.clone());\n    }\n\n    // Иначе выполнить запрос и кэшировать результат\n    return next.handle(req).pipe(\n      tap(response => {\n        if (response instanceof HttpResponse) {\n          this.cache.set(req.url, response.clone());\n          this.cacheTimestamps.set(req.url, now);\n        }\n      }),\n      shareReplay(1)\n    );\n  }\n\n  clearCache() {\n    this.cache.clear();\n    this.cacheTimestamps.clear();\n  }\n\n  clearCacheByUrl(url: string) {\n    this.cache.delete(url);\n    this.cacheTimestamps.delete(url);\n  }\n}\n```\n\n### 4. Performance Monitoring и Measurement\n\n**Использование Performance API для мониторинга:**\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { Router, NavigationStart, NavigationEnd } from '@angular/router';\n\n@Injectable({ providedIn: 'root' })\nexport class PerformanceMonitorService {\n  constructor(private router: Router) {\n    this.setupRouterMetrics();\n  }\n\n  private setupRouterMetrics() {\n    let navigationStart = 0;\n\n    this.router.events.subscribe(event => {\n      if (event instanceof NavigationStart) {\n        navigationStart = performance.now();\n        performance.mark(`navigation-${event.id}-start`);\n      }\n\n      if (event instanceof NavigationEnd) {\n        performance.mark(`navigation-${event.id}-end`);\n        performance.measure(\n          `navigation-${event.id}`,\n          `navigation-${event.id}-start`,\n          `navigation-${event.id}-end`\n        );\n\n        const duration = performance.now() - navigationStart;\n        this.reportMetric('navigation', duration, event.url);\n      }\n    });\n  }\n\n  measureComponentRender(componentName: string) {\n    const startMark = `${componentName}-render-start`;\n    const endMark = `${componentName}-render-end`;\n    const measureName = `${componentName}-render-time`;\n\n    performance.mark(startMark);\n\n    return () => {\n      performance.mark(endMark);\n      performance.measure(measureName, startMark, endMark);\n\n      const measure = performance.getEntriesByName(measureName)[0];\n      this.reportMetric('component-render', measure.duration, componentName);\n    };\n  }\n\n  measureApiCall(url: string, duration: number) {\n    this.reportMetric('api-call', duration, url);\n  }\n\n  private reportMetric(type: string, duration: number, label: string) {\n    if (duration > 1000) {\n      console.warn(\n        `[PERF WARNING] ${type}: ${label} took ${duration.toFixed(2)}ms`\n      );\n    }\n\n    // Отправить на аналитику\n    if (typeof gtag !== 'undefined') {\n      gtag('event', 'timing', {\n        'event_category': 'performance',\n        'event_label': label,\n        'value': Math.round(duration),\n        'type': type\n      });\n    }\n  }\n\n  getMetrics() {\n    return {\n      navigation: performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming,\n      paint: performance.getEntriesByType('paint'),\n      measures: performance.getEntriesByType('measure')\n    };\n  }\n}\n```\n\n**Использование в компоненте:**\n\n```typescript\n@Component({\n  selector: 'app-heavy-render',\n  template: '<div *ngFor=\"let item of items\">{{ item }}</div>'\n})\nexport class HeavyRenderComponent implements OnInit, OnDestroy {\n  items: any[] = [];\n  private stopMeasure: (() => void) | null = null;\n\n  constructor(private perfMonitor: PerformanceMonitorService) { }\n\n  ngOnInit() {\n    this.stopMeasure = this.perfMonitor.measureComponentRender('HeavyRender');\n    this.generateLargeList();\n  }\n\n  generateLargeList() {\n    this.items = Array.from({ length: 10000 }, (_, i) => ({\n      id: i,\n      data: `Item ${i}`\n    }));\n  }\n\n  ngAfterViewInit() {\n    if (this.stopMeasure) {\n      this.stopMeasure();\n    }\n  }\n}\n```",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 60,
          "question_number_in_chapter": 6,
          "question_chapter": 7,
          "question_title": "Server-Side Rendering (SSR) с Angular Universal",
          "answer_markdown": "**Ответ:**\n\n### Что такое SSR и зачем он нужен?\n\nServer-Side Rendering позволяет выполнять Angular приложение на сервере, отправляя готовый HTML-контент клиенту. Основные преимущества:\n\n1. **SEO Optimization** - поисковые боты получают полностью отрендеренный контент\n2. **First Contentful Paint (FCP)** - пользователи видят контент раньше (FCP ~50-70% от CSR)\n3. **Улучшенный UX** - нет белого экрана загрузки на низких сетях\n4. **Social Media Preview** - корректное отображение OG-метатегов при шеринге\n\n### Архитектура SSR с Angular Universal\n\n```typescript\n// server.ts - Entry point для SSR\nimport { APP_BASE_HREF } from '@angular/common';\nimport { ngExpressEngine } from '@nguniversal/express-engine';\nimport * as express from 'express';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\nimport { AppServerModule } from './src/main.server';\n\nconst app = express();\nconst DIST_FOLDER = join(process.cwd(), 'dist/app');\nconst BROWSER_FOLDER = join(DIST_FOLDER, 'browser');\nconst SERVER_FOLDER = join(DIST_FOLDER, 'server');\n\n// Setup express engine для рендеринга\napp.engine('html', ngExpressEngine({\n  bootstrap: AppServerModule\n}));\n\napp.set('view engine', 'html');\napp.set('views', BROWSER_FOLDER);\n\n// Сервируем статические файлы\napp.get('*.*', express.static(BROWSER_FOLDER, {\n  maxAge: '1y',\n  etag: false\n}));\n\n// SSR routes\napp.get('*', (req, res) => {\n  res.render(join(BROWSER_FOLDER, 'index.html'), {\n    req,\n    providers: [\n      { provide: APP_BASE_HREF, useValue: req.baseUrl }\n    ]\n  });\n});\n\nconst PORT = process.env.PORT || 4200;\napp.listen(PORT, () => {\n  console.log(`Node server listening on http://localhost:${PORT}`);\n});\n```\n\n### Hydration - критический процесс\n\nHydration - это процесс \"оживления\" SSR-рендеренного DOM путём:\n1. Angular загружает JavaScript-бандл\n2. Angular привязывает event listeners к существующему DOM\n3. Angular синхронизирует состояние приложения с рендеренным HTML\n\n**Angular 17+ TransferState для оптимальной гидратации:**\n\n```typescript\n// app.config.ts (Angular 17+ standalone)\nimport {\n  provideClientHydration,\n  withHttpTransferCacheOptions\n} from '@angular/platform-browser';\nimport { provideServerRendering } from '@angular/platform-server';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    // Клиент\n    provideClientHydration(\n      withHttpTransferCacheOptions({\n        includeHeaders: ['x-custom-header'],\n        includePostRequests: false,\n        filter: (req) => !req.url.includes('/api/auth')\n      })\n    ),\n\n    // Сервер\n    provideServerRendering(),\n\n    // Другие провайдеры\n    provideHttpClient(),\n    provideAnimations()\n  ]\n};\n\n// app.server.ts\nbootstrapApplication(AppComponent, appConfig);\n```\n\n**TransferState - передача данных с сервера на клиент:**\n\n```typescript\n// user.service.ts\nimport { TransferState, makeStateKey } from '@angular/platform-browser';\nimport { HttpClient } from '@angular/common/http';\nimport { inject } from '@angular/core';\n\nconst USER_KEY = makeStateKey<User>('user');\n\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private http = inject(HttpClient);\n  private transferState = inject(TransferState);\n\n  getUser(id: number): Observable<User> {\n    // Проверяем, уже ли был запрос на сервере\n    const cachedUser = this.transferState.get(USER_KEY, null);\n\n    if (cachedUser) {\n      this.transferState.remove(USER_KEY);\n      return of(cachedUser);\n    }\n\n    return this.http.get<User>(`/api/users/${id}`).pipe(\n      tap(user => {\n        // На сервере сохраняем для передачи клиенту\n        this.transferState.set(USER_KEY, user);\n      })\n    );\n  }\n}\n```\n\n### Angular 17+ Improvements\n\n1. **Новый hydration API:**\n```typescript\n// beforeEachChild становится beforeEach для более точного контроля\napp.get('*', (req, res) => {\n  const context = { beforeEachChild: true };\n  res.render('index', { req, context });\n});\n```\n\n2. **Hydration Mismatch Detection:**\n```typescript\n// app.component.ts\nimport { NgZone } from '@angular/core';\n\nexport class AppComponent implements OnInit {\n  ngOnInit() {\n    // Angular 17+ автоматически детектит несоответствия\n    // и логирует их в development\n  }\n}\n```\n\n3. **Incremental Hydration:**\n```typescript\n// Компоненты гидратируются по мере необходимости\n@Component({\n  selector: 'app-lazy',\n  template: `...`,\n  standalone: true,\n  hydrate: 'on-demand' // Angular 17+\n})\n```\n\n### Performance Metrics для SSR\n\n```typescript\n// server-performance.ts\nimport { performance } from 'perf_hooks';\n\napp.get('*', (req, res) => {\n  const startTime = performance.now();\n\n  renderApplication(req).then(html => {\n    const renderTime = performance.now() - startTime;\n\n    res.setHeader('X-Response-Time', renderTime);\n    res.setHeader('Server-Timing',\n      `render;dur=${renderTime}`\n    );\n    res.send(html);\n\n    // Логирование для мониторинга\n    console.log(`${req.url}: ${renderTime}ms`);\n  });\n});\n```\n\n### Решение типичных проблем SSR\n\n1. **ReferenceError: window is not defined**\n   ```typescript\n   // Используем isPlatformBrowser\n   import { isPlatformBrowser } from '@angular/common';\n\n   @Component({...})\n   export class MyComponent {\n     constructor(private platformId: any) {}\n\n     ngOnInit() {\n       if (isPlatformBrowser(this.platformId)) {\n         // Browser-only код\n         window.addEventListener('scroll', ...);\n       }\n     }\n   }\n   ```\n\n2. **Гидратационное несоответствие**\n   ```typescript\n   // Используем одинаковый контент на сервере и клиенте\n   @Component({\n     template: `\n       {{ isServer ? 'Server' : 'Client' }}  // ❌ Плохо\n       {{ currentDate | date }}  // ❌ Плохо - дата может отличаться\n     `\n   })\n   export class BadComponent {}\n   ```\n\n3. **Memory Leaks в SSR**\n   ```typescript\n   // Подписи должны быть очищены на сервере\n   @Component({...})\n   export class MyComponent implements OnInit, OnDestroy {\n     private subscription: Subscription;\n\n     ngOnInit() {\n       this.subscription = this.data$.subscribe(data => {\n         // Процесс данных\n       });\n     }\n\n     ngOnDestroy() {\n       this.subscription.unsubscribe(); // Критично для SSR\n     }\n   }\n   ```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 61,
          "question_number_in_chapter": 7,
          "question_chapter": 7,
          "question_title": "Progressive Web App (PWA) в Angular",
          "answer_markdown": "**Ответ:**\n\n### Компоненты PWA\n\nPWA состоит из трёх основных столпов:\n1. **Service Worker** - offline support, background sync\n2. **Manifest** - install prompts, app metadata\n3. **HTTPS** - security requirement\n\n### Service Worker Configuration\n\n```typescript\n// angular.json - добавляем Service Worker\n{\n  \"projects\": {\n    \"my-app\": {\n      \"architect\": {\n        \"build\": {\n          \"options\": {\n            \"serviceWorker\": \"ngsw-config.json\"\n          }\n        }\n      }\n    }\n  }\n}\n\n// ngsw-config.json - конфигурация Service Worker\n{\n  \"$schema\": \"./node_modules/@angular/service-worker/config/schema.json\",\n  \"index\": \"/index.html\",\n\n  \"assetGroups\": [\n    {\n      \"name\": \"app\",\n      \"installMode\": \"prefetch\",\n      \"updateMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/favicon.ico\",\n          \"/index.html\",\n          \"/*.css\",\n          \"/*.js\"\n        ]\n      }\n    },\n    {\n      \"name\": \"assets\",\n      \"installMode\": \"lazy\",\n      \"updateMode\": \"lazy\",\n      \"resources\": {\n        \"files\": [\n          \"/assets/**\",\n          \"/*.(svg|cur|jpg|jpeg|png|apng|webp|gif|otf|ttf|woff|woff2)\"\n        ]\n      }\n    }\n  ],\n\n  \"dataGroups\": [\n    {\n      \"name\": \"api-performance\",\n      \"urls\": [\"/api/v1/products\", \"/api/v1/users\"],\n      \"cacheConfig\": {\n        \"strategy\": \"performance\",\n        \"maxSize\": 100,\n        \"maxAge\": \"1h\"\n      }\n    },\n    {\n      \"name\": \"api-freshness\",\n      \"urls\": [\"/api/v1/news/**\"],\n      \"cacheConfig\": {\n        \"strategy\": \"freshness\",\n        \"maxSize\": 50,\n        \"maxAge\": \"24h\",\n        \"timeout\": \"5s\"\n      }\n    }\n  ],\n\n  \"navigationUrls\": [\n    \"/**\",\n    \"!/**/*.*\",\n    \"!/files/**\"\n  ]\n}\n```\n\n### Caching Strategies\n\n**1. Network First (freshness strategy):**\n```typescript\n// Service Worker пытается сначала получить из сети\ndataGroups: [{\n  cacheConfig: {\n    strategy: \"freshness\",\n    timeout: \"10s\",\n    maxAge: \"24h\"\n  }\n}]\n// Идеально для: API, новости, часто обновляемые данные\n```\n\n**2. Cache First (performance strategy):**\n```typescript\ndataGroups: [{\n  cacheConfig: {\n    strategy: \"performance\",\n    maxAge: \"30d\"\n  }\n}]\n// Идеально для: статические асеты, версионированные файлы\n```\n\n**3. Stale While Revalidate (оптимальный баланс):**\n```typescript\n// Кастомная стратегия в Service Worker\nself.addEventListener('fetch', event => {\n  if (event.request.method === 'GET') {\n    event.respondWith(\n      caches.open('v1').then(cache => {\n        return cache.match(event.request).then(response => {\n          const fetchPromise = fetch(event.request)\n            .then(networkResponse => {\n              cache.put(event.request, networkResponse.clone());\n              return networkResponse;\n            });\n\n          return response || fetchPromise;\n        });\n      })\n    );\n  }\n});\n```\n\n### Offline Support в Angular\n\n```typescript\n// offline.service.ts\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\n@Injectable({ providedIn: 'root' })\nexport class OfflineService {\n  private onlineSubject = new BehaviorSubject<boolean>(navigator.onLine);\n  public online$: Observable<boolean> = this.onlineSubject.asObservable();\n\n  constructor() {\n    window.addEventListener('online', () => {\n      this.onlineSubject.next(true);\n      this.syncOfflineData();\n    });\n\n    window.addEventListener('offline', () => {\n      this.onlineSubject.next(false);\n    });\n  }\n\n  private syncOfflineData() {\n    // Синхронизируем данные, сохранённые в localStorage/IndexedDB\n    const pendingRequests = JSON.parse(\n      localStorage.getItem('pending_requests') || '[]'\n    );\n\n    pendingRequests.forEach(req => {\n      fetch(req.url, {\n        method: req.method,\n        body: req.body,\n        headers: req.headers\n      }).then(() => {\n        // Удаляем из pending после успешной отправки\n        const updated = pendingRequests.filter(r => r.id !== req.id);\n        localStorage.setItem('pending_requests', JSON.stringify(updated));\n      });\n    });\n  }\n}\n\n// app.component.ts - использование\n@Component({\n  selector: 'app-root',\n  template: `\n    <div *ngIf=\"!(offlineService.online$ | async)\" class=\"offline-banner\">\n      Вы в режиме offline\n    </div>\n  `\n})\nexport class AppComponent {\n  constructor(public offlineService: OfflineService) {}\n}\n```\n\n### Install Prompts\n\n```typescript\n// install.service.ts\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n@Injectable({ providedIn: 'root' })\nexport class InstallService {\n  private deferredPrompt: any;\n  installPrompt$ = new BehaviorSubject<boolean>(false);\n  isInstalled$ = new BehaviorSubject<boolean>(false);\n\n  constructor() {\n    // Перехватываем beforeinstallprompt\n    window.addEventListener('beforeinstallprompt', (e) => {\n      e.preventDefault();\n      this.deferredPrompt = e;\n      this.installPrompt$.next(true);\n    });\n\n    // Проверяем, установлено ли приложение\n    if (window.matchMedia('(display-mode: standalone)').matches) {\n      this.isInstalled$.next(true);\n    }\n\n    window.addEventListener('appinstalled', () => {\n      this.isInstalled$.next(true);\n      this.installPrompt$.next(false);\n    });\n  }\n\n  async install() {\n    if (!this.deferredPrompt) return;\n\n    this.deferredPrompt.prompt();\n    const { outcome } = await this.deferredPrompt.userChoice;\n\n    console.log(`User response: ${outcome}`);\n\n    this.deferredPrompt = null;\n    this.installPrompt$.next(false);\n  }\n}\n\n// install-button.component.ts\n@Component({\n  selector: 'app-install-button',\n  template: `\n    <button\n      *ngIf=\"installService.installPrompt$ | async\"\n      (click)=\"install()\"\n      class=\"install-btn\">\n      Установить приложение\n    </button>\n  `\n})\nexport class InstallButtonComponent {\n  constructor(public installService: InstallService) {}\n\n  async install() {\n    await this.installService.install();\n  }\n}\n```\n\n### Web App Manifest\n\n```json\n// manifest.webmanifest\n{\n  \"name\": \"My Awesome App\",\n  \"short_name\": \"AwesomeApp\",\n  \"description\": \"A progressive web application\",\n  \"start_url\": \"/\",\n  \"scope\": \"/\",\n  \"display\": \"standalone\",\n  \"orientation\": \"portrait-primary\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#1976d2\",\n  \"shortcuts\": [\n    {\n      \"name\": \"Create Note\",\n      \"short_name\": \"Create\",\n      \"description\": \"Quickly create a new note\",\n      \"url\": \"/create-note\",\n      \"icons\": [\n        {\n          \"src\": \"/assets/note-96.png\",\n          \"sizes\": \"96x96\",\n          \"type\": \"image/png\"\n        }\n      ]\n    }\n  ],\n  \"icons\": [\n    {\n      \"src\": \"/assets/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any\"\n    },\n    {\n      \"src\": \"/assets/icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable\"\n    }\n  ]\n}\n```\n\n### Background Sync\n\n```typescript\n// sync.service.ts\n@Injectable({ providedIn: 'root' })\nexport class BackgroundSyncService {\n  async syncOfflineData() {\n    if ('serviceWorker' in navigator && 'SyncManager' in window) {\n      const registration = await navigator.serviceWorker.ready;\n\n      try {\n        // Регистрируем sync событие\n        await registration.sync.register('sync-offline-data');\n      } catch (error) {\n        console.error('Background sync failed:', error);\n      }\n    }\n  }\n}\n\n// Service Worker - обработка sync события\nself.addEventListener('sync', event => {\n  if (event.tag === 'sync-offline-data') {\n    event.waitUntil(\n      syncOfflineData()\n    );\n  }\n});\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 62,
          "question_number_in_chapter": 8,
          "question_chapter": 7,
          "question_title": "Performance Budgets и Monitoring",
          "answer_markdown": "**Ответ:**\n\n### Performance Budgets - что это?\n\nPerformance Budget - это лимиты на размер/скорость загрузки приложения. Нарушение бюджета блокирует deploy в production.\n\n```json\n// angular.json - бюджеты приложения\n{\n  \"projects\": {\n    \"my-app\": {\n      \"architect\": {\n        \"build\": {\n          \"configurations\": {\n            \"production\": {\n              \"budgets\": [\n                {\n                  \"type\": \"bundle\",\n                  \"name\": \"main\",\n                  \"maximumWarningInBytes\": 500000,  // 500KB warning\n                  \"maximumErrorInBytes\": 750000     // 750KB error - блокирует build\n                },\n                {\n                  \"type\": \"bundle\",\n                  \"name\": \"polyfills\",\n                  \"maximumWarningInBytes\": 50000,\n                  \"maximumErrorInBytes\": 100000\n                },\n                {\n                  \"type\": \"bundle\",\n                  \"name\": \"styles\",\n                  \"maximumWarningInBytes\": 150000,\n                  \"maximumErrorInBytes\": 200000\n                },\n                {\n                  \"type\": \"anyComponentStyle\",\n                  \"maximumWarningInBytes\": 6000,\n                  \"maximumErrorInBytes\": 10000\n                },\n                {\n                  \"type\": \"initial\",\n                  \"maximumWarningInBytes\": 2097152,  // 2MB initial\n                  \"maximumErrorInBytes\": 5242880    // 5MB max\n                }\n              ]\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n### Lighthouse CI - Automation\n\n```yaml\n# lighthouserc.json\n{\n  \"ci\": {\n    \"collect\": {\n      \"url\": [\n        \"http://localhost:4200\",\n        \"http://localhost:4200/products\",\n        \"http://localhost:4200/about\"\n      ],\n      \"numberOfRuns\": 3,\n      \"settings\": {\n        \"chromeFlags\": [\"--no-sandbox\"],\n        \"onlyCategories\": [\"performance\", \"accessibility\", \"best-practices\", \"seo\"]\n      }\n    },\n    \"upload\": {\n      \"target\": \"temporary-public-storage\"\n    },\n    \"assert\": {\n      \"preset\": \"lighthouse:recommended\",\n      \"assertions\": {\n        \"categories:performance\": [\"error\", { \"minScore\": 0.9 }],\n        \"categories:accessibility\": [\"error\", { \"minScore\": 0.9 }],\n        \"categories:best-practices\": [\"error\", { \"minScore\": 0.9 }],\n        \"cumulativeLayoutShift\": [\"error\", { \"maxNumericValue\": 0.1 }],\n        \"largest-contentful-paint\": [\"error\", { \"maxNumericValue\": 2500 }],\n        \"first-input-delay\": [\"error\", { \"maxNumericValue\": 100 }]\n      }\n    }\n  }\n}\n```\n\n**GitHub Actions интеграция:**\n```yaml\n# .github/workflows/lighthouse.yml\nname: Lighthouse CI\n\non: [push, pull_request]\n\njobs:\n  lhci:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Run Lighthouse CI\n        uses: treosh/lighthouse-ci-action@v9\n        with:\n          configPath: './lighthouserc.json'\n          temporaryPublicStorage: true\n          uploadArtifacts: true\n          runs: 3\n```\n\n### Web Vitals Monitoring\n\n```typescript\n// web-vitals.service.ts\nimport {\n  getCLS,\n  getFID,\n  getFCP,\n  getLCP,\n  getTTFB\n} from 'web-vitals';\nimport { Injectable } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class WebVitalsService {\n  private metrics: Map<string, any> = new Map();\n\n  trackWebVitals() {\n    // Core Web Vitals\n    getCLS(metric => this.recordMetric('CLS', metric));\n    getFID(metric => this.recordMetric('FID', metric));\n    getLCP(metric => this.recordMetric('LCP', metric));\n\n    // Additional metrics\n    getFCP(metric => this.recordMetric('FCP', metric));\n    getTTFB(metric => this.recordMetric('TTFB', metric));\n\n    // Собственные метрики для Angular\n    this.trackCustomMetrics();\n  }\n\n  private recordMetric(name: string, metric: any) {\n    this.metrics.set(name, metric);\n\n    console.log(`${name}: ${metric.value}ms`);\n\n    // Отправляем на аналитику\n    this.sendToAnalytics(name, metric);\n\n    // Проверяем бюджет\n    this.checkBudget(name, metric.value);\n  }\n\n  private trackCustomMetrics() {\n    // Time to Interactive\n    const tti = performance.getEntriesByName('first-input');\n\n    // Angular component initialization time\n    const componentInitStart = performance.now();\n    setTimeout(() => {\n      const componentInitTime = performance.now() - componentInitStart;\n      console.log(`Component Init: ${componentInitTime}ms`);\n    }, 0);\n  }\n\n  private checkBudget(metric: string, value: number) {\n    const budgets = {\n      'LCP': 2500,    // 2.5s - хорошо\n      'FID': 100,     // 100ms - хорошо\n      'CLS': 0.1,     // 0.1 - хорошо\n      'FCP': 1800,    // 1.8s\n      'TTFB': 600     // 600ms\n    };\n\n    if (value > budgets[metric]) {\n      console.warn(\n        `Performance budget exceeded: ${metric} = ${value}ms (budget: ${budgets[metric]}ms)`\n      );\n\n      // Отправляем alert в систему мониторинга\n      this.sendAlert(metric, value, budgets[metric]);\n    }\n  }\n\n  private sendToAnalytics(metric: string, data: any) {\n    // Google Analytics\n    if (typeof gtag !== 'undefined') {\n      gtag('event', metric, {\n        value: Math.round(data.value),\n        event_category: 'Web Vitals',\n        event_label: data.id,\n        non_interaction: true\n      });\n    }\n  }\n\n  private sendAlert(metric: string, actual: number, budget: number) {\n    // Отправляем на backend для alerting\n    fetch('/api/metrics/alert', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        metric,\n        actual,\n        budget,\n        exceeded: true,\n        timestamp: new Date().toISOString(),\n        url: window.location.href\n      })\n    });\n  }\n}\n\n// main.ts\nconst vitalService = inject(WebVitalsService);\nvitalService.trackWebVitals();\n```\n\n### RUM vs Synthetic Monitoring\n\n**RUM (Real User Monitoring) - реальные пользователи:**\n```typescript\n// rum.service.ts - сбор данных от реальных пользователей\n@Injectable({ providedIn: 'root' })\nexport class RUMService {\n  private sessionId = this.generateSessionId();\n\n  constructor(private http: HttpClient) {\n    this.initializeRUMCollection();\n  }\n\n  private initializeRUMCollection() {\n    // Navigation Timing API\n    window.addEventListener('load', () => {\n      const navTiming = performance.getEntriesByType('navigation')[0];\n\n      this.sendMetrics({\n        type: 'navigation',\n        dns: navTiming.domainLookupEnd - navTiming.domainLookupStart,\n        tcp: navTiming.connectEnd - navTiming.connectStart,\n        ttfb: navTiming.responseStart - navTiming.requestStart,\n        download: navTiming.responseEnd - navTiming.responseStart,\n        domInteractive: navTiming.domInteractive,\n        domComplete: navTiming.domComplete,\n        loadComplete: navTiming.loadEventEnd\n      });\n    });\n\n    // Ошибки JavaScript\n    window.addEventListener('error', (event) => {\n      this.sendMetrics({\n        type: 'error',\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        stack: event.error?.stack\n      });\n    });\n\n    // Необработанные Promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      this.sendMetrics({\n        type: 'unhandled-rejection',\n        reason: event.reason,\n        promise: event.promise\n      });\n    });\n  }\n\n  private sendMetrics(data: any) {\n    this.http.post('/api/rum/metrics', {\n      sessionId: this.sessionId,\n      userId: this.getUserId(),\n      userAgent: navigator.userAgent,\n      ...data,\n      timestamp: new Date().toISOString()\n    }).subscribe();\n  }\n\n  private generateSessionId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getUserId(): string | null {\n    // Получаем ID текущего пользователя из приложения\n    return localStorage.getItem('user_id');\n  }\n}\n```\n\n**Synthetic Monitoring - контролируемые тесты:**\n```typescript\n// synthetic-monitoring.ts - автоматическое тестирование performance\nimport * as puppeteer from 'puppeteer';\n\nasync function runSyntheticTests() {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n\n  // Отключаем кэш для имитации холодного старта\n  await page.setCacheEnabled(false);\n\n  // Network throttling - 4G сеть\n  const client = await page.target().createCDPSession();\n  await client.send('Network.emulateNetworkConditions', {\n    offline: false,\n    downloadThroughput: 1.6 * 1024 * 1024 / 8,  // 1.6 Mbps\n    uploadThroughput: 750 * 1024 / 8,            // 750 kbps\n    latency: 40                                   // 40ms\n  });\n\n  // Измеряем метрики\n  const metrics = await page.evaluate(() => {\n    const nav = performance.getEntriesByType('navigation')[0];\n    const paint = performance.getEntriesByType('paint');\n\n    return {\n      fcp: paint.find(p => p.name === 'first-contentful-paint')?.startTime,\n      lcp: performance.getEntriesByType('largest-contentful-paint').pop()?.startTime,\n      tti: performance.getEntriesByName('first-input').pop()?.startTime,\n      loadComplete: nav.loadEventEnd,\n      domInteractive: nav.domInteractive\n    };\n  });\n\n  console.log('Synthetic Monitoring Results:', metrics);\n\n  // Отправляем результаты на backend\n  await fetch('http://localhost:3000/api/synthetic-metrics', {\n    method: 'POST',\n    body: JSON.stringify({\n      ...metrics,\n      environment: 'synthetic',\n      timestamp: new Date().toISOString()\n    })\n  });\n\n  await browser.close();\n}\n\n// Запускается по расписанию (cron job)\nrunSyntheticTests().catch(console.error);\n```\n\n### Alerting System\n\n```typescript\n// performance-alerting.service.ts\n@Injectable({ providedIn: 'root' })\nexport class PerformanceAlertingService {\n  private thresholds = {\n    lcp: { warn: 2500, critical: 4000 },\n    fid: { warn: 100, critical: 300 },\n    cls: { warn: 0.1, critical: 0.25 },\n    errorRate: { warn: 0.01, critical: 0.05 }\n  };\n\n  checkAndAlert(metric: string, value: number) {\n    const threshold = this.thresholds[metric];\n\n    if (value > threshold.critical) {\n      this.sendCriticalAlert(metric, value);\n    } else if (value > threshold.warn) {\n      this.sendWarning(metric, value);\n    }\n  }\n\n  private sendCriticalAlert(metric: string, value: number) {\n    // Отправляем PagerDuty/Slack alert\n    fetch('https://api.pagerduty.com/incidents', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Token token=${process.env.PAGERDUTY_TOKEN}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        incident: {\n          type: 'incident',\n          title: `CRITICAL: ${metric} exceeded (${value}ms)`,\n          service: {\n            type: 'service_reference',\n            id: process.env.SERVICE_ID\n          },\n          urgency: 'high'\n        }\n      })\n    });\n  }\n\n  private sendWarning(metric: string, value: number) {\n    // Отправляем Slack notification\n    const slackMessage = {\n      text: `Performance Warning: ${metric} = ${value}ms`,\n      attachments: [{\n        color: 'warning',\n        fields: [\n          { title: 'Metric', value: metric },\n          { title: 'Actual', value: `${value}ms` },\n          { title: 'Budget', value: `${this.thresholds[metric].warn}ms` },\n          { title: 'URL', value: window.location.href }\n        ]\n      }]\n    };\n\n    fetch(process.env.SLACK_WEBHOOK_URL, {\n      method: 'POST',\n      body: JSON.stringify(slackMessage)\n    });\n  }\n}\n```\n\n### Dashboard для мониторинга\n\n```typescript\n// performance-dashboard.component.ts\n@Component({\n  selector: 'app-performance-dashboard',\n  template: `\n    <div class=\"dashboard\">\n      <h1>Performance Metrics Dashboard</h1>\n\n      <div class=\"metrics-grid\">\n        <div class=\"metric-card\"\n             [class.good]=\"lcp < 2500\"\n             [class.warning]=\"lcp >= 2500 && lcp < 4000\"\n             [class.critical]=\"lcp >= 4000\">\n          <h3>LCP</h3>\n          <p class=\"value\">{{ lcp }}ms</p>\n          <p class=\"status\">{{ getLCPStatus() }}</p>\n        </div>\n\n        <div class=\"metric-card\"\n             [class.good]=\"fid < 100\"\n             [class.warning]=\"fid >= 100 && fid < 300\"\n             [class.critical]=\"fid >= 300\">\n          <h3>FID</h3>\n          <p class=\"value\">{{ fid }}ms</p>\n          <p class=\"status\">{{ getFIDStatus() }}</p>\n        </div>\n\n        <div class=\"metric-card\"\n             [class.good]=\"cls < 0.1\"\n             [class.warning]=\"cls >= 0.1 && cls < 0.25\"\n             [class.critical]=\"cls >= 0.25\">\n          <h3>CLS</h3>\n          <p class=\"value\">{{ cls }}</p>\n          <p class=\"status\">{{ getCLSStatus() }}</p>\n        </div>\n      </div>\n\n      <div class=\"budget-status\">\n        <h2>Performance Budget Status</h2>\n        <div *ngFor=\"let budget of budgetStatus\" class=\"budget-item\">\n          <span>{{ budget.name }}</span>\n          <div class=\"progress-bar\"\n               [style.width.%]=\"(budget.used / budget.limit) * 100\"\n               [class.exceeded]=\"budget.used > budget.limit\">\n          </div>\n          <span>{{ budget.used }}{{ budget.unit }} / {{ budget.limit }}{{ budget.unit }}</span>\n        </div>\n      </div>\n    </div>\n  `,\n  styles: [`\n    .metrics-grid {\n      display: grid;\n      grid-template-columns: repeat(3, 1fr);\n      gap: 20px;\n    }\n\n    .metric-card {\n      padding: 20px;\n      border-radius: 8px;\n      background: #f5f5f5;\n    }\n\n    .metric-card.good {\n      border-left: 4px solid #4caf50;\n    }\n\n    .metric-card.warning {\n      border-left: 4px solid #ff9800;\n    }\n\n    .metric-card.critical {\n      border-left: 4px solid #f44336;\n    }\n\n    .value {\n      font-size: 24px;\n      font-weight: bold;\n      margin: 10px 0;\n    }\n\n    .progress-bar {\n      height: 8px;\n      background: #4caf50;\n      border-radius: 4px;\n      transition: all 0.3s;\n    }\n\n    .progress-bar.exceeded {\n      background: #f44336;\n    }\n  `]\n})\nexport class PerformanceDashboardComponent {\n  lcp: number = 0;\n  fid: number = 0;\n  cls: number = 0;\n  budgetStatus: any[] = [];\n\n  constructor(private metricsService: WebVitalsService) {\n    this.loadMetrics();\n  }\n\n  private loadMetrics() {\n    setInterval(() => {\n      // Загружаем свежие метрики с backend\n      fetch('/api/metrics/current').then(r => r.json()).then(data => {\n        this.lcp = data.lcp;\n        this.fid = data.fid;\n        this.cls = data.cls;\n        this.budgetStatus = data.budgets;\n      });\n    }, 5000);\n  }\n\n  getLCPStatus(): string {\n    if (this.lcp < 2500) return 'Хорошо';\n    if (this.lcp < 4000) return 'Требует внимания';\n    return 'Критично';\n  }\n\n  getFIDStatus(): string {\n    if (this.fid < 100) return 'Хорошо';\n    if (this.fid < 300) return 'Требует внимания';\n    return 'Критично';\n  }\n\n  getCLSStatus(): string {\n    if (this.cls < 0.1) return 'Хорошо';\n    if (this.cls < 0.25) return 'Требует внимания';\n    return 'Критично';\n  }\n}\n```",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 8,
      "chapter_title": "Testing",
      "questions": [
        {
          "question_number": 63,
          "question_number_in_chapter": 1,
          "question_chapter": 8,
          "question_title": "Unit Testing components? TestBed, ComponentFixture?",
          "answer_markdown": "```typescript\ndescribe('UserComponent', () => {\n  let component: UserComponent;\n  let fixture: ComponentFixture<UserComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [UserComponent]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(UserComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should display user name', () => {\n    component.user = { name: 'John' };\n    fixture.detectChanges();\n    \n    const element = fixture.nativeElement.querySelector('h1');\n    editButton: (userId: string) => `[data-test=\"edit-user-${userId}\"]`,\n    deleteButton: (userId: string) => `[data-test=\"delete-user-${userId}\"]`\n  };\n\n  visit() {\n    cy.visit('/dashboard');\n    return this;\n  }\n\n  searchUser(query: string) {\n    cy.get(this.selectors.searchInput).clear().type(query);\n    return this;\n  }\n\n  clickAddUser() {\n    cy.get(this.selectors.addUserButton).click();\n    return this;\n  }\n\n  editUser(userId: string) {\n    cy.get(this.selectors.editButton(userId)).click();\n    return this;\n  }\n\n  deleteUser(userId: string) {\n    cy.get(this.selectors.deleteButton(userId)).click();\n    // Подтверждение в модалке\n    cy.get('[data-test=\"confirm-delete\"]').click();\n    return this;\n  }\n\n  verifyUserExists(userId: string) {\n    cy.get(this.selectors.userRow(userId)).should('be.visible');\n    return this;\n  }\n\n  verifyUserNotExists(userId: string) {\n    cy.get(this.selectors.userRow(userId)).should('not.exist');\n    return this;\n  }\n\n  getUserCount() {\n    return cy.get(`${this.selectors.userTable} tbody tr`).its('length');\n  }\n\n  // Ожидание загрузки данных с API\n  waitForTableLoad() {\n    cy.wait('@getUsers');\n    cy.get(this.selectors.userTable).should('be.visible');\n    return this;\n  }\n}\n```\n\n**Playwright Page Object (более продвинутый):**\n```typescript\n// e2e/pages/dashboard.page.ts\nimport { Page, Locator, expect } from '@playwright/test';\n\nexport class DashboardPage {\n  readonly page: Page;\n\n  // Locators\n  readonly userTable: Locator;\n  readonly addUserButton: Locator;\n  readonly searchInput: Locator;\n  readonly loadingSpinner: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n    this.userTable = page.getByTestId('user-table');\n    this.addUserButton = page.getByTestId('add-user-btn');\n    this.searchInput = page.getByTestId('search-input');\n    this.loadingSpinner = page.getByTestId('loading-spinner');\n  }\n\n  async goto() {\n    await this.page.goto('/dashboard');\n    await this.waitForLoad();\n  }\n\n  async waitForLoad() {\n    // Ждем пока исчезнет спиннер\n    await this.loadingSpinner.waitFor({ state: 'hidden' });\n    // Ждем появления таблицы\n    await this.userTable.waitFor({ state: 'visible' });\n  }\n\n  async searchUser(query: string) {\n    await this.searchInput.fill(query);\n    await this.waitForLoad();\n  }\n\n  async addUser(userData: { name: string; email: string }) {\n    await this.addUserButton.click();\n\n    // Ждем открытия модалки\n    const modal = this.page.getByTestId('user-modal');\n    await modal.waitFor({ state: 'visible' });\n\n    await this.page.getByLabel('Name').fill(userData.name);\n    await this.page.getByLabel('Email').fill(userData.email);\n    await this.page.getByTestId('save-user').click();\n\n    // Ждем закрытия модалки\n    await modal.waitFor({ state: 'hidden' });\n    await this.waitForLoad();\n  }\n\n  async editUser(userId: string, newData: Partial<{ name: string; email: string }>) {\n    await this.getUserRow(userId).getByTestId('edit-btn').click();\n\n    if (newData.name) {\n      await this.page.getByLabel('Name').fill(newData.name);\n    }\n    if (newData.email) {\n      await this.page.getByLabel('Email').fill(newData.email);\n    }\n\n    await this.page.getByTestId('save-user').click();\n    await this.waitForLoad();\n  }\n\n  async deleteUser(userId: string) {\n    await this.getUserRow(userId).getByTestId('delete-btn').click();\n    await this.page.getByTestId('confirm-delete').click();\n    await this.waitForLoad();\n  }\n\n  getUserRow(userId: string): Locator {\n    return this.page.getByTestId(`user-row-${userId}`);\n  }\n\n  async verifyUserExists(userId: string, expectedData?: { name?: string; email?: string }) {\n    const row = this.getUserRow(userId);\n    await expect(row).toBeVisible();\n\n    if (expectedData?.name) {\n      await expect(row.getByTestId('user-name')).toHaveText(expectedData.name);\n    }\n    if (expectedData?.email) {\n      await expect(row.getByTestId('user-email')).toHaveText(expectedData.email);\n    }\n  }\n\n  async verifyUserNotExists(userId: string) {\n    await expect(this.getUserRow(userId)).not.toBeVisible();\n  }\n\n  async getUserCount(): Promise<number> {\n    return await this.userTable.locator('tbody tr').count();\n  }\n\n  // API mocking helper\n  async mockUsersAPI(users: any[]) {\n    await this.page.route('/api/users*', (route) => {\n      route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify(users)\n      });\n    });\n  }\n}\n```\n\n#### CI/CD Integration\n\n**GitHub Actions для Cypress:**\n```yaml\n# .github/workflows/cypress.yml\nname: Cypress E2E Tests\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main, develop]\n\njobs:\n  cypress-run:\n    runs-on: ubuntu-22.04\n    strategy:\n      fail-fast: false\n      matrix:\n        containers: [1, 2, 3, 4] # Параллелизация на 4 машины\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Build Angular app\n        run: npm run build:prod\n\n      - name: Start server\n        run: npm run start:ci &\n\n      - name: Wait for server\n        run: npx wait-on http://localhost:4200 --timeout 60000\n\n      - name: Run Cypress tests\n        uses: cypress-io/github-action@v5\n        with:\n          browser: chrome\n          record: true\n          parallel: true\n          group: 'E2E Tests'\n          ci-build-id: ${{ github.sha }}-${{ github.run_number }}\n        env:\n          CYPRESS_RECORD_KEY: ${{ secrets.CYPRESS_RECORD_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Upload screenshots\n        uses: actions/upload-artifact@v3\n        if: failure()\n        with:\n          name: cypress-screenshots\n          path: cypress/screenshots\n\n      - name: Upload videos\n        uses: actions/upload-artifact@v3\n        if: always()\n        with:\n          name: cypress-videos\n          path: cypress/videos\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        with:\n          files: ./coverage/coverage-final.json\n          flags: e2e\n```\n\n**GitLab CI для Playwright:**\n```yaml\n# .gitlab-ci.yml\nstages:\n  - build\n  - test\n  - report\n\nvariables:\n  npm_config_cache: \"$CI_PROJECT_DIR/.npm\"\n  PLAYWRIGHT_BROWSERS_PATH: \"$CI_PROJECT_DIR/.playwright-browsers\"\n\ncache:\n  paths:\n    - .npm\n    - .playwright-browsers\n    - node_modules\n\nbuild:\n  stage: build\n  image: node:18\n  script:\n    - npm ci\n    - npm run build:prod\n  artifacts:\n    paths:\n      - dist/\n    expire_in: 1 day\n\nplaywright-tests:\n  stage: test\n  image: mcr.microsoft.com/playwright:v1.40.0-jammy\n  parallel:\n    matrix:\n      - PROJECT: [chromium, firefox, webkit]\n  script:\n    - npm ci\n    - npx playwright install --with-deps $PROJECT\n    - npx playwright test --project=$PROJECT --reporter=html,junit\n  artifacts:\n    when: always\n    paths:\n      - playwright-report/\n      - test-results/\n    reports:\n      junit: test-results/junit.xml\n    expire_in: 30 days\n\npages:\n  stage: report\n  dependencies:\n    - playwright-tests\n  script:\n    - mkdir -p public/playwright\n    - cp -r playwright-report/* public/playwright/\n  artifacts:\n    paths:\n      - public\n  only:\n    - main\n```\n\n**Docker-based CI (для любого CI/CD):**\n```dockerfile\n# Dockerfile.e2e\nFROM mcr.microsoft.com/playwright:v1.40.0-jammy\n\nWORKDIR /app\n\n# Копируем package files\nCOPY package*.json ./\nRUN npm ci\n\n# Копируем весь проект\nCOPY . .\n\n# Собираем приложение\nRUN npm run build\n\n# Expose порт для приложения\nEXPOSE 4200\n\n# Скрипт для запуска тестов\nCOPY docker-entrypoint.sh /\nRUN chmod +x /docker-entrypoint.sh\n\nENTRYPOINT [\"/docker-entrypoint.sh\"]\n```\n\n```bash\n#!/bin/bash\n# docker-entrypoint.sh\n\nset -e\n\n# Запускаем Angular приложение в фоне\nnpm run start:prod &\n\n# Ждем запуска сервера\nnpx wait-on http://localhost:4200 --timeout 60000\n\n# Запускаем Playwright тесты\nnpx playwright test \"$@\"\n\n# Сохраняем exit code\nEXIT_CODE=$?\n\n# Останавливаем сервер\npkill -f \"ng serve\"\n\nexit $EXIT_CODE\n```\n\n**package.json scripts для CI:**\n```json\n{\n  \"scripts\": {\n    \"start:ci\": \"ng serve --host 0.0.0.0 --disable-host-check\",\n    \"start:prod\": \"ng serve --configuration=production\",\n    \"e2e\": \"cypress run\",\n    \"e2e:headed\": \"cypress run --headed\",\n    \"e2e:chrome\": \"cypress run --browser chrome\",\n    \"e2e:firefox\": \"cypress run --browser firefox\",\n    \"pw:test\": \"playwright test\",\n    \"pw:test:headed\": \"playwright test --headed\",\n    \"pw:test:debug\": \"playwright test --debug\",\n    \"pw:report\": \"playwright show-report\",\n    \"test:e2e:ci\": \"start-server-and-test start:ci http://localhost:4200 e2e\"\n  }\n}\n```\n\n#### Best Practices для Senior-level\n\n1. **Стабильность тестов:**\n   - Используйте `data-test` / `data-testid` атрибуты вместо CSS классов\n   - Внедряйте автоматические retry механизмы\n   - Используйте явные ожидания вместо `wait()` / `sleep()`\n\n2. **Параллелизация:**\n   - Cypress: `parallel: true` с Cypress Cloud\n   - Playwright: `fullyParallel: true` из коробки\n   - Разделяйте тесты на независимые группы\n\n3. **Мокирование API:**\n   - Используйте fixtures для предсказуемых данных\n   - Мокируйте медленные/нестабильные endpoints\n   - Тестируйте edge cases через моки\n\n4. **Debugging в CI:**\n   - Сохраняйте screenshots при падении\n   - Записывайте видео\n   - Используйте trace viewer (Playwright) или Time Travel (Cypress)\n\n5. **Метрики и мониторинг:**\n   - Интегрируйте с Cypress Dashboard / Playwright Trace Viewer\n   - Отслеживайте flaky tests\n   - Мониторьте время выполнения тестов\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 64,
          "question_number_in_chapter": 2,
          "question_chapter": 8,
          "question_title": "E2E Testing - Cypress vs Playwright. Настройка, Page Objects Pattern, CI/CD Integration",
          "answer_markdown": "**Ответ:**\n\nEnd-to-end тестирование в Angular-приложениях на Senior-уровне требует выбора между современными фреймворками, понимания архитектурных паттернов и интеграции в CI/CD pipeline.\n\n#### Сравнение Cypress vs Playwright\n\n**Cypress:**\n- **Преимущества:**\n  - Отличный DX (Developer Experience) с Time Travel debugging\n  - Автоматические ожидания и retry механизмы\n  - Встроенный Dashboard для визуализации результатов\n  - Простая настройка для Angular через `@cypress/schematic`\n  - Real-time reloading при изменениях тестов\n\n- **Недостатки:**\n  - Ограничение одним браузером в открытом окне\n  - Не поддерживает Safari (только Chrome, Firefox, Edge)\n  - Проблемы с multi-tab/multi-window тестированием\n  - Медленнее Playwright на больших тест-сьютах\n\n**Playwright:**\n- **Преимущества:**\n  - Поддержка всех браузеров (Chrome, Firefox, Safari, Edge)\n  - Параллельное выполнение тестов из коробки\n  - Multi-context: возможность тестировать несколько вкладок/окон\n  - Быстрее Cypress на 20-40% на больших проектах\n  - Лучше работает с мобильными браузерами (device emulation)\n  - Встроенная поддержка API тестирования\n\n- **Недостатки:**\n  - Менее зрелая экосистема плагинов\n  - Debugging сложнее чем в Cypress\n  - Требует больше конфигурации для Angular-специфичных вещей\n\n#### Настройка Cypress для Angular\n\n**Установка:**\n```bash\nng add @cypress/schematic\n```\n\n**cypress.config.ts:**\n```typescript\nimport { defineConfig } from 'cypress';\n\nexport default defineConfig({\n  e2e: {\n    baseUrl: 'http://localhost:4200',\n    specPattern: 'cypress/e2e/**/*.cy.ts',\n    supportFile: 'cypress/support/e2e.ts',\n    video: true,\n    videosFolder: 'cypress/videos',\n    screenshotsFolder: 'cypress/screenshots',\n    viewportWidth: 1280,\n    viewportHeight: 720,\n\n    // Retry для flaky тестов\n    retries: {\n      runMode: 2,\n      openMode: 0\n    },\n\n    // Timeout настройки\n    defaultCommandTimeout: 10000,\n    pageLoadTimeout: 60000,\n\n    setupNodeEvents(on, config) {\n      // Кастомные плагины\n      on('task', {\n        log(message) {\n          console.log(message);\n          return null;\n        }\n      });\n\n      // Code coverage\n      require('@cypress/code-coverage/task')(on, config);\n\n      return config;\n    }\n  },\n\n  component: {\n    devServer: {\n      framework: 'angular',\n      bundler: 'webpack'\n    },\n    specPattern: '**/*.cy.ts'\n  }\n});\n```\n\n**cypress/support/commands.ts (кастомные команды):**\n```typescript\ndeclare global {\n  namespace Cypress {\n    interface Chainable {\n      login(email: string, password: string): Chainable<void>;\n      getBySel(selector: string): Chainable<JQuery<HTMLElement>>;\n      getByTestId(testId: string): Chainable<JQuery<HTMLElement>>;\n      setupInterceptors(): Chainable<void>;\n    }\n  }\n}\n\n// Команда для логина через UI\nCypress.Commands.add('login', (email: string, password: string) => {\n  cy.session([email, password], () => {\n    cy.visit('/login');\n    cy.get('[data-test=\"email-input\"]').type(email);\n    cy.get('[data-test=\"password-input\"]').type(password);\n    cy.get('[data-test=\"login-button\"]').click();\n    cy.url().should('include', '/dashboard');\n\n    // Сохраняем токен в sessionStorage\n    cy.window().its('sessionStorage').invoke('getItem', 'authToken').should('exist');\n  });\n});\n\n// Селектор по data-test атрибуту\nCypress.Commands.add('getBySel', (selector: string) => {\n  return cy.get(`[data-test=\"${selector}\"]`);\n});\n\nCypress.Commands.add('getByTestId', (testId: string) => {\n  return cy.get(`[data-testid=\"${testId}\"]`);\n});\n\n// Настройка часто используемых interceptors\nCypress.Commands.add('setupInterceptors', () => {\n  cy.intercept('GET', '/api/users*', { fixture: 'users.json' }).as('getUsers');\n  cy.intercept('POST', '/api/users', { statusCode: 201 }).as('createUser');\n  cy.intercept('PUT', '/api/users/*', { statusCode: 200 }).as('updateUser');\n});\n```\n\n#### Настройка Playwright для Angular\n\n**Установка:**\n```bash\nnpm install -D @playwright/test\nnpx playwright install\n```\n\n**playwright.config.ts:**\n```typescript\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './e2e',\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: [\n    ['html'],\n    ['junit', { outputFile: 'test-results/junit.xml' }],\n    ['json', { outputFile: 'test-results/results.json' }]\n  ],\n\n  use: {\n    baseURL: 'http://localhost:4200',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure',\n\n    // Angular specific\n    actionTimeout: 10000,\n    navigationTimeout: 30000\n  },\n\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] }\n    },\n    {\n      name: 'firefox',\n      use: { ...devices['Desktop Firefox'] }\n    },\n    {\n      name: 'webkit',\n      use: { ...devices['Desktop Safari'] }\n    },\n    {\n      name: 'Mobile Chrome',\n      use: { ...devices['Pixel 5'] }\n    },\n    {\n      name: 'Mobile Safari',\n      use: { ...devices['iPhone 13'] }\n    }\n  ],\n\n  webServer: {\n    command: 'npm run start',\n    url: 'http://localhost:4200',\n    reuseExistingServer: !process.env.CI,\n    timeout: 120000\n  }\n});\n```\n\n**e2e/fixtures/base.fixture.ts (продвинутые fixtures):**\n```typescript\nimport { test as base } from '@playwright/test';\nimport { LoginPage } from '../pages/login.page';\nimport { DashboardPage } from '../pages/dashboard.page';\n\ntype MyFixtures = {\n  loginPage: LoginPage;\n  dashboardPage: DashboardPage;\n  authenticatedPage: DashboardPage;\n};\n\nexport const test = base.extend<MyFixtures>({\n  loginPage: async ({ page }, use) => {\n    const loginPage = new LoginPage(page);\n    await use(loginPage);\n  },\n\n  dashboardPage: async ({ page }, use) => {\n    const dashboardPage = new DashboardPage(page);\n    await use(dashboardPage);\n  },\n\n  // Фикстура для автоматической авторизации\n  authenticatedPage: async ({ page, dashboardPage }, use) => {\n    // Используем saved auth state\n    await page.goto('/');\n    await page.context().addCookies([\n      {\n        name: 'auth_token',\n        value: process.env.TEST_AUTH_TOKEN!,\n        domain: 'localhost',\n        path: '/'\n      }\n    ]);\n    await dashboardPage.goto();\n    await use(dashboardPage);\n  }\n});\n\nexport { expect } from '@playwright/test';\n```\n\n#### Page Object Pattern (Advanced)\n\n**Cypress Page Object:**\n```typescript\n// cypress/pages/dashboard.page.ts\nexport class DashboardPage {\n  private readonly selectors = {\n    userTable: '[data-test=\"user-table\"]',\n    addUserButton: '[data-test=\"add-user-btn\"]',\n    searchInput: '[data-test=\"search-input\"]',\n    userRow: (userId: string) => `[data-test=\"user-row-${userId}\"]`,",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 65,
          "question_number_in_chapter": 3,
          "question_chapter": 8,
          "question_title": "Integration Testing - тестирование взаимодействия компонентов, Services, HTTP, Routing. TestBed Advanced Usage",
          "answer_markdown": "**Ответ:**\n\nIntegration тестирование в Angular требует глубокого понимания TestBed, dependency injection, и механизмов взаимодействия между компонентами.\n\n#### TestBed Advanced Configuration\n\n**Базовая настройка TestBed:**\n```typescript\nimport { ComponentFixture, TestBed, fakeAsync, tick, flush } from '@angular/core/testing';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { RouterTestingModule } from '@angular/router/testing';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { DebugElement } from '@angular/core';\nimport { By } from '@angular/platform-browser';\n\ndescribe('UserListComponent Integration Tests', () => {\n  let component: UserListComponent;\n  let fixture: ComponentFixture<UserListComponent>;\n  let httpMock: HttpTestingController;\n  let compiled: HTMLElement;\n  let debugElement: DebugElement;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [\n        UserListComponent,\n        UserCardComponent,\n        UserFilterPipe\n      ],\n      imports: [\n        HttpClientTestingModule,\n        RouterTestingModule.withRoutes([\n          { path: 'users/:id', component: UserDetailComponent }\n        ]),\n        BrowserAnimationsModule,\n        CommonModule,\n        FormsModule,\n        ReactiveFormsModule\n      ],\n      providers: [\n        UserService,\n        { provide: API_BASE_URL, useValue: 'http://localhost:3000/api' },\n        {\n          provide: AuthService,\n          useValue: jasmine.createSpyObj('AuthService', ['isAuthenticated', 'getToken'])\n        }\n      ]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(UserListComponent);\n    component = fixture.componentInstance;\n    httpMock = TestBed.inject(HttpTestingController);\n    compiled = fixture.nativeElement;\n    debugElement = fixture.debugElement;\n  });\n\n  afterEach(() => {\n    httpMock.verify(); // Проверяем что все HTTP запросы были обработаны\n  });\n});\n```\n\n#### Тестирование взаимодействия компонентов (Parent-Child)\n\n**Parent Component:**\n```typescript\n// parent.component.ts\n@Component({\n  selector: 'app-user-dashboard',\n  template: `\n    <div class=\"dashboard\">\n      <app-user-filter\n        (filterChanged)=\"onFilterChanged($event)\"\n        [initialFilter]=\"currentFilter\">\n      </app-user-filter>\n\n      <app-user-list\n        [users]=\"filteredUsers\"\n        (userSelected)=\"onUserSelected($event)\"\n        (userDeleted)=\"onUserDeleted($event)\">\n      </app-user-list>\n\n      <app-user-details\n        *ngIf=\"selectedUser\"\n        [user]=\"selectedUser\"\n        (userUpdated)=\"onUserUpdated($event)\">\n      </app-user-details>\n    </div>\n  `\n})\nexport class UserDashboardComponent implements OnInit {\n  users: User[] = [];\n  filteredUsers: User[] = [];\n  selectedUser: User | null = null;\n  currentFilter: UserFilter = {};\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    this.loadUsers();\n  }\n\n  loadUsers() {\n    this.userService.getUsers().subscribe(users => {\n      this.users = users;\n      this.applyFilter();\n    });\n  }\n\n  onFilterChanged(filter: UserFilter) {\n    this.currentFilter = filter;\n    this.applyFilter();\n  }\n\n  applyFilter() {\n    this.filteredUsers = this.users.filter(user => {\n      if (this.currentFilter.role && user.role !== this.currentFilter.role) {\n        return false;\n      }\n      if (this.currentFilter.search) {\n        const searchLower = this.currentFilter.search.toLowerCase();\n        return user.name.toLowerCase().includes(searchLower) ||\n               user.email.toLowerCase().includes(searchLower);\n      }\n      return true;\n    });\n  }\n\n  onUserSelected(user: User) {\n    this.selectedUser = user;\n  }\n\n  onUserDeleted(userId: string) {\n    this.userService.deleteUser(userId).subscribe(() => {\n      this.users = this.users.filter(u => u.id !== userId);\n      if (this.selectedUser?.id === userId) {\n        this.selectedUser = null;\n      }\n      this.applyFilter();\n    });\n  }\n\n  onUserUpdated(user: User) {\n    const index = this.users.findIndex(u => u.id === user.id);\n    if (index !== -1) {\n      this.users[index] = user;\n      this.selectedUser = user;\n      this.applyFilter();\n    }\n  }\n}\n```\n\n**Integration Test для Parent-Child взаимодействия:**\n```typescript\ndescribe('UserDashboardComponent Integration', () => {\n  let component: UserDashboardComponent;\n  let fixture: ComponentFixture<UserDashboardComponent>;\n  let httpMock: HttpTestingController;\n  let filterComponent: UserFilterComponent;\n  let listComponent: UserListComponent;\n\n  const mockUsers: User[] = [\n    { id: '1', name: 'John Doe', email: 'john@example.com', role: 'admin' },\n    { id: '2', name: 'Jane Smith', email: 'jane@example.com', role: 'user' },\n    { id: '3', name: 'Bob Johnson', email: 'bob@example.com', role: 'user' }\n  ];\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [\n        UserDashboardComponent,\n        UserFilterComponent,\n        UserListComponent,\n        UserDetailsComponent\n      ],\n      imports: [\n        HttpClientTestingModule,\n        CommonModule,\n        FormsModule,\n        ReactiveFormsModule\n      ],\n      providers: [UserService]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(UserDashboardComponent);\n    component = fixture.componentInstance;\n    httpMock = TestBed.inject(HttpTestingController);\n  });\n\n  afterEach(() => {\n    httpMock.verify();\n  });\n\n  describe('Component Communication', () => {\n    it('should filter users when filter is changed in child component', fakeAsync(() => {\n      // Arrange\n      fixture.detectChanges();\n      const req = httpMock.expectOne('/api/users');\n      req.flush(mockUsers);\n      tick();\n      fixture.detectChanges();\n\n      // Act - эмулируем изменение фильтра через child component\n      const filterDebug = fixture.debugElement.query(By.directive(UserFilterComponent));\n      filterComponent = filterDebug.componentInstance;\n\n      filterComponent.filterChanged.emit({ role: 'admin' });\n      tick();\n      fixture.detectChanges();\n\n      // Assert\n      expect(component.filteredUsers.length).toBe(1);\n      expect(component.filteredUsers[0].role).toBe('admin');\n\n      // Проверяем что UserListComponent получил отфильтрованные данные\n      const listDebug = fixture.debugElement.query(By.directive(UserListComponent));\n      listComponent = listDebug.componentInstance;\n      expect(listComponent.users.length).toBe(1);\n    }));\n\n    it('should show user details when user is selected from list', fakeAsync(() => {\n      // Arrange\n      fixture.detectChanges();\n      const req = httpMock.expectOne('/api/users');\n      req.flush(mockUsers);\n      tick();\n      fixture.detectChanges();\n\n      // Act\n      const listDebug = fixture.debugElement.query(By.directive(UserListComponent));\n      listComponent = listDebug.componentInstance;\n      listComponent.userSelected.emit(mockUsers[0]);\n      tick();\n      fixture.detectChanges();\n\n      // Assert\n      expect(component.selectedUser).toEqual(mockUsers[0]);\n\n      // Проверяем что UserDetailsComponent появился и получил данные\n      const detailsDebug = fixture.debugElement.query(By.directive(UserDetailsComponent));\n      expect(detailsDebug).toBeTruthy();\n      expect(detailsDebug.componentInstance.user).toEqual(mockUsers[0]);\n    }));\n\n    it('should update user across all components when edited', fakeAsync(() => {\n      // Arrange - загружаем пользователей и выбираем одного\n      fixture.detectChanges();\n      const req = httpMock.expectOne('/api/users');\n      req.flush(mockUsers);\n      tick();\n      fixture.detectChanges();\n\n      const listDebug = fixture.debugElement.query(By.directive(UserListComponent));\n      listComponent = listDebug.componentInstance;\n      listComponent.userSelected.emit(mockUsers[0]);\n      tick();\n      fixture.detectChanges();\n\n      // Act - редактируем пользователя\n      const updatedUser = { ...mockUsers[0], name: 'John Updated' };\n      const detailsDebug = fixture.debugElement.query(By.directive(UserDetailsComponent));\n      const detailsComponent = detailsDebug.componentInstance;\n\n      detailsComponent.userUpdated.emit(updatedUser);\n      tick();\n      fixture.detectChanges();\n\n      // Assert\n      expect(component.users[0].name).toBe('John Updated');\n      expect(component.selectedUser?.name).toBe('John Updated');\n      expect(listComponent.users[0].name).toBe('John Updated');\n    }));\n\n    it('should remove user from list and hide details when deleted', fakeAsync(() => {\n      // Arrange\n      fixture.detectChanges();\n      httpMock.expectOne('/api/users').flush(mockUsers);\n      tick();\n      fixture.detectChanges();\n\n      // Выбираем пользователя\n      const listDebug = fixture.debugElement.query(By.directive(UserListComponent));\n      listComponent = listDebug.componentInstance;\n      listComponent.userSelected.emit(mockUsers[0]);\n      tick();\n      fixture.detectChanges();\n\n      expect(fixture.debugElement.query(By.directive(UserDetailsComponent))).toBeTruthy();\n\n      // Act - удаляем пользователя\n      listComponent.userDeleted.emit(mockUsers[0].id);\n      tick();\n\n      const deleteReq = httpMock.expectOne(`/api/users/${mockUsers[0].id}`);\n      deleteReq.flush({});\n      tick();\n      fixture.detectChanges();\n\n      // Assert\n      expect(component.users.length).toBe(2);\n      expect(component.selectedUser).toBeNull();\n      expect(fixture.debugElement.query(By.directive(UserDetailsComponent))).toBeFalsy();\n    }));\n  });\n});\n```\n\n#### Тестирование Services с HTTP\n\n**Service с комплексной логикой:**\n```typescript\n// user.service.ts\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private baseUrl = '/api/users';\n  private usersCache$ = new BehaviorSubject<User[]>([]);\n\n  constructor(\n    private http: HttpClient,\n    private authService: AuthService,\n    private loggingService: LoggingService\n  ) {}\n\n  getUsers(refresh = false): Observable<User[]> {\n    if (!refresh && this.usersCache$.value.length > 0) {\n      return this.usersCache$.asObservable();\n    }\n\n    return this.http.get<User[]>(this.baseUrl).pipe(\n      tap(users => {\n        this.usersCache$.next(users);\n        this.loggingService.log('Users loaded', users.length);\n      }),\n      catchError(error => {\n        this.loggingService.error('Failed to load users', error);\n        return throwError(() => new Error('Failed to load users'));\n      })\n    );\n  }\n\n  getUserById(id: string): Observable<User> {\n    // Сначала проверяем кэш\n    const cached = this.usersCache$.value.find(u => u.id === id);\n    if (cached) {\n      return of(cached);\n    }\n\n    return this.http.get<User>(`${this.baseUrl}/${id}`).pipe(\n      catchError(error => {\n        this.loggingService.error(`Failed to load user ${id}`, error);\n        return throwError(() => error);\n      })\n    );\n  }\n\n  createUser(user: Omit<User, 'id'>): Observable<User> {\n    return this.http.post<User>(this.baseUrl, user, {\n      headers: {\n        'Authorization': `Bearer ${this.authService.getToken()}`\n      }\n    }).pipe(\n      tap(newUser => {\n        const users = this.usersCache$.value;\n        this.usersCache$.next([...users, newUser]);\n        this.loggingService.log('User created', newUser.id);\n      }),\n      catchError(error => {\n        this.loggingService.error('Failed to create user', error);\n        return throwError(() => error);\n      })\n    );\n  }\n\n  updateUser(id: string, updates: Partial<User>): Observable<User> {\n    return this.http.put<User>(`${this.baseUrl}/${id}`, updates, {\n      headers: {\n        'Authorization': `Bearer ${this.authService.getToken()}`\n      }\n    }).pipe(\n      tap(updatedUser => {\n        const users = this.usersCache$.value;\n        const index = users.findIndex(u => u.id === id);\n        if (index !== -1) {\n          users[index] = updatedUser;\n          this.usersCache$.next([...users]);\n        }\n        this.loggingService.log('User updated', id);\n      })\n    );\n  }\n\n  deleteUser(id: string): Observable<void> {\n    return this.http.delete<void>(`${this.baseUrl}/${id}`, {\n      headers: {\n        'Authorization': `Bearer ${this.authService.getToken()}`\n      }\n    }).pipe(\n      tap(() => {\n        const users = this.usersCache$.value.filter(u => u.id !== id);\n        this.usersCache$.next(users);\n        this.loggingService.log('User deleted', id);\n      })\n    );\n  }\n\n  // Batch операции\n  batchUpdateUsers(updates: Array<{ id: string; data: Partial<User> }>): Observable<User[]> {\n    return forkJoin(\n      updates.map(({ id, data }) => this.updateUser(id, data))\n    );\n  }\n}\n```\n\n**Integration тесты для Service:**\n```typescript\ndescribe('UserService Integration', () => {\n  let service: UserService;\n  let httpMock: HttpTestingController;\n  let authService: jasmine.SpyObj<AuthService>;\n  let loggingService: jasmine.SpyObj<LoggingService>;\n\n  beforeEach(() => {\n    const authSpy = jasmine.createSpyObj('AuthService', ['getToken']);\n    const loggingSpy = jasmine.createSpyObj('LoggingService', ['log', 'error']);\n\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [\n        UserService,\n        { provide: AuthService, useValue: authSpy },\n        { provide: LoggingService, useValue: loggingSpy }\n      ]\n    });\n\n    service = TestBed.inject(UserService);\n    httpMock = TestBed.inject(HttpTestingController);\n    authService = TestBed.inject(AuthService) as jasmine.SpyObj<AuthService>;\n    loggingService = TestBed.inject(LoggingService) as jasmine.SpyObj<LoggingService>;\n\n    authService.getToken.and.returnValue('fake-token');\n  });\n\n  afterEach(() => {\n    httpMock.verify();\n  });\n\n  describe('Caching behavior', () => {\n    it('should cache users after first request', fakeAsync(() => {\n      const mockUsers: User[] = [\n        { id: '1', name: 'John', email: 'john@test.com', role: 'admin' }\n      ];\n\n      // Первый запрос\n      service.getUsers().subscribe(users => {\n        expect(users).toEqual(mockUsers);\n      });\n\n      const req1 = httpMock.expectOne('/api/users');\n      req1.flush(mockUsers);\n      tick();\n\n      // Второй запрос - должен вернуть из кэша без HTTP\n      service.getUsers().subscribe(users => {\n        expect(users).toEqual(mockUsers);\n      });\n\n      httpMock.expectNone('/api/users'); // Не должно быть HTTP запроса\n      tick();\n    }));\n\n    it('should refresh cache when refresh=true', fakeAsync(() => {\n      const initialUsers: User[] = [{ id: '1', name: 'John', email: 'john@test.com', role: 'admin' }];\n      const updatedUsers: User[] = [\n        { id: '1', name: 'John Updated', email: 'john@test.com', role: 'admin' },\n        { id: '2', name: 'Jane', email: 'jane@test.com', role: 'user' }\n      ];\n\n      // Первый запрос\n      service.getUsers().subscribe();\n      httpMock.expectOne('/api/users').flush(initialUsers);\n      tick();\n\n      // Запрос с refresh=true\n      service.getUsers(true).subscribe(users => {\n        expect(users).toEqual(updatedUsers);\n        expect(users.length).toBe(2);\n      });\n\n      const req = httpMock.expectOne('/api/users');\n      req.flush(updatedUsers);\n      tick();\n    }));\n\n    it('should return user from cache if available', fakeAsync(() => {\n      const mockUsers: User[] = [\n        { id: '1', name: 'John', email: 'john@test.com', role: 'admin' }\n      ];\n\n      // Загружаем пользователей в кэш\n      service.getUsers().subscribe();\n      httpMock.expectOne('/api/users').flush(mockUsers);\n      tick();\n\n      // Запрашиваем конкретного пользователя - должен вернуть из кэша\n      service.getUserById('1').subscribe(user => {\n        expect(user).toEqual(mockUsers[0]);\n      });\n\n      httpMock.expectNone('/api/users/1'); // Не должно быть HTTP запроса\n      tick();\n    }));\n  });\n\n  describe('CRUD operations with cache updates', () => {\n    it('should add new user to cache after creation', fakeAsync(() => {\n      const existingUsers: User[] = [\n        { id: '1', name: 'John', email: 'john@test.com', role: 'admin' }\n      ];\n      const newUserData = { name: 'Jane', email: 'jane@test.com', role: 'user' };\n      const createdUser: User = { id: '2', ...newUserData };\n\n      // Загружаем существующих пользователей\n      service.getUsers().subscribe();\n      httpMock.expectOne('/api/users').flush(existingUsers);\n      tick();\n\n      // Создаем нового пользователя\n      service.createUser(newUserData).subscribe(user => {\n        expect(user).toEqual(createdUser);\n      });\n\n      const createReq = httpMock.expectOne('/api/users');\n      expect(createReq.request.method).toBe('POST');\n      expect(createReq.request.headers.get('Authorization')).toBe('Bearer fake-token');\n      createReq.flush(createdUser);\n      tick();\n\n      // Проверяем что кэш обновился\n      service.getUsers().subscribe(users => {\n        expect(users.length).toBe(2);\n        expect(users).toContain(createdUser);\n      });\n\n      expect(loggingService.log).toHaveBeenCalledWith('User created', '2');\n      tick();\n    }));\n\n    it('should update user in cache after modification', fakeAsync(() => {\n      const users: User[] = [\n        { id: '1', name: 'John', email: 'john@test.com', role: 'admin' }\n      ];\n      const updates = { name: 'John Updated' };\n      const updatedUser = { ...users[0], ...updates };\n\n      service.getUsers().subscribe();\n      httpMock.expectOne('/api/users').flush(users);\n      tick();\n\n      service.updateUser('1', updates).subscribe(user => {\n        expect(user.name).toBe('John Updated');\n      });\n\n      const updateReq = httpMock.expectOne('/api/users/1');\n      expect(updateReq.request.method).toBe('PUT');\n      expect(updateReq.request.headers.get('Authorization')).toBe('Bearer fake-token');\n      updateReq.flush(updatedUser);\n      tick();\n\n      // Проверяем обновление в кэше\n      service.getUsers().subscribe(cachedUsers => {\n        expect(cachedUsers[0].name).toBe('John Updated');\n      });\n\n      tick();\n    }));\n\n    it('should remove user from cache after deletion', fakeAsync(() => {\n      const users: User[] = [\n        { id: '1', name: 'John', email: 'john@test.com', role: 'admin' },\n        { id: '2', name: 'Jane', email: 'jane@test.com', role: 'user' }\n      ];\n\n      service.getUsers().subscribe();\n      httpMock.expectOne('/api/users').flush(users);\n      tick();\n\n      service.deleteUser('1').subscribe();\n\n      const deleteReq = httpMock.expectOne('/api/users/1');\n      expect(deleteReq.request.method).toBe('DELETE');\n      deleteReq.flush({});\n      tick();\n\n      service.getUsers().subscribe(cachedUsers => {\n        expect(cachedUsers.length).toBe(1);\n        expect(cachedUsers.find(u => u.id === '1')).toBeUndefined();\n      });\n\n      tick();\n    }));\n  });\n\n  describe('Batch operations', () => {\n    it('should update multiple users and update cache', fakeAsync(() => {\n      const users: User[] = [\n        { id: '1', name: 'John', email: 'john@test.com', role: 'admin' },\n        { id: '2', name: 'Jane', email: 'jane@test.com', role: 'user' }\n      ];\n\n      service.getUsers().subscribe();\n      httpMock.expectOne('/api/users').flush(users);\n      tick();\n\n      const updates = [\n        { id: '1', data: { name: 'John Updated' } },\n        { id: '2', data: { name: 'Jane Updated' } }\n      ];\n\n      service.batchUpdateUsers(updates).subscribe(results => {\n        expect(results.length).toBe(2);\n        expect(results[0].name).toBe('John Updated');\n        expect(results[1].name).toBe('Jane Updated');\n      });\n\n      // Оба PUT запроса должны быть выполнены\n      const req1 = httpMock.expectOne('/api/users/1');\n      const req2 = httpMock.expectOne('/api/users/2');\n\n      req1.flush({ ...users[0], name: 'John Updated' });\n      req2.flush({ ...users[1], name: 'Jane Updated' });\n      tick();\n\n      // Проверяем обновление кэша\n      service.getUsers().subscribe(cachedUsers => {\n        expect(cachedUsers[0].name).toBe('John Updated');\n        expect(cachedUsers[1].name).toBe('Jane Updated');\n      });\n\n      tick();\n    }));\n  });\n\n  describe('Error handling', () => {\n    it('should log error and rethrow when getUsers fails', fakeAsync(() => {\n      service.getUsers().subscribe({\n        next: () => fail('should have failed'),\n        error: (error) => {\n          expect(error.message).toBe('Failed to load users');\n        }\n      });\n\n      const req = httpMock.expectOne('/api/users');\n      req.error(new ProgressEvent('Network error'), { status: 500 });\n      tick();\n\n      expect(loggingService.error).toHaveBeenCalledWith(\n        'Failed to load users',\n        jasmine.any(Object)\n      );\n    }));\n  });\n});\n```\n\n#### Тестирование Routing\n\n**Router integration тесты:**\n```typescript\ndescribe('App Routing Integration', () => {\n  let router: Router;\n  let location: Location;\n  let fixture: ComponentFixture<AppComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [\n        AppComponent,\n        HomeComponent,\n        UserListComponent,\n        UserDetailComponent,\n        NotFoundComponent\n      ],\n      imports: [\n        RouterTestingModule.withRoutes([\n          { path: '', component: HomeComponent },\n          { path: 'users', component: UserListComponent },\n          { path: 'users/:id', component: UserDetailComponent },\n          { path: '**', component: NotFoundComponent }\n        ]),\n        HttpClientTestingModule\n      ],\n      providers: [\n        UserService,\n        { provide: AuthGuard, useClass: MockAuthGuard }\n      ]\n    }).compileComponents();\n\n    router = TestBed.inject(Router);\n    location = TestBed.inject(Location);\n    fixture = TestBed.createComponent(AppComponent);\n    router.initialNavigation();\n  });\n\n  it('should navigate to users list', fakeAsync(() => {\n    router.navigate(['/users']);\n    tick();\n\n    expect(location.path()).toBe('/users');\n\n    const compiled = fixture.nativeElement;\n    expect(compiled.querySelector('app-user-list')).toBeTruthy();\n  }));\n\n  it('should navigate to user detail with id parameter', fakeAsync(() => {\n    router.navigate(['/users', '123']);\n    tick();\n\n    expect(location.path()).toBe('/users/123');\n\n    const userDetailComponent = fixture.debugElement.query(\n      By.directive(UserDetailComponent)\n    ).componentInstance;\n\n    expect(userDetailComponent).toBeTruthy();\n  }));\n\n  it('should show 404 for unknown routes', fakeAsync(() => {\n    router.navigate(['/unknown-path']);\n    tick();\n\n    expect(location.path()).toBe('/unknown-path');\n    expect(fixture.nativeElement.querySelector('app-not-found')).toBeTruthy();\n  }));\n});\n```\n\n#### Best Practices\n\n1. **Изолируйте внешние зависимости:**\n   - Мокируйте HTTP с `HttpClientTestingModule`\n   - Используйте spies для services\n   - Мокируйте Router, ActivatedRoute\n\n2. **Тестируйте реальное взаимодействие:**\n   - Не мокируйте child components в integration тестах\n   - Тестируйте полный flow данных\n   - Проверяйте side effects\n\n3. **Используйте fakeAsync и tick:**\n   - Контролируйте асинхронные операции\n   - Избегайте реальных timeouts\n   - Упрощайте debugging\n\n4. **Проверяйте DOM изменения:**\n   - Вызывайте `fixture.detectChanges()`\n   - Используйте `By.directive()` для поиска child components\n   - Проверяйте rendered output\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 66,
          "question_number_in_chapter": 4,
          "question_chapter": 8,
          "question_title": "Visual Regression Testing - Percy, Chromatic, BackstopJS. Screenshot Comparison, CI Automation",
          "answer_markdown": "**Ответ:**\n\nVisual Regression Testing критически важен для обнаружения непредвиденных UI изменений в Angular приложениях. Senior-level подход включает автоматизацию, интеграцию в CI/CD, и правильный выбор инструмента.\n\n#### Сравнение инструментов Visual Testing\n\n**Percy (от BrowserStack):**\n- **Преимущества:**\n  - SaaS решение, минимум настройки\n  - Интеллектуальные алгоритмы сравнения (anti-aliasing, dynamic content)\n  - Интеграция с большинством CI/CD\n  - Поддержка responsive testing\n  - Review процесс с командой\n\n- **Недостатки:**\n  - Платный (после free tier)\n  - Зависимость от внешнего сервиса\n  - Ограничения на количество screenshots\n\n**Chromatic (от Storybook):**\n- **Преимущества:**\n  - Глубокая интеграция со Storybook\n  - UI Review & Collaboration tools\n  - TurboSnap - snapshot только измененных компонентов\n  - Автоматическое определение baseline\n  - Design system focused\n\n- **Недостатки:**\n  - Требует Storybook\n  - Платный\n  - Менее гибкий для non-Storybook use cases\n\n**BackstopJS:**\n- **Преимущества:**\n  - Open Source, бесплатный\n  - Полный контроль, self-hosted\n  - Гибкие сценарии тестирования\n  - Puppeteer/Playwright under the hood\n  - Работает без внешних зависимостей\n\n- **Недостатки:**\n  - Требует больше настройки\n  - Нет облачного хранилища\n  - Базовые инструменты сравнения\n  - Требует storage для screenshots\n\n#### Настройка Percy для Angular\n\n**Установка:**\n```bash\nnpm install --save-dev @percy/cli @percy/cypress\n# или\nnpm install --save-dev @percy/playwright\n```\n\n**Percy + Cypress:**\n```typescript\n// cypress/support/e2e.ts\nimport '@percy/cypress';\n\n// cypress/e2e/visual.cy.ts\ndescribe('Visual Regression Tests', () => {\n  beforeEach(() => {\n    cy.visit('/');\n  });\n\n  it('should match homepage snapshot', () => {\n    cy.percySnapshot('Homepage');\n  });\n\n  it('should match dashboard in different states', () => {\n    cy.login('user@test.com', 'password');\n    cy.visit('/dashboard');\n\n    // Базовое состояние\n    cy.percySnapshot('Dashboard - Default');\n\n    // С открытой sidebar\n    cy.get('[data-test=\"sidebar-toggle\"]').click();\n    cy.percySnapshot('Dashboard - Sidebar Open');\n\n    // С модалкой\n    cy.get('[data-test=\"add-user\"]').click();\n    cy.percySnapshot('Dashboard - Add User Modal');\n  });\n\n  it('should test responsive layouts', () => {\n    cy.visit('/products');\n\n    // Desktop\n    cy.viewport(1920, 1080);\n    cy.percySnapshot('Products - Desktop', {\n      widths: [1920]\n    });\n\n    // Tablet\n    cy.viewport(768, 1024);\n    cy.percySnapshot('Products - Tablet', {\n      widths: [768]\n    });\n\n    // Mobile\n    cy.viewport(375, 667);\n    cy.percySnapshot('Products - Mobile', {\n      widths: [375]\n    });\n  });\n\n  it('should test theme variations', () => {\n    cy.visit('/settings');\n\n    // Light theme\n    cy.percySnapshot('Settings - Light Theme');\n\n    // Dark theme\n    cy.get('[data-test=\"theme-toggle\"]').click();\n    cy.wait(500); // Ждем окончания transition\n    cy.percySnapshot('Settings - Dark Theme');\n  });\n\n  it('should handle dynamic content', () => {\n    cy.visit('/users');\n\n    // Мокируем API для стабильных данных\n    cy.intercept('GET', '/api/users', {\n      fixture: 'users-visual-test.json'\n    }).as('getUsers');\n\n    cy.wait('@getUsers');\n    cy.percySnapshot('Users List', {\n      // Игнорируем элементы с динамическим контентом\n      percyCSS: `\n        .timestamp { display: none !important; }\n        .avatar { opacity: 0 !important; }\n      `\n    });\n  });\n});\n```\n\n**Percy конфигурация (.percy.yml):**\n```yaml\nversion: 2\n\nstatic:\n  # Базовые настройки\n  widths:\n    - 375   # Mobile\n    - 768   # Tablet\n    - 1280  # Desktop\n\n  min-height: 1024\n\n# Глобальные настройки snapshot\nsnapshot:\n  widths:\n    - 375\n    - 768\n    - 1280\n    - 1920\n\n  min-height: 1024\n\n  # Автоматический скролл для полных page screenshots\n  enable-javascript: true\n\n  # Ожидание загрузки ресурсов\n  percy-css: |\n    /* Скрываем динамические элементы */\n    .loading-spinner,\n    .timestamp,\n    .real-time-indicator {\n      display: none !important;\n    }\n\n    /* Фиксируем размеры для стабильности */\n    img {\n      max-width: 100%;\n      height: auto;\n    }\n\n# Discovery настройки\ndiscovery:\n  # Игнорируемые запросы для ускорения\n  network-idle-timeout: 125\n\n  allowed-hostnames:\n    - localhost\n    - '*.yourcdn.com'\n\n# Shard конфигурация для параллелизации\nshard:\n  total-shards: 4\n```\n\n**package.json scripts:**\n```json\n{\n  \"scripts\": {\n    \"percy:exec\": \"percy exec -- cypress run\",\n    \"percy:snapshot\": \"percy snapshot ./dist/your-app\",\n    \"percy:upload\": \"percy upload ./screenshots\"\n  }\n}\n```\n\n#### Настройка Chromatic для Angular + Storybook\n\n**Установка:**\n```bash\nnpx storybook@latest init\nnpm install --save-dev chromatic\n```\n\n**Storybook stories для Visual Testing:**\n```typescript\n// src/app/components/button/button.stories.ts\nimport { Meta, StoryObj } from '@storybook/angular';\nimport { ButtonComponent } from './button.component';\n\nconst meta: Meta<ButtonComponent> = {\n  title: 'Components/Button',\n  component: ButtonComponent,\n  tags: ['autodocs'],\n  parameters: {\n    // Chromatic параметры\n    chromatic: {\n      // Делаем больше задержки для анимаций\n      delay: 300,\n      // Отключаем автоматические snapshots для специфичных stories\n      disableSnapshot: false,\n      // Viewport конфигурация\n      viewports: [320, 768, 1200]\n    }\n  },\n  argTypes: {\n    variant: {\n      control: { type: 'select' },\n      options: ['primary', 'secondary', 'danger']\n    },\n    size: {\n      control: { type: 'select' },\n      options: ['small', 'medium', 'large']\n    },\n    disabled: {\n      control: 'boolean'\n    }\n  }\n};\n\nexport default meta;\ntype Story = StoryObj<ButtonComponent>;\n\n// Базовые варианты\nexport const Primary: Story = {\n  args: {\n    label: 'Primary Button',\n    variant: 'primary',\n    size: 'medium'\n  }\n};\n\nexport const Secondary: Story = {\n  args: {\n    label: 'Secondary Button',\n    variant: 'secondary',\n    size: 'medium'\n  }\n};\n\nexport const Danger: Story = {\n  args: {\n    label: 'Delete',\n    variant: 'danger',\n    size: 'medium'\n  }\n};\n\n// Размеры\nexport const Small: Story = {\n  args: {\n    label: 'Small Button',\n    variant: 'primary',\n    size: 'small'\n  }\n};\n\nexport const Large: Story = {\n  args: {\n    label: 'Large Button',\n    variant: 'primary',\n    size: 'large'\n  }\n};\n\n// Состояния\nexport const Disabled: Story = {\n  args: {\n    label: 'Disabled Button',\n    variant: 'primary',\n    disabled: true\n  }\n};\n\nexport const Loading: Story = {\n  args: {\n    label: 'Loading...',\n    variant: 'primary',\n    loading: true\n  }\n};\n\n// Interaction тесты для Chromatic\nexport const Hover: Story = {\n  args: Primary.args,\n  parameters: {\n    pseudo: { hover: true }\n  }\n};\n\nexport const Focus: Story = {\n  args: Primary.args,\n  parameters: {\n    pseudo: { focus: true }\n  }\n};\n\nexport const Active: Story = {\n  args: Primary.args,\n  parameters: {\n    pseudo: { active: true }\n  }\n};\n\n// Dark theme\nexport const DarkTheme: Story = {\n  args: Primary.args,\n  parameters: {\n    backgrounds: { default: 'dark' },\n    chromatic: {\n      modes: {\n        dark: {\n          theme: 'dark'\n        }\n      }\n    }\n  }\n};\n```\n\n**chromatic.config.json:**\n```json\n{\n  \"projectId\": \"your-project-id\",\n  \"buildScriptName\": \"build-storybook\",\n  \"onlyChanged\": true,\n  \"externals\": [\n    \"public/**\"\n  ],\n  \"untraced\": [\n    \"node_modules/**\",\n    \"dist/**\"\n  ],\n  \"skip\": \"dependabot/**\",\n  \"autoAcceptChanges\": \"main\",\n  \"exitZeroOnChanges\": true,\n  \"exitOnceUploaded\": true\n}\n```\n\n**package.json:**\n```json\n{\n  \"scripts\": {\n    \"chromatic\": \"chromatic --exit-zero-on-changes\",\n    \"chromatic:ci\": \"chromatic --exit-zero-on-changes --ci\"\n  }\n}\n```\n\n#### Настройка BackstopJS\n\n**Установка:**\n```bash\nnpm install --save-dev backstopjs\n```\n\n**backstop.json:**\n```json\n{\n  \"id\": \"angular_visual_regression\",\n  \"viewports\": [\n    {\n      \"label\": \"phone\",\n      \"width\": 375,\n      \"height\": 667\n    },\n    {\n      \"label\": \"tablet\",\n      \"width\": 768,\n      \"height\": 1024\n    },\n    {\n      \"label\": \"desktop\",\n      \"width\": 1280,\n      \"height\": 1024\n    }\n  ],\n  \"onBeforeScript\": \"puppet/onBefore.js\",\n  \"onReadyScript\": \"puppet/onReady.js\",\n  \"scenarios\": [\n    {\n      \"label\": \"Homepage\",\n      \"url\": \"http://localhost:4200/\",\n      \"referenceUrl\": \"\",\n      \"readyEvent\": \"\",\n      \"readySelector\": \"\",\n      \"delay\": 500,\n      \"hideSelectors\": [\n        \".loading-spinner\",\n        \".timestamp\"\n      ],\n      \"removeSelectors\": [\n        \".ad-banner\"\n      ],\n      \"hoverSelector\": \"\",\n      \"clickSelector\": \"\",\n      \"postInteractionWait\": 0,\n      \"selectors\": [\"document\"],\n      \"selectorExpansion\": true,\n      \"expect\": 0,\n      \"misMatchThreshold\": 0.1,\n      \"requireSameDimensions\": true\n    },\n    {\n      \"label\": \"Dashboard - Logged In\",\n      \"url\": \"http://localhost:4200/dashboard\",\n      \"onBeforeScript\": \"puppet/loginUser.js\",\n      \"delay\": 1000,\n      \"selectors\": [\".dashboard-container\"],\n      \"misMatchThreshold\": 0.2\n    },\n    {\n      \"label\": \"User List - All States\",\n      \"url\": \"http://localhost:4200/users\",\n      \"scenarios\": [\n        {\n          \"label\": \"Default View\",\n          \"selectors\": [\".user-list\"]\n        },\n        {\n          \"label\": \"With Sidebar Open\",\n          \"clickSelector\": \".sidebar-toggle\",\n          \"postInteractionWait\": 300,\n          \"selectors\": [\".user-list\", \".sidebar\"]\n        },\n        {\n          \"label\": \"With Filter Applied\",\n          \"onReadyScript\": \"puppet/applyFilters.js\",\n          \"selectors\": [\".user-list\", \".filters\"]\n        }\n      ]\n    },\n    {\n      \"label\": \"Button Component - Hover State\",\n      \"url\": \"http://localhost:4200/styleguide/buttons\",\n      \"hoverSelector\": \".btn-primary\",\n      \"postInteractionWait\": 200,\n      \"selectors\": [\".btn-primary\"]\n    },\n    {\n      \"label\": \"Form Validation\",\n      \"url\": \"http://localhost:4200/register\",\n      \"clickSelectors\": [\n        \".email-input\",\n        \".password-input\",\n        \".submit-button\"\n      ],\n      \"postInteractionWait\": 500,\n      \"selectors\": [\".registration-form\"],\n      \"misMatchThreshold\": 0.5\n    },\n    {\n      \"label\": \"Dark Theme\",\n      \"url\": \"http://localhost:4200/\",\n      \"onBeforeScript\": \"puppet/enableDarkTheme.js\",\n      \"delay\": 1000,\n      \"selectors\": [\"document\"]\n    }\n  ],\n  \"paths\": {\n    \"bitmaps_reference\": \"backstop_data/bitmaps_reference\",\n    \"bitmaps_test\": \"backstop_data/bitmaps_test\",\n    \"engine_scripts\": \"backstop_data/engine_scripts\",\n    \"html_report\": \"backstop_data/html_report\",\n    \"ci_report\": \"backstop_data/ci_report\"\n  },\n  \"report\": [\"browser\", \"CI\"],\n  \"engine\": \"puppeteer\",\n  \"engineOptions\": {\n    \"args\": [\"--no-sandbox\"]\n  },\n  \"asyncCaptureLimit\": 5,\n  \"asyncCompareLimit\": 50,\n  \"debug\": false,\n  \"debugWindow\": false\n}\n```\n\n**Custom scripts для BackstopJS:**\n\n```javascript\n// backstop_data/engine_scripts/puppet/loginUser.js\nmodule.exports = async (page, scenario, vp) => {\n  console.log('SCENARIO > ' + scenario.label);\n\n  // Переходим на страницу логина\n  await page.goto('http://localhost:4200/login');\n\n  // Заполняем форму\n  await page.type('[data-test=\"email-input\"]', 'test@example.com');\n  await page.type('[data-test=\"password-input\"]', 'password123');\n  await page.click('[data-test=\"login-button\"]');\n\n  // Ждем редиректа\n  await page.waitForNavigation({ waitUntil: 'networkidle0' });\n\n  console.log('User logged in successfully');\n};\n\n// backstop_data/engine_scripts/puppet/enableDarkTheme.js\nmodule.exports = async (page, scenario, vp) => {\n  await page.evaluate(() => {\n    localStorage.setItem('theme', 'dark');\n    document.body.classList.add('dark-theme');\n  });\n\n  await page.reload({ waitUntil: 'networkidle0' });\n};\n\n// backstop_data/engine_scripts/puppet/onReady.js\nmodule.exports = async (page, scenario, vp) => {\n  console.log('SCENARIO > ' + scenario.label);\n\n  // Ждем пока все изображения загрузятся\n  await page.evaluate(async () => {\n    const selectors = Array.from(document.querySelectorAll(\"img\"));\n    await Promise.all(\n      selectors.map(img => {\n        if (img.complete) return;\n        return new Promise((resolve, reject) => {\n          img.addEventListener('load', resolve);\n          img.addEventListener('error', reject);\n        });\n      })\n    );\n  });\n\n  // Останавливаем все анимации для стабильности\n  await page.evaluate(() => {\n    const style = document.createElement('style');\n    style.innerHTML = `\n      *, *::before, *::after {\n        animation-duration: 0s !important;\n        animation-delay: 0s !important;\n        transition-duration: 0s !important;\n        transition-delay: 0s !important;\n      }\n    `;\n    document.head.appendChild(style);\n  });\n};\n```\n\n**package.json scripts:**\n```json\n{\n  \"scripts\": {\n    \"backstop:reference\": \"backstop reference --config=backstop.json\",\n    \"backstop:test\": \"backstop test --config=backstop.json\",\n    \"backstop:approve\": \"backstop approve\",\n    \"backstop:report\": \"backstop openReport\",\n    \"visual:test\": \"npm-run-all build:prod start:ci --parallel backstop:test\"\n  }\n}\n```\n\n#### CI/CD Integration\n\n**GitHub Actions для Percy:**\n```yaml\nname: Visual Regression Testing\n\non:\n  pull_request:\n    branches: [main, develop]\n\njobs:\n  percy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Build app\n        run: npm run build:prod\n\n      - name: Percy Test\n        run: npm run percy:exec\n        env:\n          PERCY_TOKEN: ${{ secrets.PERCY_TOKEN }}\n```\n\n**GitHub Actions для Chromatic:**\n```yaml\nname: Chromatic Visual Tests\n\non:\n  push:\n    branches:\n      - main\n      - develop\n  pull_request:\n\njobs:\n  chromatic:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0  # Нужно для TurboSnap\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Publish to Chromatic\n        uses: chromaui/action@v1\n        with:\n          projectToken: ${{ secrets.CHROMATIC_PROJECT_TOKEN }}\n          buildScriptName: build-storybook\n          exitZeroOnChanges: true\n          autoAcceptChanges: main\n          onlyChanged: true  # TurboSnap\n```\n\n**GitLab CI для BackstopJS:**\n```yaml\nstages:\n  - build\n  - test\n  - report\n\nbackstop-test:\n  stage: test\n  image: backstopjs/backstopjs:latest\n\n  before_script:\n    - npm ci\n    - npm run build:prod\n    - npm run start:ci &\n    - npx wait-on http://localhost:4200\n\n  script:\n    - backstop test --config=backstop.json\n\n  after_script:\n    - backstop openReport\n\n  artifacts:\n    when: always\n    paths:\n      - backstop_data/html_report/\n      - backstop_data/bitmaps_test/\n    expire_in: 30 days\n\n  allow_failure: true\n```\n\n#### Best Practices\n\n1. **Стабилизация screenshots:**\n   - Отключайте анимации (`prefers-reduced-motion`)\n   - Скрывайте timestamp и динамический контент\n   - Мокируйте API для предсказуемых данных\n   - Используйте фиксированные шрифты и viewport\n\n2. **Оптимизация производительности:**\n   - Chromatic TurboSnap - snapshot только измененного\n   - Percy Smart Diffing - интеллектуальное сравнение\n   - Параллелизация тестов\n   - Кэширование baseline screenshots\n\n3. **Review процесс:**\n   - Настройте автоматический approve для main ветки\n   - Требуйте review для visual changes\n   - Интегрируйте с Pull Request checks\n   - Документируйте expected changes\n\n4. **Threshold настройка:**\n   - `misMatchThreshold` для BackstopJS\n   - Учитывайте anti-aliasing различия\n   - Разные thresholds для разных типов контента\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 67,
          "question_number_in_chapter": 5,
          "question_chapter": 8,
          "question_title": "Test Coverage & Quality - Istanbul, Coverage Reports, Mutation Testing (Stryker), Code Quality Gates в CI",
          "answer_markdown": "**Ответ:**\n\nCode coverage и quality metrics - ключевые индикаторы здоровья тестовой базы для Senior-level разработки.\n\n#### Istanbul Code Coverage\n\n**Настройка в Angular:**\n\n**karma.conf.js:**\n```javascript\nmodule.exports = function(config) {\n  config.set({\n    basePath: '',\n    frameworks: ['jasmine', '@angular-devkit/build-angular'],\n    plugins: [\n      require('karma-jasmine'),\n      require('karma-chrome-launcher'),\n      require('karma-jasmine-html-reporter'),\n      require('karma-coverage'),\n      require('@angular-devkit/build-angular/plugins/karma')\n    ],\n    client: {\n      jasmine: {\n        random: false,\n        seed: 42\n      },\n      clearContext: false\n    },\n    jasmineHtmlReporter: {\n      suppressAll: true\n    },\n    coverageReporter: {\n      dir: require('path').join(__dirname, './coverage'),\n      subdir: '.',\n      reporters: [\n        { type: 'html' },\n        { type: 'text-summary' },\n        { type: 'lcovonly' },\n        { type: 'json' },\n        { type: 'cobertura' }\n      ],\n      check: {\n        global: {\n          statements: 80,\n          branches: 75,\n          functions: 80,\n          lines: 80\n        },\n        each: {\n          statements: 70,\n          branches: 65,\n          functions: 70,\n          lines: 70\n        }\n      },\n      watermarks: {\n        statements: [75, 90],\n        functions: [75, 90],\n        branches: [70, 85],\n        lines: [75, 90]\n      }\n    },\n    reporters: ['progress', 'kjhtml', 'coverage'],\n    port: 9876,\n    colors: true,\n    logLevel: config.LOG_INFO,\n    autoWatch: true,\n    browsers: ['ChromeHeadless'],\n    singleRun: false,\n    restartOnFileChange: true,\n    browserNoActivityTimeout: 30000\n  });\n};\n```\n\n**angular.json:**\n```json\n{\n  \"projects\": {\n    \"your-app\": {\n      \"architect\": {\n        \"test\": {\n          \"options\": {\n            \"codeCoverage\": true,\n            \"codeCoverageExclude\": [\n              \"src/**/*.spec.ts\",\n              \"src/**/*.stories.ts\",\n              \"src/**/test-utils/**\",\n              \"src/environments/**\"\n            ]\n          },\n          \"configurations\": {\n            \"ci\": {\n              \"watch\": false,\n              \"progress\": false,\n              \"browsers\": \"ChromeHeadlessCI\",\n              \"codeCoverage\": true\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n**package.json scripts:**\n```json\n{\n  \"scripts\": {\n    \"test\": \"ng test\",\n    \"test:ci\": \"ng test --configuration=ci\",\n    \"test:coverage\": \"ng test --code-coverage --watch=false\",\n    \"test:coverage:open\": \"npm run test:coverage && open coverage/index.html\",\n    \"coverage:check\": \"node scripts/check-coverage.js\"\n  }\n}\n```\n\n**scripts/check-coverage.js:**\n```javascript\nconst fs = require('fs');\nconst path = require('path');\n\nconst coverageSummaryPath = path.join(__dirname, '../coverage/coverage-summary.json');\n\nif (!fs.existsSync(coverageSummaryPath)) {\n  console.error('Coverage summary not found. Run tests with --code-coverage first.');\n  process.exit(1);\n}\n\nconst coverage = JSON.parse(fs.readFileSync(coverageSummaryPath, 'utf8'));\nconst { total } = coverage;\n\nconst thresholds = {\n  statements: 80,\n  branches: 75,\n  functions: 80,\n  lines: 80\n};\n\nconsole.log('\\n📊 Coverage Report:\\n');\nconsole.log(`Statements: ${total.statements.pct}% (threshold: ${thresholds.statements}%)`);\nconsole.log(`Branches:   ${total.branches.pct}% (threshold: ${thresholds.branches}%)`);\nconsole.log(`Functions:  ${total.functions.pct}% (threshold: ${thresholds.functions}%)`);\nconsole.log(`Lines:      ${total.lines.pct}% (threshold: ${thresholds.lines}%)\\n`);\n\nlet failed = false;\n\nObject.keys(thresholds).forEach(key => {\n  if (total[key].pct < thresholds[key]) {\n    console.error(`❌ ${key} coverage (${total[key].pct}%) below threshold (${thresholds[key]}%)`);\n    failed = true;\n  }\n});\n\nif (failed) {\n  console.error('\\n❌ Coverage check failed!\\n');\n  process.exit(1);\n}\n\nconsole.log('✅ Coverage check passed!\\n');\nprocess.exit(0);\n```\n\n#### Детальный Coverage Analysis\n\n**Генерация подробных отчетов:**\n```bash\n# HTML отчет с drill-down по файлам\nng test --code-coverage --watch=false\n\n# LCOV для интеграции с внешними инструментами\nng test --code-coverage --watch=false --reporters=lcov\n\n# JSON для кастомного анализа\nng test --code-coverage --watch=false --reporters=json\n```\n\n**Анализ непокрытого кода:**\n```javascript\n// scripts/analyze-uncovered.js\nconst fs = require('fs');\nconst path = require('path');\n\nconst coverageDir = path.join(__dirname, '../coverage');\nconst coverageFiles = fs.readdirSync(coverageDir)\n  .filter(file => file.endsWith('.json'))\n  .map(file => path.join(coverageDir, file));\n\nconst uncoveredFiles = [];\n\ncoverageFiles.forEach(file => {\n  const coverage = JSON.parse(fs.readFileSync(file, 'utf8'));\n\n  Object.entries(coverage).forEach(([filePath, data]) => {\n    if (data.lines.pct < 70) {\n      uncoveredFiles.push({\n        file: filePath,\n        coverage: data.lines.pct,\n        uncoveredLines: Object.entries(data.statementMap)\n          .filter(([, loc]) => !data.s[loc.start.line])\n          .map(([, loc]) => loc.start.line)\n      });\n    }\n  });\n});\n\n// Сортируем по проценту покрытия\nuncoveredFiles.sort((a, b) => a.coverage - b.coverage);\n\nconsole.log('\\n🔍 Files with low coverage:\\n');\nuncoveredFiles.forEach(({ file, coverage, uncoveredLines }) => {\n  console.log(`${file}: ${coverage}%`);\n  console.log(`  Uncovered lines: ${uncoveredLines.join(', ')}\\n`);\n});\n```\n\n#### Mutation Testing с Stryker\n\n**Установка:**\n```bash\nnpm install --save-dev @stryker-mutator/core @stryker-mutator/karma-runner @stryker-mutator/typescript-checker @stryker-mutator/jasmine-framework\n```\n\n**stryker.conf.json:**\n```json\n{\n  \"$schema\": \"./node_modules/@stryker-mutator/core/schema/stryker-schema.json\",\n  \"packageManager\": \"npm\",\n  \"reporters\": [\n    \"html\",\n    \"clear-text\",\n    \"progress\",\n    \"dashboard\"\n  ],\n  \"testRunner\": \"karma\",\n  \"karma\": {\n    \"configFile\": \"karma.conf.js\",\n    \"projectType\": \"angular-cli\",\n    \"config\": {\n      \"browsers\": [\"ChromeHeadless\"]\n    }\n  },\n  \"coverageAnalysis\": \"perTest\",\n  \"mutate\": [\n    \"src/**/*.ts\",\n    \"!src/**/*.spec.ts\",\n    \"!src/**/*.stories.ts\",\n    \"!src/test/**\",\n    \"!src/environments/**\"\n  ],\n  \"checkers\": [\"typescript\"],\n  \"tsconfigFile\": \"tsconfig.json\",\n  \"thresholds\": {\n    \"high\": 80,\n    \"low\": 60,\n    \"break\": 70\n  },\n  \"mutator\": {\n    \"plugins\": [\n      \"@stryker-mutator/typescript-checker\"\n    ],\n    \"excludedMutations\": [\n      \"StringLiteral\",\n      \"BlockStatement\"\n    ]\n  },\n  \"timeoutMS\": 60000,\n  \"timeoutFactor\": 1.5,\n  \"maxConcurrentTestRunners\": 2,\n  \"ignorePatterns\": [\n    \"dist\",\n    \"coverage\",\n    \"node_modules\"\n  ],\n  \"dashboard\": {\n    \"project\": \"github.com/your-org/your-project\",\n    \"version\": \"main\",\n    \"module\": \"angular-app\",\n    \"baseUrl\": \"https://dashboard.stryker-mutator.io/api/reports\"\n  }\n}\n```\n\n**package.json scripts:**\n```json\n{\n  \"scripts\": {\n    \"stryker\": \"stryker run\",\n    \"stryker:incremental\": \"stryker run --incremental\",\n    \"stryker:open\": \"npm run stryker && open reports/mutation/html/index.html\"\n  }\n}\n```\n\n**Пример mutation testing результата:**\n```\nMutant killed  (✓): 342\nMutant survived (✗): 23\nMutant timeout  (⏱): 2\nMutant no coverage (⚠): 8\n\nMutation score based on covered code: 93.25%\nMutation score based on all code: 87.89%\n\nTop 5 mutants that survived:\n1. src/app/services/user.service.ts:42:12\n   - Mutator: ConditionalExpression\n   - Original: if (user.role === 'admin')\n   - Mutated:  if (false)\n\n2. src/app/components/form/form.component.ts:78:8\n   - Mutator: ArithmeticOperator\n   - Original: total += item.price\n   - Mutated:  total -= item.price\n```\n\n#### CI/CD Quality Gates\n\n**GitHub Actions - Complete Quality Pipeline:**\n```yaml\nname: Code Quality & Coverage\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main, develop]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Lint\n        run: npm run lint\n\n      - name: Check formatting\n        run: npm run prettier:check\n\n  test-coverage:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run tests with coverage\n        run: npm run test:coverage\n\n      - name: Check coverage thresholds\n        run: npm run coverage:check\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage/lcov.info\n          flags: unittests\n          name: codecov-umbrella\n          fail_ci_if_error: true\n\n      - name: SonarCloud Scan\n        uses: SonarSource/sonarcloud-github-action@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}\n        with:\n          args: >\n            -Dsonar.projectKey=your-project\n            -Dsonar.organization=your-org\n            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info\n            -Dsonar.coverage.exclusions=**/*.spec.ts,**/*.stories.ts\n\n      - name: Upload coverage artifacts\n        uses: actions/upload-artifact@v3\n        if: always()\n        with:\n          name: coverage-report\n          path: coverage/\n\n  mutation-testing:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run Stryker\n        run: npm run stryker\n        env:\n          STRYKER_DASHBOARD_API_KEY: ${{ secrets.STRYKER_DASHBOARD_API_KEY }}\n\n      - name: Upload mutation report\n        uses: actions/upload-artifact@v3\n        if: always()\n        with:\n          name: mutation-report\n          path: reports/mutation/\n\n  quality-gate:\n    runs-on: ubuntu-latest\n    needs: [lint, test-coverage]\n    steps:\n      - name: Quality Gate Status\n        run: echo \"All quality checks passed!\"\n```\n\n**sonar-project.properties:**\n```properties\nsonar.projectKey=your-project\nsonar.organization=your-org\nsonar.sources=src\nsonar.tests=src\nsonar.test.inclusions=**/*.spec.ts\nsonar.exclusions=**/node_modules/**,**/*.spec.ts,**/*.stories.ts,**/dist/**\nsonar.typescript.lcov.reportPaths=coverage/lcov.info\nsonar.testExecutionReportPaths=test-results/sonar-report.xml\n\n# Quality Gates\nsonar.qualitygate.wait=true\nsonar.qualitygate.timeout=300\n\n# Coverage\nsonar.coverage.exclusions=**/*.spec.ts,**/*.stories.ts,**/test-utils/**\n\n# Duplication\nsonar.cpd.exclusions=**/*.spec.ts\n\n# Code Smells\nsonar.issue.ignore.multicriteria=e1,e2\n\nsonar.issue.ignore.multicriteria.e1.ruleKey=typescript:S1128\nsonar.issue.ignore.multicriteria.e1.resourceKey=**/*.spec.ts\n\nsonar.issue.ignore.multicriteria.e2.ruleKey=typescript:S3776\nsonar.issue.ignore.multicriteria.e2.resourceKey=**/*.component.ts\n```\n\n**GitLab CI with Quality Gates:**\n```yaml\nstages:\n  - lint\n  - test\n  - quality\n  - report\n\nvariables:\n  npm_config_cache: \"$CI_PROJECT_DIR/.npm\"\n  SONAR_USER_HOME: \"${CI_PROJECT_DIR}/.sonar\"\n  GIT_DEPTH: \"0\"\n\ncache:\n  paths:\n    - .npm\n    - .sonar/cache\n    - node_modules\n\nlint:\n  stage: lint\n  image: node:18\n  script:\n    - npm ci\n    - npm run lint\n    - npm run prettier:check\n  artifacts:\n    reports:\n      codequality: gl-code-quality-report.json\n\ntest:coverage:\n  stage: test\n  image: node:18\n  script:\n    - npm ci\n    - npm run test:coverage\n  coverage: '/Lines\\s*:\\s*(\\d+\\.\\d+)%/'\n  artifacts:\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage/cobertura-coverage.xml\n      junit: test-results/junit.xml\n    paths:\n      - coverage/\n\nsonarcloud:\n  stage: quality\n  image: sonarsource/sonar-scanner-cli:latest\n  variables:\n    SONAR_TOKEN: \"${SONAR_TOKEN}\"\n  script:\n    - sonar-scanner\n  only:\n    - merge_requests\n    - main\n    - develop\n\nquality:gate:\n  stage: quality\n  image: node:18\n  dependencies:\n    - test:coverage\n  script:\n    - npm run coverage:check\n    - node scripts/quality-gate.js\n  allow_failure: false\n\npages:\n  stage: report\n  dependencies:\n    - test:coverage\n  script:\n    - mkdir -p public/coverage\n    - cp -r coverage/* public/coverage/\n  artifacts:\n    paths:\n      - public\n  only:\n    - main\n```\n\n**Quality Gate Script (scripts/quality-gate.js):**\n```javascript\nconst fs = require('fs');\nconst path = require('path');\n\nconst coveragePath = path.join(__dirname, '../coverage/coverage-summary.json');\nconst coverage = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));\n\nconst rules = {\n  coverage: {\n    statements: { min: 80, weight: 1 },\n    branches: { min: 75, weight: 1 },\n    functions: { min: 80, weight: 1 },\n    lines: { min: 80, weight: 1 }\n  },\n  complexity: {\n    maxComplexity: 10\n  },\n  duplication: {\n    maxPercentage: 3\n  }\n};\n\nlet score = 0;\nlet maxScore = 0;\nconst violations = [];\n\n// Check coverage\nObject.entries(rules.coverage).forEach(([metric, { min, weight }]) => {\n  maxScore += weight;\n  const actual = coverage.total[metric].pct;\n\n  if (actual >= min) {\n    score += weight;\n  } else {\n    violations.push({\n      type: 'coverage',\n      metric,\n      expected: min,\n      actual,\n      severity: 'error'\n    });\n  }\n});\n\n// Final score\nconst finalScore = (score / maxScore) * 100;\n\nconsole.log('\\n🎯 Quality Gate Report\\n');\nconsole.log(`Overall Score: ${finalScore.toFixed(2)}%`);\nconsole.log(`Passed: ${score}/${maxScore} checks\\n`);\n\nif (violations.length > 0) {\n  console.log('❌ Violations:\\n');\n  violations.forEach(v => {\n    console.log(`  ${v.metric}: ${v.actual}% (expected: ${v.expected}%)`);\n  });\n  console.log('\\n');\n}\n\nif (finalScore < 80) {\n  console.error('❌ Quality gate failed! Score below 80%\\n');\n  process.exit(1);\n}\n\nconsole.log('✅ Quality gate passed!\\n');\nprocess.exit(0);\n```\n\n#### Best Practices\n\n1. **Coverage targets:**\n   - Unit tests: 80%+ line coverage\n   - Integration tests: 70%+ branch coverage\n   - E2E: Critical user paths 100%\n\n2. **Mutation testing:**\n   - Run на main branch или периодически\n   - Фокус на критичных модулях (services, business logic)\n   - Mutation score >80% для core features\n\n3. **Quality gates:**\n   - Блокируйте merge при падении coverage\n   - Настройте SonarCloud/SonarQube quality profiles\n   - Отслеживайте technical debt\n   - Мониторьте code smells и duplication\n\n4. **Reporting:**\n   - Codecov для визуализации coverage trends\n   - Stryker Dashboard для mutation testing history\n   - SonarCloud для overall code quality\n   - Генерируйте HTML reports для CI artifacts",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 68,
          "question_number_in_chapter": 6,
          "question_chapter": 8,
          "question_title": "Accessibility Testing в Angular",
          "answer_markdown": "### Вопрос: Как реализовать comprehensive accessibility testing в Angular приложении? Какие инструменты и практики используются на production?\n\n**Ответ:**\n\n### Стратегия Accessibility Testing\n\nAccessibility testing (a11y) - критичный компонент quality assurance для senior разработчиков. Включает три уровня: автоматизированное тестирование, ручное тестирование, и интеграцию в CI/CD pipeline.\n\n### 1. Автоматизированное Accessibility Testing с axe-core\n\n**Установка и конфигурация:**\n\n```bash\nnpm install axe-core axe-playwright axe-jasmine-unit --save-dev\nnpm install @testing-library/angular @testing-library/jest-dom --save-dev\n```\n\n**Интеграция в Unit Tests (jasmine):**\n\n```typescript\n// accessibility.spec.ts\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { axe, toHaveNoViolations } from 'jasmine-axe';\nimport { AccessibleFormComponent } from './accessible-form.component';\n\nexpect.extend(toHaveNoViolations);\n\ndescribe('AccessibleFormComponent - a11y', () => {\n  let component: AccessibleFormComponent;\n  let fixture: ComponentFixture<AccessibleFormComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [AccessibleFormComponent]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(AccessibleFormComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should have no a11y violations', async () => {\n    const results = await axe(fixture.nativeElement);\n    expect(results).toHaveNoViolations();\n  });\n\n  it('should have proper ARIA labels on form inputs', async () => {\n    const results = await axe(fixture.nativeElement, {\n      rules: {\n        'label': { enabled: true },\n        'aria-required-attr': { enabled: true },\n        'aria-valid-attr-value': { enabled: true }\n      }\n    });\n\n    expect(results.violations.length).toBe(0);\n    results.passes.forEach(pass => {\n      console.log(`✓ ${pass.id}: ${pass.description}`);\n    });\n  });\n\n  it('should have proper heading hierarchy', async () => {\n    const headingViolations = await axe(fixture.nativeElement, {\n      rules: { 'heading-order': { enabled: true } }\n    });\n\n    expect(headingViolations.violations).toEqual([]);\n  });\n});\n```\n\n**Component с accessibility best practices:**\n\n```typescript\n// accessible-form.component.ts\nimport { Component, OnInit } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-accessible-form',\n  template: `\n    <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\" role=\"form\">\n      <!-- Proper heading hierarchy -->\n      <h1 id=\"form-title\">Регистрационная форма</h1>\n\n      <!-- Accessible input with label and error messaging -->\n      <div class=\"form-group\">\n        <label for=\"email-input\" class=\"form-label\">\n          Email адрес\n          <span aria-label=\"обязательное поле\" class=\"required\">*</span>\n        </label>\n        <input\n          id=\"email-input\"\n          type=\"email\"\n          formControlName=\"email\"\n          class=\"form-control\"\n          aria-describedby=\"email-error\"\n          [attr.aria-invalid]=\"isFieldInvalid('email')\"\n          required\n          autocomplete=\"email\"\n        />\n        <span\n          id=\"email-error\"\n          class=\"error-message\"\n          role=\"alert\"\n          *ngIf=\"isFieldInvalid('email')\"\n        >\n          {{ getErrorMessage('email') }}\n        </span>\n      </div>\n\n      <!-- Accessible checkbox with proper labels -->\n      <div class=\"form-group\">\n        <input\n          id=\"subscribe-checkbox\"\n          type=\"checkbox\"\n          formControlName=\"subscribe\"\n          class=\"form-checkbox\"\n        />\n        <label for=\"subscribe-checkbox\" class=\"checkbox-label\">\n          Подписаться на новости\n        </label>\n      </div>\n\n      <!-- Accessible select dropdown -->\n      <div class=\"form-group\">\n        <label for=\"country-select\">Страна (обязательное поле)</label>\n        <select\n          id=\"country-select\"\n          formControlName=\"country\"\n          class=\"form-select\"\n          required\n          aria-required=\"true\"\n        >\n          <option value=\"\">-- Выберите страну --</option>\n          <option *ngFor=\"let country of countries\" [value]=\"country\">\n            {{ country }}\n          </option>\n        </select>\n      </div>\n\n      <!-- Button with proper ARIA attributes -->\n      <button\n        type=\"submit\"\n        class=\"btn btn-primary\"\n        [disabled]=\"!form.valid\"\n        [attr.aria-busy]=\"isSubmitting\"\n      >\n        <span *ngIf=\"!isSubmitting\">Отправить</span>\n        <span *ngIf=\"isSubmitting\" aria-live=\"polite\">\n          Обработка...\n        </span>\n      </button>\n\n      <!-- Form validation summary for screen readers -->\n      <div\n        *ngIf=\"form.invalid && form.touched\"\n        role=\"alert\"\n        class=\"error-summary\"\n        aria-live=\"assertive\"\n        aria-atomic=\"true\"\n      >\n        <h2>Пожалуйста, исправьте следующие ошибки:</h2>\n        <ul>\n          <li *ngFor=\"let error of getFormErrors()\">\n            {{ error }}\n          </li>\n        </ul>\n      </div>\n    </form>\n  `,\n  styles: [`\n    .form-label { display: block; margin-bottom: 0.5rem; font-weight: 500; }\n    .required { color: red; }\n    .form-control { padding: 0.5rem; border: 1px solid #ccc; }\n    .form-control[aria-invalid=\"true\"] { border-color: red; }\n    .error-message { color: red; font-size: 0.875rem; margin-top: 0.25rem; display: block; }\n    .error-summary { background: #ffe6e6; padding: 1rem; margin: 1rem 0; }\n  `]\n})\nexport class AccessibleFormComponent implements OnInit {\n  form: FormGroup;\n  isSubmitting = false;\n  countries = ['Россия', 'США', 'Франция', 'Германия'];\n\n  constructor(private fb: FormBuilder) {\n    this.form = this.fb.group({\n      email: ['', [Validators.required, Validators.email]],\n      subscribe: [false],\n      country: ['', Validators.required]\n    });\n  }\n\n  ngOnInit(): void {}\n\n  isFieldInvalid(fieldName: string): boolean {\n    const field = this.form.get(fieldName);\n    return !!(field && field.invalid && (field.dirty || field.touched));\n  }\n\n  getErrorMessage(fieldName: string): string {\n    const field = this.form.get(fieldName);\n    if (field?.hasError('required')) return 'Это поле обязательно';\n    if (field?.hasError('email')) return 'Введите корректный email';\n    return '';\n  }\n\n  getFormErrors(): string[] {\n    const errors: string[] = [];\n    Object.keys(this.form.controls).forEach(key => {\n      const control = this.form.get(key);\n      if (control?.invalid) {\n        errors.push(this.getErrorMessage(key));\n      }\n    });\n    return errors;\n  }\n\n  onSubmit(): void {\n    if (this.form.valid) {\n      this.isSubmitting = true;\n      // Simulate API call\n      setTimeout(() => {\n        this.isSubmitting = false;\n        alert('Форма успешно отправлена');\n      }, 2000);\n    }\n  }\n}\n```\n\n### 2. Keyboard Navigation Testing\n\n```typescript\n// keyboard-navigation.spec.ts\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { DebugElement } from '@angular/core';\nimport { By } from '@angular/platform-browser';\nimport { TabNavComponent } from './tab-nav.component';\n\ndescribe('TabNavComponent - Keyboard Navigation', () => {\n  let component: TabNavComponent;\n  let fixture: ComponentFixture<TabNavComponent>;\n  let compiled: DebugElement;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [TabNavComponent]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(TabNavComponent);\n    component = fixture.componentInstance;\n    compiled = fixture.debugElement;\n    fixture.detectChanges();\n  });\n\n  it('should navigate tabs with Arrow keys', (done) => {\n    const tabs = compiled.queryAll(By.css('[role=\"tab\"]'));\n    const firstTab = tabs[0].nativeElement as HTMLElement;\n\n    // Focus первый таб\n    firstTab.focus();\n    expect(document.activeElement).toBe(firstTab);\n\n    // Simulate Arrow Right key\n    const rightArrowEvent = new KeyboardEvent('keydown', {\n      key: 'ArrowRight',\n      code: 'ArrowRight',\n      bubbles: true\n    });\n\n    firstTab.dispatchEvent(rightArrowEvent);\n    fixture.detectChanges();\n\n    fixture.whenStable().then(() => {\n      const secondTab = tabs[1].nativeElement as HTMLElement;\n      expect(document.activeElement).toBe(secondTab);\n      done();\n    });\n  });\n\n  it('should support Home/End keys for tab navigation', (done) => {\n    const tabs = compiled.queryAll(By.css('[role=\"tab\"]'));\n    const firstTab = tabs[0].nativeElement as HTMLElement;\n    const lastTab = tabs[tabs.length - 1].nativeElement as HTMLElement;\n\n    firstTab.focus();\n\n    // Simulate Home key\n    const homeEvent = new KeyboardEvent('keydown', {\n      key: 'Home',\n      code: 'Home',\n      bubbles: true\n    });\n\n    firstTab.dispatchEvent(homeEvent);\n    fixture.detectChanges();\n\n    fixture.whenStable().then(() => {\n      const endEvent = new KeyboardEvent('keydown', {\n        key: 'End',\n        code: 'End',\n        bubbles: true\n      });\n\n      lastTab.dispatchEvent(endEvent);\n      fixture.detectChanges();\n\n      expect(document.activeElement).toBe(lastTab);\n      done();\n    });\n  });\n\n  it('should trap focus within modal dialog', () => {\n    const modalElement = compiled.query(By.css('[role=\"dialog\"]'));\n    const focusableElements = modalElement.nativeElement.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    );\n\n    const firstElement = focusableElements[0] as HTMLElement;\n    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;\n\n    firstElement.focus();\n\n    // Simulate Shift+Tab on first element\n    const shiftTabEvent = new KeyboardEvent('keydown', {\n      key: 'Tab',\n      shiftKey: true,\n      bubbles: true\n    });\n\n    firstElement.dispatchEvent(shiftTabEvent);\n    fixture.detectChanges();\n\n    // Should cycle to last element (focus trap)\n    expect(document.activeElement).toBe(lastElement);\n  });\n});\n```\n\n**Компонент с keyboard navigation:**\n\n```typescript\n// tab-nav.component.ts\nimport { Component, OnInit, ViewChildren, QueryList, ElementRef } from '@angular/core';\n\n@Component({\n  selector: 'app-tab-nav',\n  template: `\n    <div class=\"tabs-container\">\n      <div role=\"tablist\" class=\"tab-buttons\">\n        <button\n          *ngFor=\"let tab of tabs; let i = index\"\n          #tabButtons\n          [id]=\"'tab-' + i\"\n          role=\"tab\"\n          [attr.aria-selected]=\"i === activeTab\"\n          [attr.aria-controls]=\"'panel-' + i\"\n          [attr.tabindex]=\"i === activeTab ? 0 : -1\"\n          class=\"tab-button\"\n          [class.active]=\"i === activeTab\"\n          (click)=\"selectTab(i)\"\n          (keydown)=\"onTabKeydown($event, i)\"\n        >\n          {{ tab }}\n        </button>\n      </div>\n\n      <div class=\"tab-panels\">\n        <div\n          *ngFor=\"let content of tabContents; let i = index\"\n          [id]=\"'panel-' + i\"\n          role=\"tabpanel\"\n          [attr.aria-labelledby]=\"'tab-' + i\"\n          [attr.hidden]=\"i !== activeTab\"\n          class=\"tab-panel\"\n        >\n          {{ content }}\n        </div>\n      </div>\n    </div>\n  `,\n  styles: [`\n    .tab-buttons { display: flex; border-bottom: 2px solid #ccc; }\n    .tab-button {\n      padding: 0.5rem 1rem;\n      background: none;\n      border: none;\n      cursor: pointer;\n      font-size: 1rem;\n    }\n    .tab-button[aria-selected=\"true\"] {\n      border-bottom: 2px solid blue;\n      font-weight: bold;\n    }\n    .tab-panel { padding: 1rem; }\n  `]\n})\nexport class TabNavComponent implements OnInit {\n  tabs = ['Tab 1', 'Tab 2', 'Tab 3'];\n  tabContents = ['Content 1', 'Content 2', 'Content 3'];\n  activeTab = 0;\n\n  @ViewChildren('tabButtons') tabButtons!: QueryList<ElementRef>;\n\n  ngOnInit(): void {}\n\n  selectTab(index: number): void {\n    this.activeTab = index;\n    this.setFocus(index);\n  }\n\n  onTabKeydown(event: KeyboardEvent, currentIndex: number): void {\n    let newIndex = currentIndex;\n\n    switch (event.key) {\n      case 'ArrowRight':\n      case 'ArrowDown':\n        event.preventDefault();\n        newIndex = (currentIndex + 1) % this.tabs.length;\n        break;\n      case 'ArrowLeft':\n      case 'ArrowUp':\n        event.preventDefault();\n        newIndex = (currentIndex - 1 + this.tabs.length) % this.tabs.length;\n        break;\n      case 'Home':\n        event.preventDefault();\n        newIndex = 0;\n        break;\n      case 'End':\n        event.preventDefault();\n        newIndex = this.tabs.length - 1;\n        break;\n      default:\n        return;\n    }\n\n    this.selectTab(newIndex);\n  }\n\n  private setFocus(index: number): void {\n    this.tabButtons.toArray()[index]?.nativeElement.focus();\n  }\n}\n```\n\n### 3. pa11y для E2E Accessibility Testing\n\n```bash\nnpm install pa11y pa11y-ci --save-dev\n```\n\n**pa11y конфигурация (.pa11yci.json):**\n\n```json\n{\n  \"runners\": [\"axe\", \"htmlcs\"],\n  \"standard\": \"WCAG2AA\",\n  \"timeout\": 10000,\n  \"wait\": 2000,\n  \"chromeLaunchConfig\": {\n    \"args\": [\"--no-sandbox\"]\n  },\n  \"urls\": [\n    \"http://localhost:4200/home\",\n    \"http://localhost:4200/about\",\n    \"http://localhost:4200/contact\"\n  ],\n  \"level\": \"error\",\n  \"includeWarnings\": true,\n  \"includeNotices\": false,\n  \"runners\": [\"axe\"]\n}\n```\n\n**Скрипт для запуска pa11y:**\n\n```bash\n#!/bin/bash\n# a11y-test.sh\n\necho \"Starting Angular development server...\"\nng serve &\nSERVER_PID=$!\n\nsleep 10\n\necho \"Running pa11y accessibility tests...\"\npa11y-ci\n\nTEST_RESULT=$?\n\nkill $SERVER_PID\n\nexit $TEST_RESULT\n```\n\n### 4. CI/CD Integration для Accessibility Testing\n\n**GitHub Actions workflow (.github/workflows/a11y.yml):**\n\n```yaml\nname: Accessibility Testing\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main, develop ]\n\njobs:\n  a11y-test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run unit tests with a11y checks\n        run: npm run test:a11y -- --watch=false --browsers=ChromeHeadless\n\n      - name: Build application\n        run: npm run build\n\n      - name: Run pa11y accessibility audit\n        run: |\n          npm install -g pa11y-ci\n          ng serve --configuration production &\n          sleep 10\n          pa11y-ci\n\n      - name: Generate a11y report\n        if: always()\n        uses: actions/upload-artifact@v3\n        with:\n          name: accessibility-report\n          path: a11y-report/\n\n  axe-scan:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n\n      - name: Install axe DevTools\n        run: npm install --save-dev @axe-devtools/cli\n\n      - name: Run axe scan\n        run: |\n          npm run build\n          npx axe --tags wcag2aa dist/app/\n```\n\n**package.json скрипты:**\n\n```json\n{\n  \"scripts\": {\n    \"test:a11y\": \"ng test --include='**/*.a11y.spec.ts'\",\n    \"test:a11y:watch\": \"ng test --include='**/*.a11y.spec.ts'\",\n    \"a11y:audit\": \"pa11y-ci\",\n    \"a11y:report\": \"pa11y-ci --reporter=json > a11y-report.json\"\n  }\n}\n```\n\n### 5. Lighthouse Performance и Accessibility\n\n```typescript\n// lighthouse.integration.spec.ts\nimport { lighthouse } from 'lighthouse';\n\ndescribe('Lighthouse Accessibility Audit', () => {\n  it('should achieve accessibility score > 90', async () => {\n    const options = {\n      logLevel: 'info',\n      output: 'json',\n      onlyCategories: ['accessibility'],\n      port: 9222\n    };\n\n    const runnerResult = await lighthouse('http://localhost:4200', options);\n    const scores = runnerResult?.lhr.categories;\n\n    expect(scores?.accessibility.score).toBeGreaterThan(0.9);\n    console.log(`Accessibility Score: ${scores?.accessibility.score * 100}`);\n  }, 30000);\n});\n```\n\n### Best Practices Summary\n\n| Практика | Инструмент | Когда применять |\n|----------|-----------|-----------------|\n| Автоматизированное сканирование | axe-core, pa11y | Каждый commit |\n| Keyboard navigation testing | Jasmine, Karma | Unit тесты компонентов |\n| E2E accessibility | Playwright + pa11y | Перед releases |\n| Performance a11y | Lighthouse CI | CI/CD pipeline |\n| Manual testing | Screen readers | Перед production deployment |\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 69,
          "question_number_in_chapter": 7,
          "question_chapter": 8,
          "question_title": "Performance Testing в Angular",
          "answer_markdown": "### Вопрос: Как настроить comprehensive performance testing для Angular приложения? Какие метрики важны для senior-уровня и как интегрировать Lighthouse в CI?\n\n**Ответ:**\n\n### Performance Testing Strategy\n\nPerformance testing на senior-уровне включает: метрики Web Vitals, load testing, benchmark тесты, и CI/CD интеграцию для гарантирования качества.\n\n### 1. Web Vitals и Lighthouse в Unit/E2E Tests\n\n**Установка:**\n\n```bash\nnpm install --save-dev lighthouse @lighthouse/cli\nnpm install --save web-vitals @web-vitals/attribution\nnpm install --save-dev k6\n```\n\n**Performance метрики тест:**\n\n```typescript\n// performance.spec.ts\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { PerformanceComponent } from './performance.component';\nimport { PerformanceMonitor } from './performance.monitor';\n\ndescribe('Performance Monitoring', () => {\n  let component: PerformanceComponent;\n  let fixture: ComponentFixture<PerformanceComponent>;\n  let monitor: PerformanceMonitor;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [PerformanceComponent],\n      providers: [PerformanceMonitor]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(PerformanceComponent);\n    component = fixture.componentInstance;\n    monitor = TestBed.inject(PerformanceMonitor);\n  });\n\n  describe('Core Web Vitals', () => {\n    it('should have LCP < 2.5s', async () => {\n      const lcpMetrics = await monitor.measureLCP();\n      expect(lcpMetrics.value).toBeLessThan(2500);\n    });\n\n    it('should have FID/INP < 100ms', async () => {\n      const inpMetrics = await monitor.measureINP();\n      expect(inpMetrics.value).toBeLessThan(100);\n    });\n\n    it('should have CLS < 0.1', async () => {\n      const clsMetrics = await monitor.measureCLS();\n      expect(clsMetrics.value).toBeLessThan(0.1);\n    });\n  });\n\n  describe('Custom Performance Metrics', () => {\n    it('should measure component render time', (done) => {\n      const startTime = performance.now();\n      fixture.detectChanges();\n      const endTime = performance.now();\n\n      const renderTime = endTime - startTime;\n      expect(renderTime).toBeLessThan(100); // < 100ms\n      done();\n    });\n\n    it('should measure API response time', async () => {\n      const metrics = await monitor.measureAPIResponseTime('/api/data');\n      expect(metrics.duration).toBeLessThan(1000); // < 1 second\n      expect(metrics.ttfb).toBeLessThan(200); // Time To First Byte < 200ms\n    });\n\n    it('should track memory usage', () => {\n      fixture.detectChanges();\n\n      const memoryBefore = (performance as any).memory?.usedJSHeapSize || 0;\n\n      // Perform operations\n      for (let i = 0; i < 1000; i++) {\n        component.addItem();\n      }\n\n      const memoryAfter = (performance as any).memory?.usedJSHeapSize || 0;\n      const memoryIncrease = memoryAfter - memoryBefore;\n\n      expect(memoryIncrease).toBeLessThan(5 * 1024 * 1024); // < 5MB\n    });\n  });\n\n  describe('DOM Performance', () => {\n    it('should have minimal reflows/repaints', (done) => {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const measures = entries.filter(e => e.entryType === 'measure');\n\n        expect(measures.length).toBeLessThan(10);\n        observer.disconnect();\n        done();\n      });\n\n      observer.observe({ entryTypes: ['measure'] });\n\n      performance.mark('start');\n      fixture.detectChanges();\n      performance.mark('end');\n      performance.measure('render', 'start', 'end');\n    });\n  });\n});\n```\n\n**Performance Monitor Service:**\n\n```typescript\n// performance.monitor.ts\nimport { Injectable } from '@angular/core';\nimport { onCLS, onFID, onFCP, onINP, onLCP, Metric } from 'web-vitals';\n\ninterface PerformanceMetric {\n  name: string;\n  value: number;\n  rating: 'good' | 'needs-improvement' | 'poor';\n  delta?: number;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PerformanceMonitor {\n  private metrics: Map<string, PerformanceMetric> = new Map();\n\n  constructor() {\n    this.initializeWebVitals();\n  }\n\n  private initializeWebVitals(): void {\n    // Largest Contentful Paint\n    onLCP((metric: Metric) => {\n      this.recordMetric('LCP', metric.value, this.getLCPRating(metric.value));\n    });\n\n    // Interaction to Next Paint\n    onINP((metric: Metric) => {\n      this.recordMetric('INP', metric.value, this.getINPRating(metric.value));\n    });\n\n    // Cumulative Layout Shift\n    onCLS((metric: Metric) => {\n      this.recordMetric('CLS', metric.value, this.getCLSRating(metric.value));\n    });\n\n    // First Contentful Paint\n    onFCP((metric: Metric) => {\n      this.recordMetric('FCP', metric.value, this.getFCPRating(metric.value));\n    });\n\n    // First Input Delay (deprecated, replaced by INP)\n    onFID((metric: Metric) => {\n      this.recordMetric('FID', metric.value, this.getFIDRating(metric.value));\n    });\n  }\n\n  private recordMetric(\n    name: string,\n    value: number,\n    rating: 'good' | 'needs-improvement' | 'poor'\n  ): void {\n    this.metrics.set(name, { name, value, rating });\n    console.log(`${name}: ${value.toFixed(2)}ms (${rating})`);\n  }\n\n  private getLCPRating(value: number): 'good' | 'needs-improvement' | 'poor' {\n    if (value <= 2500) return 'good';\n    if (value <= 4000) return 'needs-improvement';\n    return 'poor';\n  }\n\n  private getINPRating(value: number): 'good' | 'needs-improvement' | 'poor' {\n    if (value <= 200) return 'good';\n    if (value <= 500) return 'needs-improvement';\n    return 'poor';\n  }\n\n  private getCLSRating(value: number): 'good' | 'needs-improvement' | 'poor' {\n    if (value <= 0.1) return 'good';\n    if (value <= 0.25) return 'needs-improvement';\n    return 'poor';\n  }\n\n  private getFCPRating(value: number): 'good' | 'needs-improvement' | 'poor' {\n    if (value <= 1800) return 'good';\n    if (value <= 3000) return 'needs-improvement';\n    return 'poor';\n  }\n\n  private getFIDRating(value: number): 'good' | 'needs-improvement' | 'poor' {\n    if (value <= 100) return 'good';\n    if (value <= 300) return 'needs-improvement';\n    return 'poor';\n  }\n\n  async measureLCP(): Promise<PerformanceMetric> {\n    return new Promise(resolve => {\n      onLCP((metric: Metric) => {\n        resolve(this.metrics.get('LCP') || {\n          name: 'LCP',\n          value: metric.value,\n          rating: this.getLCPRating(metric.value)\n        });\n      });\n    });\n  }\n\n  async measureINP(): Promise<PerformanceMetric> {\n    return new Promise(resolve => {\n      onINP((metric: Metric) => {\n        resolve(this.metrics.get('INP') || {\n          name: 'INP',\n          value: metric.value,\n          rating: this.getINPRating(metric.value)\n        });\n      });\n    });\n  }\n\n  async measureCLS(): Promise<PerformanceMetric> {\n    return new Promise(resolve => {\n      onCLS((metric: Metric) => {\n        resolve(this.metrics.get('CLS') || {\n          name: 'CLS',\n          value: metric.value,\n          rating: this.getCLSRating(metric.value)\n        });\n      });\n    });\n  }\n\n  async measureAPIResponseTime(endpoint: string): Promise<{\n    duration: number;\n    ttfb: number;\n  }> {\n    const startTime = performance.now();\n\n    try {\n      const response = await fetch(endpoint);\n      const ttfb = performance.now() - startTime;\n      await response.arrayBuffer();\n      const duration = performance.now() - startTime;\n\n      return { duration, ttfb };\n    } catch (error) {\n      throw new Error(`API call failed: ${error}`);\n    }\n  }\n\n  getMetrics(): PerformanceMetric[] {\n    return Array.from(this.metrics.values());\n  }\n\n  generateReport(): string {\n    let report = '=== Performance Report ===\\n';\n    this.metrics.forEach(metric => {\n      report += `${metric.name}: ${metric.value.toFixed(2)}ms (${metric.rating})\\n`;\n    });\n    return report;\n  }\n}\n```\n\n### 2. Lighthouse CI Integration\n\n**Установка и конфигурация:**\n\n```bash\nnpm install --save-dev @lhci/cli@latest\n```\n\n**Конфигурация файла (lighthouserc.json):**\n\n```json\n{\n  \"ci\": {\n    \"collect\": {\n      \"url\": [\n        \"http://localhost:4200/\",\n        \"http://localhost:4200/about\",\n        \"http://localhost:4200/dashboard\"\n      ],\n      \"numberOfRuns\": 3,\n      \"staticDistDir\": \"./dist/app\",\n      \"headless\": true,\n      \"settings\": {\n        \"chromeFlags\": \"--no-sandbox --disable-gpu\",\n        \"throttling\": {\n          \"rttMs\": 40,\n          \"throughputKbps\": 10240,\n          \"cpuSlowdownMultiplier\": 1\n        }\n      }\n    },\n    \"assert\": {\n      \"assertMatrix\": [\n        {\n          \"matchingUrlPattern\": \".*\",\n          \"assertions\": {\n            \"categories:performance\": [\"error\", { \"minScore\": 0.85 }],\n            \"categories:accessibility\": [\"error\", { \"minScore\": 0.9 }],\n            \"categories:best-practices\": [\"error\", { \"minScore\": 0.85 }],\n            \"categories:seo\": [\"error\", { \"minScore\": 0.8 }]\n          }\n        }\n      ],\n      \"preset\": \"lighthouse:recommended\"\n    },\n    \"upload\": {\n      \"target\": \"filesystem\",\n      \"outputDir\": \"./lhci-results\",\n      \"reportDir\": \"./lhci-results\"\n    }\n  }\n}\n```\n\n### 3. Load Testing с k6\n\n```typescript\n// k6-load-test.js\nimport http from 'k6/http';\nimport { check, sleep, group } from 'k6';\nimport { Rate } from 'k6/metrics';\n\nconst errorRate = new Rate('errors');\n\nexport const options = {\n  stages: [\n    { duration: '30s', target: 20 },   // Ramp-up: 0->20 users\n    { duration: '1m30s', target: 100 }, // Ramp-up: 20->100 users\n    { duration: '1m', target: 100 },    // Stay at 100 users\n    { duration: '30s', target: 0 }      // Ramp-down: 100->0 users\n  ],\n  thresholds: {\n    http_req_duration: ['p(99)<1500'],   // 99th percentile < 1.5s\n    http_req_failed: ['rate<0.1'],       // Error rate < 10%\n    'errors': ['rate<0.5']               // Custom error metric < 50%\n  }\n};\n\nexport default function() {\n  // Test главной страницы\n  group('Homepage', function() {\n    const res = http.get('http://localhost:4200/');\n\n    const success = check(res, {\n      'status is 200': (r) => r.status === 200,\n      'page load < 1000ms': (r) => r.timings.duration < 1000,\n      'has content': (r) => r.body.includes('Angular App')\n    });\n\n    errorRate.add(!success);\n  });\n\n  sleep(1);\n\n  // Test API endpoint\n  group('API Calls', function() {\n    const res = http.get('http://localhost:4200/api/data');\n\n    const success = check(res, {\n      'API status 200': (r) => r.status === 200,\n      'API response time < 500ms': (r) => r.timings.duration < 500,\n      'response is JSON': (r) => r.headers['content-type'].includes('application/json')\n    });\n\n    errorRate.add(!success);\n  });\n\n  sleep(2);\n\n  // Test with payload\n  group('POST Requests', function() {\n    const payload = JSON.stringify({\n      name: 'Test User',\n      email: 'test@example.com'\n    });\n\n    const res = http.post('http://localhost:4200/api/users', payload, {\n      headers: { 'Content-Type': 'application/json' }\n    });\n\n    const success = check(res, {\n      'POST status 201': (r) => r.status === 201,\n      'response contains ID': (r) => r.json('id') !== null\n    });\n\n    errorRate.add(!success);\n  });\n\n  sleep(1);\n}\n```\n\n**Запуск load testing:**\n\n```bash\nk6 run k6-load-test.js\n```\n\n### 4. Benchmark Тесты\n\n```typescript\n// benchmark.spec.ts\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { HeavyListComponent } from './heavy-list.component';\n\ndescribe('Component Benchmarks', () => {\n  let component: HeavyListComponent;\n  let fixture: ComponentFixture<HeavyListComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [HeavyListComponent]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(HeavyListComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should render 1000 items < 500ms', () => {\n    component.items = Array.from({ length: 1000 }, (_, i) => ({\n      id: i,\n      title: `Item ${i}`,\n      description: `Description ${i}`\n    }));\n\n    const startTime = performance.now();\n    fixture.detectChanges();\n    const duration = performance.now() - startTime;\n\n    expect(duration).toBeLessThan(500);\n    console.log(`Rendered 1000 items in ${duration.toFixed(2)}ms`);\n  });\n\n  it('should filter 10000 items < 200ms', () => {\n    component.items = Array.from({ length: 10000 }, (_, i) => ({\n      id: i,\n      title: `Item ${i}`,\n      description: `Description ${i}`\n    }));\n\n    const startTime = performance.now();\n    const filtered = component.items.filter(item =>\n      item.title.includes('Item 5')\n    );\n    const duration = performance.now() - startTime;\n\n    expect(duration).toBeLessThan(200);\n    expect(filtered.length).toBeGreaterThan(0);\n  });\n\n  it('should sort 5000 items < 100ms', () => {\n    component.items = Array.from({ length: 5000 }, (_, i) => ({\n      id: Math.random(),\n      title: `Item ${i}`,\n      description: `Description ${i}`\n    }));\n\n    const startTime = performance.now();\n    const sorted = [...component.items].sort((a, b) =>\n      a.id - b.id\n    );\n    const duration = performance.now() - startTime;\n\n    expect(duration).toBeLessThan(100);\n    expect(sorted[0].id).toBeLessThanOrEqual(sorted[1].id);\n  });\n});\n```\n\n### 5. CI/CD Integration для Performance\n\n**GitHub Actions (.github/workflows/performance.yml):**\n\n```yaml\nname: Performance Testing\n\non:\n  pull_request:\n    branches: [ main, develop ]\n  push:\n    branches: [ main ]\n\njobs:\n  lighthouse:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Build application\n        run: npm run build -- --configuration production\n\n      - name: Install Lighthouse CI\n        run: npm install -g @lhci/cli@latest\n\n      - name: Run Lighthouse CI\n        run: lhci autorun\n\n      - name: Upload results\n        uses: actions/upload-artifact@v3\n        if: always()\n        with:\n          name: lighthouse-results\n          path: lhci-results/\n\n  performance-tests:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run performance benchmarks\n        run: npm run test:performance -- --watch=false\n\n      - name: Generate performance report\n        if: always()\n        run: npm run perf:report\n\n      - name: Comment PR with results\n        if: github.event_name == 'pull_request'\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const fs = require('fs');\n            const report = fs.readFileSync('performance-report.md', 'utf8');\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: report\n            });\n\n  load-test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup k6\n        uses: grafana/setup-k6-action@v1\n\n      - name: Build and start server\n        run: |\n          npm run build\n          npm start &\n          sleep 5\n\n      - name: Run load tests\n        run: k6 run k6-load-test.js --out json=results.json\n\n      - name: Upload k6 results\n        uses: actions/upload-artifact@v3\n        if: always()\n        with:\n          name: k6-results\n          path: results.json\n```\n\n---",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 70,
          "question_number_in_chapter": 8,
          "question_chapter": 8,
          "question_title": "Contract Testing для Frontend-Backend Integration",
          "answer_markdown": "### Вопрос: Как использовать Contract Testing (Pact) для гарантирования совместимости между Frontend и Backend? Какие практики применяются на production?\n\n**Ответ:**\n\n### Contract Testing Strategy\n\nContract Testing - методология для тестирования интеграции между микросервисами/frontend-backend без необходимости запуска обоих систем вместе. На senior-уровне это critical для масштабируемых систем.\n\n### 1. Pact Setup и Configuration\n\n**Установка:**\n\n```bash\nnpm install --save-dev @pact-foundation/pact @pact-foundation/pact-node\nnpm install --save-dev pact-broker\nnpm install axios  # для HTTP клиента\n```\n\n**Pact конфигурация (pact.config.ts):**\n\n```typescript\n// pact.config.ts\nimport { PactV3 } from '@pact-foundation/pact';\nimport path from 'path';\n\nexport const pactFrontendBE = new PactV3({\n  consumer: 'angular-frontend',\n  provider: 'backend-api',\n  logLevel: 'info',\n  dir: path.resolve(process.cwd(), 'pacts'),\n  spec: 3\n});\n\nexport const pactConfig = {\n  pactDirectory: path.resolve(process.cwd(), 'pacts'),\n  brokerUrl: process.env.PACT_BROKER_URL || 'http://localhost:8000',\n  brokerUsername: process.env.PACT_BROKER_USERNAME,\n  brokerPassword: process.env.PACT_BROKER_PASSWORD,\n  consumerVersion: process.env.GIT_COMMIT || 'dev',\n  tags: [process.env.GIT_BRANCH || 'main']\n};\n```\n\n### 2. Frontend Contract Tests (Consumer)\n\n```typescript\n// users.service.contract.spec.ts\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { UsersService } from './users.service';\nimport { PactV3 } from '@pact-foundation/pact';\nimport { expect } from 'chai';\nimport path from 'path';\n\ndescribe('UsersService - Contract Tests (Consumer)', () => {\n  let service: UsersService;\n  let httpTestingController: HttpClientTestingModule;\n\n  const pact = new PactV3({\n    consumer: 'angular-frontend',\n    provider: 'user-api',\n    logLevel: 'info',\n    dir: path.resolve(process.cwd(), 'pacts')\n  });\n\n  beforeAll(async () => {\n    await pact.setup();\n  });\n\n  afterAll(async () => {\n    await pact.finalize();\n  });\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [\n        {\n          provide: 'API_URL',\n          useValue: 'http://localhost:8000'\n        },\n        UsersService\n      ]\n    });\n    service = TestBed.inject(UsersService);\n  });\n\n  describe('GET /api/users', () => {\n    it('should return list of users', async () => {\n      const expectedUsers = [\n        {\n          id: 1,\n          name: 'John Doe',\n          email: 'john@example.com',\n          role: 'admin'\n        },\n        {\n          id: 2,\n          name: 'Jane Smith',\n          email: 'jane@example.com',\n          role: 'user'\n        }\n      ];\n\n      await pact\n        .addInteraction()\n        .given('users exist in the database')\n        .uponReceiving('a request for all users')\n        .withRequest('GET', '/api/users')\n        .willRespondWith(200, (builder) => {\n          return builder\n            .jsonFixture(expectedUsers)\n            .headers({ 'Content-Type': 'application/json' });\n        })\n        .executeTest(async (mockServer) => {\n          const users = await service.getUsers().toPromise();\n\n          expect(users).to.deep.equal(expectedUsers);\n          expect(users.length).to.equal(2);\n        });\n    });\n\n    it('should handle filter by role', async () => {\n      const adminUsers = [\n        {\n          id: 1,\n          name: 'John Doe',\n          email: 'john@example.com',\n          role: 'admin'\n        }\n      ];\n\n      await pact\n        .addInteraction()\n        .given('admin users exist')\n        .uponReceiving('a request for users with role=admin')\n        .withRequest('GET', '/api/users', (request) => {\n          return request.query({ role: 'admin' });\n        })\n        .willRespondWith(200, (builder) => {\n          return builder.jsonFixture(adminUsers);\n        })\n        .executeTest(async (mockServer) => {\n          const users = await service.getUsersByRole('admin').toPromise();\n\n          expect(users).to.have.lengthOf(1);\n          expect(users[0].role).to.equal('admin');\n        });\n    });\n  });\n\n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      const newUser = {\n        name: 'Alice Johnson',\n        email: 'alice@example.com',\n        role: 'user'\n      };\n\n      const createdUser = {\n        id: 3,\n        ...newUser\n      };\n\n      await pact\n        .addInteraction()\n        .given('user table is empty')\n        .uponReceiving('a request to create a new user')\n        .withRequest('POST', '/api/users', (request) => {\n          return request\n            .body(newUser)\n            .headers({ 'Content-Type': 'application/json' });\n        })\n        .willRespondWith(201, (builder) => {\n          return builder\n            .body(createdUser)\n            .headers({\n              'Content-Type': 'application/json',\n              'Location': '/api/users/3'\n            });\n        })\n        .executeTest(async (mockServer) => {\n          const result = await service.createUser(newUser).toPromise();\n\n          expect(result).to.deep.equal(createdUser);\n          expect(result.id).to.exist;\n        });\n    });\n  });\n\n  describe('GET /api/users/:id', () => {\n    it('should return user by id', async () => {\n      const user = {\n        id: 1,\n        name: 'John Doe',\n        email: 'john@example.com',\n        role: 'admin'\n      };\n\n      await pact\n        .addInteraction()\n        .given('user with id=1 exists')\n        .uponReceiving('a request for user with id 1')\n        .withRequest('GET', '/api/users/1')\n        .willRespondWith(200, (builder) => {\n          return builder.jsonFixture(user);\n        })\n        .executeTest(async (mockServer) => {\n          const result = await service.getUserById(1).toPromise();\n\n          expect(result).to.deep.equal(user);\n          expect(result.id).to.equal(1);\n        });\n    });\n\n    it('should return 404 for non-existent user', async () => {\n      await pact\n        .addInteraction()\n        .given('user with id=999 does not exist')\n        .uponReceiving('a request for non-existent user')\n        .withRequest('GET', '/api/users/999')\n        .willRespondWith(404, (builder) => {\n          return builder.body({\n            error: 'User not found',\n            statusCode: 404\n          });\n        })\n        .executeTest(async (mockServer) => {\n          try {\n            await service.getUserById(999).toPromise();\n            throw new Error('Should have thrown');\n          } catch (error) {\n            expect((error as any).status).to.equal(404);\n          }\n        });\n    });\n  });\n\n  describe('PUT /api/users/:id', () => {\n    it('should update user', async () => {\n      const updateData = {\n        name: 'John Smith',\n        email: 'john.smith@example.com'\n      };\n\n      const updatedUser = {\n        id: 1,\n        ...updateData,\n        role: 'admin'\n      };\n\n      await pact\n        .addInteraction()\n        .given('user with id=1 exists')\n        .uponReceiving('a request to update user')\n        .withRequest('PUT', '/api/users/1', (request) => {\n          return request\n            .body(updateData)\n            .headers({ 'Content-Type': 'application/json' });\n        })\n        .willRespondWith(200, (builder) => {\n          return builder.jsonFixture(updatedUser);\n        })\n        .executeTest(async (mockServer) => {\n          const result = await service.updateUser(1, updateData).toPromise();\n\n          expect(result.name).to.equal('John Smith');\n          expect(result.email).to.equal('john.smith@example.com');\n        });\n    });\n  });\n\n  describe('DELETE /api/users/:id', () => {\n    it('should delete user', async () => {\n      await pact\n        .addInteraction()\n        .given('user with id=1 exists')\n        .uponReceiving('a request to delete user')\n        .withRequest('DELETE', '/api/users/1')\n        .willRespondWith(204)\n        .executeTest(async (mockServer) => {\n          const result = await service.deleteUser(1).toPromise();\n\n          expect(result).to.be.undefined;\n        });\n    });\n  });\n});\n```\n\n**UsersService (consumer):**\n\n```typescript\n// users.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient, HttpParams } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\nexport interface User {\n  id: number;\n  name: string;\n  email: string;\n  role: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UsersService {\n  private apiUrl = '/api/users';\n\n  constructor(private http: HttpClient) {}\n\n  getUsers(): Observable<User[]> {\n    return this.http.get<User[]>(this.apiUrl);\n  }\n\n  getUsersByRole(role: string): Observable<User[]> {\n    const params = new HttpParams().set('role', role);\n    return this.http.get<User[]>(this.apiUrl, { params });\n  }\n\n  getUserById(id: number): Observable<User> {\n    return this.http.get<User>(`${this.apiUrl}/${id}`);\n  }\n\n  createUser(user: Omit<User, 'id'>): Observable<User> {\n    return this.http.post<User>(this.apiUrl, user);\n  }\n\n  updateUser(id: number, user: Partial<User>): Observable<User> {\n    return this.http.put<User>(`${this.apiUrl}/${id}`, user);\n  }\n\n  deleteUser(id: number): Observable<void> {\n    return this.http.delete<void>(`${this.apiUrl}/${id}`);\n  }\n}\n```\n\n### 3. Schema Validation Testing\n\n```typescript\n// api-schema.spec.ts\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { UsersService } from './users.service';\nimport Ajv from 'ajv';\n\ndescribe('API Schema Validation', () => {\n  let service: UsersService;\n  let httpMock: HttpTestingController;\n  let ajv: Ajv;\n\n  const userSchema = {\n    type: 'object',\n    properties: {\n      id: { type: 'number', minimum: 1 },\n      name: { type: 'string', minLength: 1, maxLength: 100 },\n      email: { type: 'string', format: 'email' },\n      role: { type: 'string', enum: ['admin', 'user', 'guest'] }\n    },\n    required: ['id', 'name', 'email', 'role'],\n    additionalProperties: false\n  };\n\n  const usersListSchema = {\n    type: 'array',\n    items: userSchema,\n    minItems: 0\n  };\n\n  const errorSchema = {\n    type: 'object',\n    properties: {\n      error: { type: 'string' },\n      statusCode: { type: 'number' }\n    },\n    required: ['error', 'statusCode']\n  };\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [UsersService]\n    });\n\n    service = TestBed.inject(UsersService);\n    httpMock = TestBed.inject(HttpTestingController);\n    ajv = new Ajv();\n  });\n\n  afterEach(() => {\n    httpMock.verify();\n  });\n\n  it('should validate GET /api/users response schema', () => {\n    const mockUsers = [\n      { id: 1, name: 'John', email: 'john@example.com', role: 'admin' },\n      { id: 2, name: 'Jane', email: 'jane@example.com', role: 'user' }\n    ];\n\n    service.getUsers().subscribe((users) => {\n      const validate = ajv.compile(usersListSchema);\n      const isValid = validate(users);\n\n      expect(isValid).toBe(true);\n      if (!isValid) {\n        console.error('Validation errors:', validate.errors);\n      }\n    });\n\n    const req = httpMock.expectOne('/api/users');\n    expect(req.request.method).toBe('GET');\n    req.flush(mockUsers);\n  });\n\n  it('should validate single user schema', () => {\n    const mockUser = {\n      id: 1,\n      name: 'John Doe',\n      email: 'john@example.com',\n      role: 'admin'\n    };\n\n    service.getUserById(1).subscribe((user) => {\n      const validate = ajv.compile(userSchema);\n      const isValid = validate(user);\n\n      expect(isValid).toBe(true);\n    });\n\n    const req = httpMock.expectOne('/api/users/1');\n    req.flush(mockUser);\n  });\n\n  it('should reject invalid response schema', () => {\n    const invalidUser = {\n      id: 1,\n      name: 'John',\n      email: 'invalid-email',  // Invalid email format\n      role: 'invalid-role'      // Not in enum\n    };\n\n    const validate = ajv.compile(userSchema);\n    const isValid = validate(invalidUser);\n\n    expect(isValid).toBe(false);\n    expect(validate.errors).toBeDefined();\n  });\n\n  it('should validate error responses', () => {\n    const errorResponse = {\n      error: 'User not found',\n      statusCode: 404\n    };\n\n    const validate = ajv.compile(errorSchema);\n    const isValid = validate(errorResponse);\n\n    expect(isValid).toBe(true);\n  });\n\n  it('should validate request payload schema before sending', () => {\n    const newUser = {\n      name: 'Alice',\n      email: 'alice@example.com',\n      role: 'user'\n    };\n\n    const createUserSchema = {\n      type: 'object',\n      properties: {\n        name: { type: 'string', minLength: 1 },\n        email: { type: 'string', format: 'email' },\n        role: { type: 'string', enum: ['admin', 'user', 'guest'] }\n      },\n      required: ['name', 'email', 'role']\n    };\n\n    const validate = ajv.compile(createUserSchema);\n    expect(validate(newUser)).toBe(true);\n\n    service.createUser(newUser).subscribe();\n\n    const req = httpMock.expectOne('/api/users');\n    expect(req.request.body).toEqual(newUser);\n    req.flush({ id: 3, ...newUser });\n  });\n});\n```\n\n### 4. API Mocking для Tests\n\n```typescript\n// mock-api.interceptor.ts\nimport { Injectable } from '@angular/core';\nimport {\n  HttpInterceptor,\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpResponse\n} from '@angular/common/http';\nimport { Observable, of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\n@Injectable()\nexport class MockAPIInterceptor implements HttpInterceptor {\n  private mockData = {\n    '/api/users': [\n      { id: 1, name: 'John Doe', email: 'john@example.com', role: 'admin' },\n      { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'user' }\n    ]\n  };\n\n  intercept(\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    // Only mock in test environment\n    if (!this.shouldMock(request)) {\n      return next.handle(request);\n    }\n\n    const { method, url } = request;\n\n    if (method === 'GET' && url.includes('/api/users')) {\n      if (url.match(/\\/api\\/users\\/\\d+$/)) {\n        // GET /api/users/:id\n        const id = parseInt(url.split('/').pop() || '0', 10);\n        const user = (this.mockData['/api/users'] as any[]).find(u => u.id === id);\n\n        if (user) {\n          return of(new HttpResponse({ status: 200, body: user })).pipe(delay(100));\n        } else {\n          return of(new HttpResponse({\n            status: 404,\n            body: { error: 'User not found', statusCode: 404 }\n          })).pipe(delay(100));\n        }\n      } else {\n        // GET /api/users\n        return of(new HttpResponse({\n          status: 200,\n          body: this.mockData['/api/users']\n        })).pipe(delay(100));\n      }\n    }\n\n    if (method === 'POST' && url.includes('/api/users')) {\n      const newUser = { id: 3, ...request.body };\n      return of(new HttpResponse({ status: 201, body: newUser })).pipe(delay(100));\n    }\n\n    if (method === 'PUT' && url.includes('/api/users')) {\n      const updatedUser = { id: parseInt(url.split('/').pop() || '0', 10), ...request.body };\n      return of(new HttpResponse({ status: 200, body: updatedUser })).pipe(delay(100));\n    }\n\n    if (method === 'DELETE' && url.includes('/api/users')) {\n      return of(new HttpResponse({ status: 204 })).pipe(delay(100));\n    }\n\n    return next.handle(request);\n  }\n\n  private shouldMock(request: HttpRequest<any>): boolean {\n    return request.url.includes('/api/');\n  }\n}\n```\n\n**Использование в тестах:**\n\n```typescript\n// users.component.spec.ts\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { UsersComponent } from './users.component';\nimport { UsersService } from './users.service';\nimport { MockAPIInterceptor } from './mock-api.interceptor';\n\ndescribe('UsersComponent', () => {\n  let component: UsersComponent;\n  let fixture: ComponentFixture<UsersComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [UsersComponent],\n      imports: [HttpClientTestingModule],\n      providers: [\n        UsersService,\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: MockAPIInterceptor,\n          multi: true\n        }\n      ]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(UsersComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should load users from mocked API', () => {\n    fixture.detectChanges();\n\n    expect(component.users.length).toEqual(2);\n    expect(component.users[0].name).toEqual('John Doe');\n  });\n});\n```\n\n### 5. CI/CD Integration для Contract Testing\n\n**GitHub Actions (.github/workflows/contract-testing.yml):**\n\n```yaml\nname: Contract Testing\n\non:\n  pull_request:\n    branches: [ main, develop ]\n  push:\n    branches: [ main, develop ]\n\njobs:\n  contract-test:\n    runs-on: ubuntu-latest\n\n    services:\n      pact-broker:\n        image: pactfoundation/pact-broker:2.96.0\n        ports:\n          - 8000:8000\n        environment:\n          PACT_BROKER_DATABASE_URL: 'sqlite:////tmp/pact_broker.sqlite'\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run consumer contract tests\n        run: npm run test:contracts\n        env:\n          PACT_BROKER_URL: http://localhost:8000\n\n      - name: Publish contracts to Pact Broker\n        run: npm run pact:publish\n        if: github.event_name == 'push'\n        env:\n          PACT_BROKER_URL: http://localhost:8000\n\n      - name: Verify API compatibility\n        run: npm run pact:verify\n        env:\n          PACT_BROKER_URL: http://localhost:8000\n\n      - name: Generate contract report\n        if: always()\n        run: npm run pact:report\n\n      - name: Upload contract report\n        uses: actions/upload-artifact@v3\n        if: always()\n        with:\n          name: contract-test-report\n          path: pact-report/\n\n  schema-validation:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Validate API schemas\n        run: npm run test:schemas\n\n      - name: Generate schema report\n        if: always()\n        run: npm run schema:report\n\n      - name: Comment PR with schema validation\n        if: github.event_name == 'pull_request'\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const fs = require('fs');\n            const report = fs.readFileSync('schema-validation-report.md', 'utf8');\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: report\n            });\n```\n\n**package.json скрипты:**\n\n```json\n{\n  \"scripts\": {\n    \"test:contracts\": \"jasmine --config=jasmine.contract.json\",\n    \"test:contracts:watch\": \"jasmine --config=jasmine.contract.json --watch\",\n    \"pact:publish\": \"pact-broker publish pacts --consumer-app-version=$GIT_COMMIT --tag=$GIT_BRANCH\",\n    \"pact:verify\": \"pact-broker can-i-deploy --pacticipant=angular-frontend --version=$GIT_COMMIT --tag=$GIT_BRANCH\",\n    \"pact:report\": \"pact-broker generate-changelog --pacticipant=angular-frontend\",\n    \"test:schemas\": \"jasmine --config=jasmine.schema.json\",\n    \"schema:report\": \"node scripts/generate-schema-report.js\"\n  }\n}\n```\n\n### Best Practices Summary\n\n| Практика | Инструмент | Когда применять |\n|----------|-----------|-----------------|\n| Consumer Contract | Pact + Jasmine | При разработке frontend-backend интеграции |\n| Schema Validation | AJV | Проверка структуры response/request |\n| API Mocking | MockAPIInterceptor | Unit/Integration тесты компонентов |\n| Pact Broker | Docker | Хранение и верификация контрактов |\n| CI/CD Contract | GitHub Actions | Каждый push/PR для гарантии совместимости |",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    }
  ],
  "guide_name": "Angular - Гайд для подготовки к интервью (Senior уровень)"
}
